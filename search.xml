<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring 核心 01 - 深度學習路徑與 ApplicationContext 概覽</title>
      <link href="/2025/08/29/java-spring-core-01/"/>
      <url>/2025/08/29/java-spring-core-01/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：從「知其然」到「知其所以然」"><a href="#前言：從「知其然」到「知其所以然」" class="headerlink" title="前言：從「知其然」到「知其所以然」"></a>前言：從「知其然」到「知其所以然」</h2><p>歡迎來到「Spring 核心實戰」系列！</p><p>如果說「Spring Series 基礎」是教我們如何駕駛一輛名為 Spring Boot 的高性能跑車——如何啟動、加速、轉彎；那麼這個「核心實戰」系列，則是邀請您打開發動機蓋，親手探究其內部引擎的精密構造與運作原理。</p><p>我們在基礎系列的第 6 篇中，已經初步了解了 IoC (控制反轉) 與 DI (依賴注入) 的<strong>概念</strong>。我們知道，我們不再需要手動 <code>new</code> 物件，Spring 會為我們代勞。但這背後的「魔法」究竟是如何發生的？當魔法失靈時（例如 Bean 無法建立、依賴找不到、出現循環依賴），我們又該如何像一位經驗豐富的技師一樣，從容地診斷並修復問題？</p><p>本系列旨在回答這些「為什麼」。理解 Spring 的核心原理，是您從一位框架的「使用者」，蛻變為一位能駕馭框架、解決複雜問題的「掌控者」的必經之路。</p><h2 id="Spring-的心臟：ApplicationContext"><a href="#Spring-的心臟：ApplicationContext" class="headerlink" title="Spring 的心臟：ApplicationContext"></a>Spring 的心臟：<code>ApplicationContext</code></h2><p>在每一個 Spring 應用程式的背後，都有一個看不見的強大引擎在運轉，它的名字就是 <strong><code>ApplicationContext</code><strong>。它就是我們常說的「</strong>Spring IoC 容器</strong>」。</p><p>您可以將 <code>ApplicationContext</code> 想像成您應用程式的「總經理」。這位總經理在應用程式啟動時，會讀取所有的「員工名冊」（也就是 Bean 的定義），然後負責：</p><ol><li>**招募員工 (Bean Lifecycle Management)**：根據名冊，建立並實例化所有員工 (Beans)。</li><li>**分配工具 (Dependency Injection)**：為每一位員工，配發他們工作所需的工具（也就是他們所依賴的其他 Beans）。</li><li>**提供資源 (Resource Loading)**：管理並提供應用程式所需的各種外部資源。</li><li>**發布公司公告 (Event Publishing)**：建立一個事件廣播機制，讓各個部門（元件）之間可以解耦地進行溝通。</li></ol><p>我們後續的所有學習，都將圍繞著這位「總經理」如何管理它的「員工們 (Beans)」來展開。</p><h2 id="「Spring-核心實戰」完整學習地圖"><a href="#「Spring-核心實戰」完整學習地圖" class="headerlink" title="「Spring 核心實戰」完整學習地圖"></a>「Spring 核心實戰」完整學習地圖</h2><hr><h3 id="Spring-核心-02-Bean-的定義與註冊"><a href="#Spring-核心-02-Bean-的定義與註冊" class="headerlink" title="Spring 核心 02 - Bean 的定義與註冊"></a><strong><code>Spring 核心 02 - Bean 的定義與註冊</code></strong></h3><ul><li><strong>我們面臨的問題</strong>：我們知道 <code>@Service</code> 和 <code>@Component</code> 能建立 Bean，在 <code>@Configuration</code> 類別中使用 <code>@Bean</code> 方法也能建立 Bean。它們有什麼不同？我應該在什麼時候使用哪一種？Spring 又是如何發現這些散落在各處的 Bean 定義的？</li><li><strong>本篇學習目標</strong>：本篇將深入探討 Spring IoC 容器的「員工名冊」是如何建立的。我們將比較<strong>元件掃描 (<code>@ComponentScan</code>)</strong> 與 <strong>Java 組態 (<code>@Configuration</code>)</strong> 這兩種主流的 Bean 定義方式，分析其各自的優劣與適用場景，並學習如何透過 <code>@Import</code> 來實現組態的模組化。</li></ul><hr><h3 id="Spring-核心-03-精通-Bean-的作用域-Scope"><a href="#Spring-核心-03-精通-Bean-的作用域-Scope" class="headerlink" title="Spring 核心 03 - 精通 Bean 的作用域 (Scope)"></a><strong><code>Spring 核心 03 - 精通 Bean 的作用域 (Scope)</code></strong></h3><ul><li><strong>我們面臨的問題</strong>：預設情況下，<code>UserService</code> 在整個應用程式中只有一個實例 (Singleton)。但如果我們需要一個物件，是每次請求時都是全新的實例呢？或者在 Web 應用中，我們希望某個物件（例如購物車）的生命週期能與使用者的 Session 綁定，該怎麼做？</li><li><strong>本篇學習目標</strong>：我們將探索 Bean 的不同「生命型態」。本篇將帶您深入 <code>singleton</code>, <code>prototype</code> 以及 Web 環境下的 <code>request</code>, <code>session</code> 等核心作用域，理解它們的行為差異、適用情境，以及在使用時可能遇到的陷阱。</li></ul><hr><h3 id="Spring-核心-04-Bean-的完整生命週期"><a href="#Spring-核心-04-Bean-的完整生命週期" class="headerlink" title="Spring 核心 04 - Bean 的完整生命週期"></a><strong><code>Spring 核心 04 - Bean 的完整生命週期</code></strong></h3><ul><li><strong>我們面臨的問題</strong>：當一個 Bean 被建立後，我們常常需要在它被正式使用前，執行一些初始化操作（例如：讀取初始資料、建立網路連線）。同樣地，當應用程式關閉時，我們也希望能優雅地釋放資源。該如何可靠地掛載這些行為？</li><li><strong>本篇學習目標</strong>：我們將像紀錄片一樣，追蹤一個 Bean 從「誕生」到「消亡」的完整過程。您將學習 Bean 生命週期中的各個關鍵階段，並掌握 Spring 推薦的現代化回呼 (Callback) 機制——**<code>@PostConstruct</code>** 與 <strong><code>@PreDestroy</code></strong> 註解。</li></ul><hr><h3 id="Spring-核心-05-進階依賴注入與條件化組態"><a href="#Spring-核心-05-進階依賴注入與條件化組態" class="headerlink" title="Spring 核心 05 - 進階依賴注入與條件化組態"></a><strong><code>Spring 核心 05 - 進階依賴注入與條件化組態</code></strong></h3><ul><li><strong>我們面臨的問題</strong>：應用程式啟動失敗，日誌上顯示著可怕的「循環依賴 (Circular Dependency)」錯誤。或者，當有多個 Bean 實作了同一個介面時，Spring 拋出例外，抱怨它「不知道該注入哪一個」。如何解決這些棘手的依賴注入問題？</li><li><strong>本篇學習目標</strong>：我們將成為依賴注入的「拆彈專家」。本篇將教您如何使用 <code>@Primary</code> 和 <code>@Qualifier</code> 來解決注入衝突，使用 <code>@Lazy</code> 來打斷循環依賴，並最終揭密 Spring Boot 自動設定背後的終極武器——**<code>@Conditional</code>** 系列註解。</li></ul><hr><h3 id="旅程的目標"><a href="#旅程的目標" class="headerlink" title="旅程的目標"></a><strong>旅程的目標</strong></h3><p>完成這個系列後，Spring 對您來說將不再是一個「黑盒子」。您將具備從框架底層原理出發，去分析和解決複雜組態問題的能力。這份底氣，將讓您在未來的開發與架構設計之路上，走得更穩、更遠。</p><p>準備好打開引擎蓋了嗎？讓我們從下一篇文章「**<code>Spring 核心 02 - Bean 的定義與註冊</code>**」開始，深入探索 Spring IoC 容器的內部世界。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring 核心實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Spring Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenAPI 實戰 05 - 全域組態與最佳實踐</title>
      <link href="/2025/08/26/java-spring-openapi-05/"/>
      <url>/2025/08/26/java-spring-openapi-05/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：當註解變得重複"><a href="#前言：當註解變得重複" class="headerlink" title="前言：當註解變得重複"></a>前言：當註解變得重複</h2><p>在前面的文章中，我們學會了使用一系列的註解來豐富我們的 API 文件。但隨著專案規模的擴大，一些問題也隨之浮現：</p><ul><li>如果公司名稱或聯絡信箱變更了，我們是否要去修改多個 <code>@Tag</code> 或 <code>@Operation</code> 嗎？</li><li>我們的 API 會被部署到開發、測試、生產等多個環境，它們有著不同的 URL。如何在文件中體現這一點，讓測試者可以方便地切換？</li><li>是否有辦法為所有 API 一起加上某些通用設定，而不用在每個 Controller 上都重複貼上相同的註解？</li></ul><p>這些問題都指向同一個解決方案：<strong>集中化的全域組態</strong>。本篇文章將帶您擴充我們在上一篇中建立的 <code>OpenAPI</code> Bean，學習如何透過程式化的方式，來集中管理文件的元數據 (Metadata)、伺服器資訊，並在最後為整個系列總結 API 文件的最佳實踐。</p><h2 id="程式化設定：OpenAPI-Bean-的威力"><a href="#程式化設定：OpenAPI-Bean-的威力" class="headerlink" title="程式化設定：OpenAPI Bean 的威力"></a>程式化設定：<code>OpenAPI</code> Bean 的威力</h2><p>我們在 <code>config/OpenApiConfig.java</code> 中建立的 <code>OpenAPI</code> Bean，是我們進行全域客製化的中樞。它代表了整個 OpenAPI 規格的根物件，透過設定這個物件的屬性，我們就能控制最終產生的文件的每一個角落。</p><h2 id="設定文件基本資訊-Info"><a href="#設定文件基本資訊-Info" class="headerlink" title="設定文件基本資訊 (Info)"></a>設定文件基本資訊 (Info)</h2><p><code>Info</code> 物件定義了 API 文件的「封面頁」，包含了標題、描述、版本、服務條款、聯絡人與授權資訊。一個資訊完整的封面，能讓文件的使用者第一眼就了解這個 API 的用途與背景。</p><p>讓我們來擴充 <code>OpenApiConfig.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in config/OpenApiConfig.java</span></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Contact;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Info;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.License;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenApiConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OpenAPI <span class="title function_">customOpenAPI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">securitySchemeName</span> <span class="operator">=</span> <span class="string">&quot;bearerAuth&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">            <span class="comment">// 1. 設定文件的基本資訊</span></span><br><span class="line">            .info(<span class="keyword">new</span> <span class="title class_">Info</span>()</span><br><span class="line">                .title(<span class="string">&quot;Spring Series 專案 API 文件&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;這是一份使用 springdoc-openapi 自動產生的 API 文件，&quot;</span> + </span><br><span class="line">                             <span class="string">&quot;涵蓋了使用者管理與相關操作。&quot;</span>)</span><br><span class="line">                .termsOfService(<span class="string">&quot;https://example.com/terms&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>().name(<span class="string">&quot;開發團隊&quot;</span>).email(<span class="string">&quot;dev@example.com&quot;</span>))</span><br><span class="line">                .license(<span class="keyword">new</span> <span class="title class_">License</span>().name(<span class="string">&quot;Apache 2.0&quot;</span>).url(<span class="string">&quot;https://springdoc.org&quot;</span>))</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// ... 保留上一篇的 addSecurityItem 和 components 設定 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新啟動應用並刷新 Swagger UI，您會發現頁面的最頂部，已經顯示出我們剛剛設定的所有詳細資訊，顯得非常專業。</p><h2 id="定義多環境伺服器-Servers"><a href="#定義多環境伺服器-Servers" class="headerlink" title="定義多環境伺服器 (Servers)"></a>定義多環境伺服器 (Servers)</h2><p><strong>問題</strong>：API 的使用者（例如前端工程師）可能需要在本機、開發伺服器、測試伺服器之間切換來進行測試。如果文件中只顯示 <code>localhost</code>，將會非常不便。</p><p><strong>解決方案</strong>：我們可以定義一個 <code>Server</code> 物件列表，讓使用者可以在 Swagger UI 上自由切換要發送請求的目標伺服器。</p><p>繼續修改 <code>OpenApiConfig.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in config/OpenApiConfig.java</span></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.servers.Server;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> OpenAPI <span class="title function_">customOpenAPI</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">        .info(<span class="keyword">new</span> <span class="title class_">Info</span>()...) <span class="comment">// ... 接續上面的 info 設定 ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 設定多個伺服器環境</span></span><br><span class="line">        .servers(List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Server</span>().url(<span class="string">&quot;http://localhost:8080&quot;</span>).description(<span class="string">&quot;本機開發環境 (DEV)&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Server</span>().url(<span class="string">&quot;https://staging.example.com&quot;</span>).description(<span class="string">&quot;測試環境 (Staging)&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Server</span>().url(<span class="string">&quot;https://api.example.com&quot;</span>).description(<span class="string">&quot;生產環境 (PROD)&quot;</span>)</span><br><span class="line">        ))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... 接續後面的 addSecurityItem 和 components 設定 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次刷新 Swagger UI，您會發現在文件標題的下方，出現了一個伺服器列表的<strong>下拉選單</strong>。使用者可以在這裡選擇要對哪個環境的伺服器發送 “Try it out” 請求，這極大地提升了文件的實用性。</p><h2 id="API-文件設計的最佳實踐"><a href="#API-文件設計的最佳實踐" class="headerlink" title="API 文件設計的最佳實踐"></a>API 文件設計的最佳實踐</h2><p>恭喜您！至此，您已經掌握了 <code>springdoc-openapi</code> 從基礎到進階的絕大部分核心功能。在我們結束這個系列之前，讓我們總結一下打造一份卓越 API 文件的最佳實踐：</p><ol><li><strong>為所有公開端點提供文件</strong>：確保每一個提供給外部使用的 API 都被文件化，沒有任何遺漏。</li><li>**使用清晰且一致的命名 (<code>@Tag</code>, <code>@Operation</code>)**：<ul><li>使用 <code>@Tag</code> 將關聯的 API 歸類在一起，例如「使用者管理」、「訂單管理」。</li><li>使用「動詞 + 名詞」的模式來撰寫 <code>@Operation</code> 的 <code>summary</code>，例如「建立使用者」、「查詢特定訂單」。</li></ul></li><li>**詳盡描述資料模型 (<code>@Schema</code>)**：<ul><li>為 DTO 的每一個屬性都提供 <code>description</code> 和 <code>example</code>。</li><li>明確標示 <code>requiredMode</code>，並盡可能提供 <code>minLength</code>, <code>pattern</code> 等驗證提示。</li></ul></li><li>**定義所有可能的回應 (<code>@ApiResponses</code>)**：<ul><li>除了 <code>200</code> 成功的回應，務必也要定義常見的錯誤回應，如 <code>400</code> (請求錯誤)、<code>401</code> (未授權)、<code>404</code> (找不到資源)、<code>500</code> (伺服器內部錯誤)。</li></ul></li><li>**提供豐富的範例 (<code>@ExampleObject</code>)**：對於複雜的請求本文，提供多個不同情境的範例，會遠比文字描述更有效。</li><li>**明確標示安全性 (<code>SecurityScheme</code>)**：確保所有受保護的 API 都有對應的安全性定義，並讓文件本身具備互動測試的能力。</li><li>**集中管理全域設定 (<code>OpenAPI</code> Bean)**：善用程式化的 Bean 組態，將通用資訊（如 <code>Info</code>, <code>Servers</code>, 全域 <code>SecurityRequirement</code>）集中管理，保持程式碼的 DRY (Don’t Repeat Yourself) 原則。</li></ol><h2 id="旅程總結：從程式碼到溝通的橋樑"><a href="#旅程總結：從程式碼到溝通的橋樑" class="headerlink" title="旅程總結：從程式碼到溝通的橋樑"></a>旅程總結：從程式碼到溝通的橋樑</h2><p>在這五篇文章的旅程中，我們從一份陽春的、自動產生的 API 列表開始，一步步地為它添加了豐富的描述、清晰的資料模型、明確的安全規則，並最終學會了如何集中化地管理這份文件的全域設定。</p><p>希望您能體會到，一份好的 API 文件，其價值遠不止於「有就好」。它是在開發團隊中建立「共同語言」的基石，是縮短前後端、測試與維運人員之間溝通鴻溝的橋樑。它能將隱晦的程式碼邏輯，轉化為清晰、明確、無歧義的技術合約。</p><p>掌握 API 文件的藝術，將是您在專業開發者道路上，一項極具價值的軟技能。感謝您完成「OpenAPI 實戰」系列！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> OpenAPI 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> OpenAPI </tag>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenAPI 實戰 04 - 定義安全性方案 (Security Schemes)</title>
      <link href="/2025/08/26/java-spring-openapi-04/"/>
      <url>/2025/08/26/java-spring-openapi-04/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：解鎖被保護的-API"><a href="#前言：解鎖被保護的-API" class="headerlink" title="前言：解鎖被保護的 API"></a>前言：解鎖被保護的 API</h2><p>我們已經成功地為 API 打造了一份內容豐富的文件。但此刻，這份文件正面臨一個巨大的尷尬：它無法使用。</p><p>當我們嘗試在 Swagger UI 上點擊 “Try it out” 來測試任何受保護的端點時（例如 <code>GET /users</code>），迎來的總是一個紅色的 <code>401 Unauthorized</code> 或 <code>403 Forbidden</code> 錯誤。原因很簡單：我們的應用程式受 JWT 保護，但 API 文件本身卻對此一無所知，它發出的請求中，並未包含必要的 <code>Authorization</code> 標頭。</p><p>這使得文件的互動性大打折扣，開發者依然需要回到 Postman 等工具來進行測試。本篇文章的目標，就是打通這「最後一哩路」。我們將學習如何設定 OpenAPI，使其完全理解我們的 JWT 驗證機制，這會在 Swagger UI 上新增一個神奇的「Authorize」按鈕，讓所有受保護的 API 都能在文件頁面上直接測試。</p><h2 id="核心概念：SecurityScheme-與-SecurityRequirement"><a href="#核心概念：SecurityScheme-與-SecurityRequirement" class="headerlink" title="核心概念：SecurityScheme 與 SecurityRequirement"></a>核心概念：<code>SecurityScheme</code> 與 <code>SecurityRequirement</code></h2><p>要讓 OpenAPI 理解我們的安全性設定，需要透過兩個核心概念：</p><ol><li><p><strong><code>SecurityScheme</code> (安全性方案)<strong>：它像是對一種「門鎖」的</strong>定義</strong>。它告訴 OpenAPI 我們正在使用哪一種類型的安全機制。例如，HTTP Basic 驗證、API Key，或者在我們的例子中，是 **HTTP Bearer Token (JWT)**。</p></li><li><p><strong><code>SecurityRequirement</code> (安全性需求)<strong>：它則是對「門鎖」的</strong>應用</strong>。它告訴 OpenAPI：「請將名為 <code>xyz</code> 的這把鎖，應用到這個 API 端點上」。這個需求可以應用在單一的 API 上，也可以應用在所有 API 上。</p></li></ol><h2 id="實戰一：建立全域安全性組態"><a href="#實戰一：建立全域安全性組態" class="headerlink" title="實戰一：建立全域安全性組態"></a>實戰一：建立全域安全性組態</h2><p>對於像 JWT 這樣需要全站套用的安全機制，最佳實踐不是在每個 Controller 上都加上註解，而是在一個集中的地方，透過定義一個 <code>OpenAPI</code> Bean 來進行全域設定。</p><ol><li><p><strong>建立組態類別</strong><br>在 <code>com.example.demoapp.config</code> 套件下，建立新檔案 <code>OpenApiConfig.java</code>。</p></li><li><p><strong>撰寫組態程式碼</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.Components;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.OpenAPI;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Info;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.security.SecurityRequirement;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.security.SecurityScheme;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenApiConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OpenAPI <span class="title function_">customOpenAPI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">securitySchemeName</span> <span class="operator">=</span> <span class="string">&quot;bearerAuth&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">            <span class="comment">// 1. 將 SecurityRequirement 應用到所有 API</span></span><br><span class="line">            .addSecurityItem(<span class="keyword">new</span> <span class="title class_">SecurityRequirement</span>().addList(securitySchemeName))</span><br><span class="line">            <span class="comment">// 2. 在 components 中定義 SecurityScheme 的具體內容</span></span><br><span class="line">            .components(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Components</span>()</span><br><span class="line">                    .addSecuritySchemes(securitySchemeName,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">SecurityScheme</span>()</span><br><span class="line">                            .name(<span class="string">&quot;Authorization&quot;</span>)      <span class="comment">// HTTP 標頭的名稱</span></span><br><span class="line">                            .type(SecurityScheme.Type.HTTP) <span class="comment">// 類型為 HTTP</span></span><br><span class="line">                            .scheme(<span class="string">&quot;bearer&quot;</span>)           <span class="comment">// Scheme 為 bearer</span></span><br><span class="line">                            .bearerFormat(<span class="string">&quot;JWT&quot;</span>)        <span class="comment">// 格式為 JWT</span></span><br><span class="line">                    )</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 3. (可選) 加上文件的基本資訊</span></span><br><span class="line">            .info(<span class="keyword">new</span> <span class="title class_">Info</span>().title(<span class="string">&quot;Spring Series Demo API&quot;</span>).version(<span class="string">&quot;v1.0&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li><strong>程式碼詳解</strong>：<ol><li><code>addSecurityItem(...)</code>：將一個名為 <code>bearerAuth</code> 的安全性需求，<strong>全域應用</strong>到所有 API 端點上。</li><li><code>components(...).addSecuritySchemes(...)</code>：在這裡我們<strong>定義</strong>了名為 <code>bearerAuth</code> 的 <code>SecurityScheme</code>（門鎖）的具體規格。</li><li><code>.scheme(&quot;bearer&quot;).bearerFormat(&quot;JWT&quot;)</code>：這兩行清楚地描述了我們使用的是 JWT Bearer Token 方案。</li></ol></li></ul><h2 id="實戰二：在-SecurityConfig-中放行-Swagger-路徑"><a href="#實戰二：在-SecurityConfig-中放行-Swagger-路徑" class="headerlink" title="實戰二：在 SecurityConfig 中放行 Swagger 路徑"></a>實戰二：在 <code>SecurityConfig</code> 中放行 Swagger 路徑</h2><p>Spring Security 預設會保護所有路徑，這當然也包括了提供 Swagger UI 頁面和 API 規格 (<code>/v3/api-docs</code>) 的路徑。如果我們不將它們明確地設為公開，我們將連文件頁面都無法訪問。</p><p>修改 <code>config/SecurityConfig.java</code>，將 Swagger 相關路徑加入白名單。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in SecurityConfig.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">            .csrf(AbstractHttpConfigurer::disable)</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                    <span class="comment">// 將 Swagger 相關路徑加入白名單</span></span><br><span class="line">                    .requestMatchers(</span><br><span class="line">                            <span class="string">&quot;/api/auth/**&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;/v3/api-docs/**&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;/swagger-ui/**&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;/swagger-ui.html&quot;</span></span><br><span class="line">                    ).permitAll()</span><br><span class="line">                    .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// ... 其餘設定 ...</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用者操作指南：如何在-Swagger-UI-中進行授權"><a href="#使用者操作指南：如何在-Swagger-UI-中進行授權" class="headerlink" title="使用者操作指南：如何在 Swagger UI 中進行授權"></a>使用者操作指南：如何在 Swagger UI 中進行授權</h2><p>現在，我們已經完成了所有後端設定。</p><ol><li><strong>重新啟動應用程式</strong>。</li><li><strong>訪問 Swagger UI</strong>：打開瀏覽器，訪問 <code>http://localhost:8080/swagger-ui.html</code>。您會發現在頁面的右上角，多了一個綠色的 <strong>“Authorize”</strong> 按鈕。</li><li><strong>獲取 JWT</strong>：使用 Postman 等工具，訪問我們之前建立的登入 API（例如 <code>POST /api/auth/login</code>），用正確的帳號密碼（<code>user</code> &#x2F; <code>password</code>）換取一個 JWT Token。複製完整的 Token 字串。</li><li><strong>進行授權</strong>：<ul><li>回到 Swagger UI 頁面，點擊 “Authorize” 按鈕。</li><li>在彈出的視窗中，找到 <code>bearerAuth</code> 區塊，在 <code>Value</code> 輸入框中，貼上您剛剛複製的 Token。<strong>請務必在 Token 的最前面手動加上 <code>Bearer </code> （<code>Bearer</code> 後面有一個空格）</strong>。</li><li>格式應為：<code>Bearer eyJhbGciOiJIUzI1NiJ9...</code></li><li>點擊 “Authorize”，然後關閉視窗。</li></ul></li><li><strong>測試受保護 API</strong>：<br>現在，”Authorize” 按鈕上的小鎖圖示應該已經變為「上鎖」狀態。此時，您再去對任何受保護的 API（如 <code>GET /users</code>）點擊 “Try it out” 並執行，請求將會成功，並回傳 <code>200 OK</code>！因為 Swagger UI 已經自動為您的每一次請求，都附上了 <code>Authorization</code> 標頭。</li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們成功地打通了 API 文件與安全層之間的壁壘。</p><ul><li>我們學會了使用 <code>SecurityScheme</code> 來<strong>定義</strong>我們的 JWT 驗證方案。</li><li>我們學會了使用 <code>SecurityRequirement</code> 來將安全規則<strong>應用</strong>到 API 上。</li><li>我們掌握了使用程式化的 <code>OpenAPI</code> Bean 來進行<strong>全域安全設定</strong>。</li><li>我們學會了如何在 Swagger UI 中使用 “Authorize” 功能，實現了對受保護 API 的<strong>端對端互動測試</strong>。</li></ul><p>這讓我們的 API 文件從一份靜態的「說明書」，蛻變成了一個功能強大的「互動式開發工具」。</p><p>我們已經精通了 API 文件中關於端點行為、資料模型與安全性的所有細節。在我們這個系列的最終章，我們將學習如何透過<strong>全域組態</strong>來集中管理文件設定，並總結 API 文件的最佳實踐，讓您的文件維護工作更上一層樓。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> OpenAPI 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> OpenAPI </tag>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenAPI 實戰 03 - 精通 @Schema：定義您的資料模型</title>
      <link href="/2025/08/22/java-spring-openapi-03/"/>
      <url>/2025/08/22/java-spring-openapi-03/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：定義-API-的共同語言——資料模型"><a href="#前言：定義-API-的共同語言——資料模型" class="headerlink" title="前言：定義 API 的共同語言——資料模型"></a>前言：定義 API 的共同語言——資料模型</h2><p>在上一篇文章中，我們學會了如何描述 API 端點的用途與回應。我們使用了 <code>@Schema(implementation = User.class)</code> 來將回應與一個 Java 類別連結。但是，如果您捲動到 Swagger UI 頁面的最下方，查看「Schemas」區塊，您會發現它只顯示了最基本的欄位名稱和 Java 型別。</p><p>這會引發新的溝通問題：</p><ul><li><code>username</code> 欄位代表什麼？是登入帳號還是暱稱？有長度限制嗎？</li><li><code>email</code> 欄位是否為必填？格式有什麼要求？</li><li>如果有一個 <code>status</code> 欄位，它有哪些可選的值？</li></ul><p>一份專業的 API 文件，必須能精準地回答這些問題。本篇文章將專注於 <code>@Schema</code> 這個核心註解，教您如何直接在您的 DTO (資料傳輸物件) 類別上，為每一個欄位加上豐富的「註解」，打造一份清晰、自解釋的「資料字典」。</p><h2 id="Schema-基礎應用：描述與範例"><a href="#Schema-基礎應用：描述與範例" class="headerlink" title="@Schema 基礎應用：描述與範例"></a><code>@Schema</code> 基礎應用：描述與範例</h2><p>欄位名稱本身提供的資訊有限。<code>description</code> 屬性可以提供業務上的上下文，而 <code>example</code> 屬性則能提供一個比 <code>string</code> 或 <code>integer</code> 這種型別描述更具體的範例值。</p><p>讓我們來豐富化我們在「Spring Series 基礎」中建立的 <code>CreateUserRequest</code> DTO。</p><p><strong>修改 <code>dto/CreateUserRequest.java</code></strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.media.Schema;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema(description = &quot;用於建立新使用者的請求資料模型&quot;)</span> <span class="comment">// 1. 在類別層級加上整體描述</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateUserRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在屬性層級加上詳細描述</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;使用者名稱，在系統中必須是唯一的&quot;, </span></span><br><span class="line"><span class="meta">            example = &quot;john.doe&quot;, </span></span><br><span class="line"><span class="meta">            requiredMode = Schema.RequiredMode.REQUIRED)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;使用者的電子郵件地址，必須是合法的郵件格式&quot;, </span></span><br><span class="line"><span class="meta">            example = &quot;john.doe@example.com&quot;,</span></span><br><span class="line"><span class="meta">            requiredMode = Schema.RequiredMode.REQUIRED)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;使用者的年齡，此為選填欄位&quot;, </span></span><br><span class="line"><span class="meta">            example = &quot;30&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ol><li>我們可以在<strong>類別</strong>上加上 <code>@Schema</code>，為整個資料模型提供一個總體的描述。</li><li>我們可以在<strong>屬性</strong>上加上 <code>@Schema</code>，來分別定義每一個欄位。</li><li><code>requiredMode = Schema.RequiredMode.REQUIRED</code> 是 OpenAPI 3 的標準作法，用於標示此欄位為必填。Swagger UI 會在其旁邊顯示一個紅色的星號 <code>*</code>，非常直觀。</li></ol></li></ul><p>刷新 Swagger UI 頁面，您會發現在 <code>POST /users</code> 的請求本文範例以及頁面下方的 “Schemas” 區塊，都出現了我們剛剛新增的描述與範例，文件的可讀性大幅提升。</p><h2 id="體現驗證規則"><a href="#體現驗證規則" class="headerlink" title="體現驗證規則"></a>體現驗證規則</h2><p>您的 API 後端通常會對傳入的資料進行驗證（例如，使用者名稱長度不能超過 50）。將這些驗證規則直接體現在 API 文件上，可以幫助前端開發者在發送請求前就知道資料的限制，避免不必要的錯誤。</p><p><code>@Schema</code> 註解提供了一系列屬性來描述這些驗證規則：</p><ul><li><code>minLength</code> &#x2F; <code>maxLength</code> (用於字串)</li><li><code>minimum</code> &#x2F; <code>maximum</code> (用於數字)</li><li><code>pattern</code> (用於正規表示式)</li></ul><p>讓我們繼續完善 <code>CreateUserRequest.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in CreateUserRequest.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Schema(description = &quot;使用者名稱，在系統中必須是唯一的&quot;,</span></span><br><span class="line"><span class="meta">        example = &quot;john.doe&quot;,</span></span><br><span class="line"><span class="meta">        requiredMode = Schema.RequiredMode.REQUIRED,</span></span><br><span class="line"><span class="meta">        minLength = 3,</span></span><br><span class="line"><span class="meta">        maxLength = 50)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Schema(description = &quot;使用者的電子郵件地址，必須是合法的郵件格式&quot;,</span></span><br><span class="line"><span class="meta">        example = &quot;john.doe@example.com&quot;,</span></span><br><span class="line"><span class="meta">        requiredMode = Schema.RequiredMode.REQUIRED,</span></span><br><span class="line"><span class="meta">        pattern = &quot;^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]&#123;2,4&#125;$&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Schema(description = &quot;使用者的年齡，必須介於 0 到 120 之間&quot;,</span></span><br><span class="line"><span class="meta">        example = &quot;30&quot;,</span></span><br><span class="line"><span class="meta">        minimum = &quot;0&quot;,</span></span><br><span class="line"><span class="meta">        maximum = &quot;120&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br></pre></td></tr></table></figure><p>現在，Swagger UI 會將這些限制顯示在 Schema 的說明中，為 API 的使用者提供了清晰的指引。</p><h2 id="處理枚舉與可選值"><a href="#處理枚舉與可選值" class="headerlink" title="處理枚舉與可選值"></a>處理枚舉與可選值</h2><p><strong>問題</strong>：如果某個欄位只能接受幾個固定的值（例如，訂單狀態只能是 “PENDING”, “PROCESSING”, “SHIPPED”），該如何表達？</p><p><strong>解決方案</strong>：使用 <code>@Schema</code> 的 <code>allowableValues</code> 屬性。</p><p>讓我們建立一個新的 DTO <code>StatusQueryRequest.java</code> 來示範：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.media.Schema;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema(description = &quot;用於查詢狀態的請求&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatusQueryRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(</span></span><br><span class="line"><span class="meta">        description = &quot;查詢的狀態類型&quot;,</span></span><br><span class="line"><span class="meta">        example = &quot;ACTIVE&quot;,</span></span><br><span class="line"><span class="meta">        allowableValues = &#123;&quot;ACTIVE&quot;, &quot;INACTIVE&quot;, &quot;PENDING&quot;&#125; // 核心在這</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>效果</strong>：當 Swagger UI 渲染這個模型時，它會非常智慧地為 <code>status</code> 欄位顯示一個<strong>下拉選單</strong>，其中只包含了我們定義的三個可選值。這極大地改善了使用者體驗，並從源頭上杜絕了無效值的傳入。</li></ul><h2 id="巢狀物件與唯讀-x2F-唯寫欄位"><a href="#巢狀物件與唯讀-x2F-唯寫欄位" class="headerlink" title="巢狀物件與唯讀&#x2F;唯寫欄位"></a>巢狀物件與唯讀&#x2F;唯寫欄位</h2><p>真實世界的 DTO 往往更加複雜，可能包含巢狀物件，也可能有些欄位只在特定情境下出現。</p><ul><li><code>readOnly = true</code>：表示此欄位僅用於<strong>回應</strong>（例如由資料庫自動產生的 <code>id</code> 或 <code>createdAt</code>），客戶端在<strong>請求</strong>時不應傳入。</li><li><code>writeOnly = true</code>：表示此欄位僅用於<strong>請求</strong>（例如 <code>password</code>），在<strong>回應</strong>時絕不應被序列化並回傳給客戶端。</li></ul><p>讓我們建立一個 <code>UserResponse.java</code> DTO 來示範：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.media.Schema;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema(description = &quot;回傳給客戶端的使用者資訊模型&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserResponse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;使用者的唯一 ID (由系統產生)&quot;, example = &quot;1&quot;, readOnly = true)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;使用者名稱&quot;, example = &quot;john.doe&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我們可以建立一個巢狀的 DTO 來組織資訊</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;使用者的聯絡方式&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ContactInfo contact;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ContactInfo</span> &#123;</span><br><span class="line">        <span class="meta">@Schema(description = &quot;電子郵件&quot;, example = &quot;john.doe@example.com&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swagger UI 會正確地將 <code>id</code> 標示為 <code>read-only</code>，並以巢狀結構來呈現 <code>contact</code> 物件，讓整個資料模型清晰易懂。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們已經從描述 API 的「行為」，進階到了描述 API 的「資料」。</p><ul><li>我們學會了使用 <code>@Schema</code> 的 <code>description</code> 和 <code>example</code> 屬性，為 DTO 加上豐富的說明。</li><li>我們掌握了如何在文件中體現 <code>minLength</code>, <code>pattern</code> 等驗證規則。</li><li>我們學會了使用 <code>allowableValues</code> 為欄位定義一個清晰的枚舉值列表。</li><li>我們了解了如何透過 <code>readOnly</code> &#x2F; <code>writeOnly</code> 來區分請求與回應的欄位。</li></ul><p>為您的資料模型建立一份詳盡、無歧義的「規格書」，是鞏固 API 合約 (Contract)、提升團隊協作效率的基礎。</p><p>我們已經精通了如何描述 API 的行為與資料。但還有一個關鍵部分沒有在文件中體現：安全性。在下一篇文章中，我們將學習如何<strong>定義安全性方案</strong>，讓我們的 API 文件能夠反映出 JWT 驗證需求，並讓使用者可以直接在 Swagger UI 中進行授權測試。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> OpenAPI 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> OpenAPI </tag>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenAPI 實戰 02 - 基礎註解詳解：豐富您的 API 端點</title>
      <link href="/2025/08/22/java-spring-openapi-02/"/>
      <url>/2025/08/22/java-spring-openapi-02/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：為您的-API-加上註解"><a href="#前言：為您的-API-加上註解" class="headerlink" title="前言：為您的 API 加上註解"></a>前言：為您的 API 加上註解</h2><p>在「Spring Series 基礎」中，我們僅僅加入一個 Maven 依賴，就神奇地產生了一份 API 文件。但這份文件更像是一張「毛胚屋」的平面圖——我們看得到有哪些房間（API 端點），卻不知道每個房間的用途、門窗在哪、又該如何進出。</p><p>當前端工程師看到 <code>GET /users/&#123;id&#125;</code> 時，他們心中會充滿疑問：</p><ul><li>這個 API 究竟是做什麼的？</li><li>參數 <code>&#123;id&#125;</code> 應該傳入什麼樣的值？</li><li>如果成功了，會回傳什麼格式的資料？</li><li>如果 <code>id</code> 不存在，又會發生什麼事？</li></ul><p>本篇文章的目標，就是學習 OpenAPI 文件的「基礎詞彙」，透過一系列的核心註解，來精準地回答以上所有問題。我們將一起動手，把這份陽春的平面圖，裝潢成一份任何人都能看懂的、資訊豐富的「精裝修設計圖」。</p><h2 id="使用-Tag-進行分組：讓文件更有條理"><a href="#使用-Tag-進行分組：讓文件更有條理" class="headerlink" title="使用 @Tag 進行分組：讓文件更有條理"></a>使用 <code>@Tag</code> 進行分組：讓文件更有條理</h2><p><strong>問題</strong>：當我們的 Controller 越來越多時（<code>UserController</code>, <code>ProductController</code>, <code>OrderController</code>…），Swagger UI 預設會將它們全部混在一起，顯得雜亂無章。</p><p><strong>解決方案</strong>：使用 <code>@Tag</code> 註解，像為檔案建立資料夾一樣，為我們的 API 進行分類。</p><p>讓我們為現有的 <code>UserController</code> 和 <code>HelloController</code> 加上分組標籤。</p><p><strong><code>controller/UserController.java</code></strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.tags.Tag;</span><br><span class="line"><span class="comment">// ... 其他 import</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;使用者功能&quot;, description = &quot;提供使用者新增、查詢、修改、刪除等相關 API&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>controller/HelloController.java</code></strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.tags.Tag;</span><br><span class="line"><span class="comment">// ... 其他 import</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;測試用 API&quot;, description = &quot;提供一些簡單的測試與範例端點&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新啟動應用並刷新 Swagger UI 頁面，您會發現 API 已經被整齊地收納在「使用者功能」和「測試用 API」這兩個可折疊的群組下了，結構一目了然。</p><h2 id="使用-Operation-與-Parameter-描述意圖"><a href="#使用-Operation-與-Parameter-描述意圖" class="headerlink" title="使用 @Operation 與 @Parameter 描述意圖"></a>使用 <code>@Operation</code> 與 <code>@Parameter</code> 描述意圖</h2><p><strong>問題</strong>：<code>GET /users/&#123;id&#125;</code> 這個路徑很簡潔，但完全看不出它的意圖與參數細節。</p><p><strong>解決方案</strong>：使用 <code>@Operation</code> 來描述 API 方法的用途，<code>@Parameter</code> 來描述參數的細節。</p><p>讓我們來豐富 <code>UserController</code> 中的 <code>getUserById</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in UserController.java</span></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.Operation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.Parameter;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Operation(summary = &quot;查詢特定使用者&quot;, description = &quot;透過使用者 ID 查詢單一使用者的完整資訊&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@Parameter(description = &quot;要查詢的使用者 ID&quot;, example = &quot;1&quot;, required = true)</span></span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**<code>@Operation</code>**：<code>summary</code> 提供一個簡短的標題，會直接顯示在 API 列表上；<code>description</code> 提供更詳細的說明文字。</li><li>**<code>@Parameter</code>**：我們直接在 <code>@PathVariable</code> 參數旁加上此註解，用 <code>description</code> 說明其用途，<code>example</code> 提供一個範例值，<code>required = true</code> 則明確標示此參數為必填。</li></ul><p>刷新 Swagger UI，現在這個 API 的用途和參數細節都變得非常清晰。</p><h2 id="使用-ApiResponses-定義所有可能性"><a href="#使用-ApiResponses-定義所有可能性" class="headerlink" title="使用 @ApiResponses 定義所有可能性"></a>使用 <code>@ApiResponses</code> 定義所有可能性</h2><p><strong>問題</strong>：前端工程師知道呼叫 <code>GET /users/1</code> 成功時會拿到使用者資料，但如果傳入一個不存在的 ID，例如 <code>999</code>，會發生什麼？是回傳 <code>null</code>？還是 JSON 錯誤物件？HTTP 狀態碼又是什麼？</p><p><strong>解決方案</strong>：使用 <code>@ApiResponses</code> 和 <code>@ApiResponse</code> 來明確定義 API 所有可能的執行結果。</p><p>讓我們繼續完善 <code>getUserById</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in UserController.java</span></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.media.Content;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.media.Schema;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.responses.ApiResponse;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.responses.ApiResponses;</span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.entity.User;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Operation(summary = &quot;查詢特定使用者&quot;, description = &quot;透過使用者 ID 查詢單一使用者的完整資訊&quot;)</span></span><br><span class="line"><span class="meta">@ApiResponses(value = &#123;</span></span><br><span class="line"><span class="meta">    @ApiResponse(</span></span><br><span class="line"><span class="meta">        responseCode = &quot;200&quot;, </span></span><br><span class="line"><span class="meta">        description = &quot;成功找到使用者&quot;, </span></span><br><span class="line"><span class="meta">        content = &#123; @Content(mediaType = &quot;application/json&quot;, </span></span><br><span class="line"><span class="meta">                             schema = @Schema(implementation = User.class)) &#125;),</span></span><br><span class="line"><span class="meta">    @ApiResponse(</span></span><br><span class="line"><span class="meta">        responseCode = &quot;404&quot;, </span></span><br><span class="line"><span class="meta">        description = &quot;找不到指定 ID 的使用者&quot;, </span></span><br><span class="line"><span class="meta">        content = @Content)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(...)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>**<code>@ApiResponses</code>**：作為一個容器，包裹一個或多個 <code>@ApiResponse</code>。</li><li>**<code>@ApiResponse</code>**：定義一種可能的回應。<ul><li><code>responseCode</code>：對應 HTTP 狀態碼。</li><li><code>description</code>：對這個回應的文字說明。</li><li><code>content</code>：描述回應的本文內容。<code>@Content</code> 中的 <code>mediaType</code> 指定了格式，而 <code>@Schema(implementation = User.class)</code> 則告訴 Swagger：「這個回應的結構，請參考 <code>User</code> 這個類別」，Swagger 就會自動為您產生對應的範例 JSON。</li></ul></li></ul><p>現在，前端工程師可以在文件上清楚地看到，這個 API 可能會回傳 <code>200</code> 或 <code>404</code> 兩種狀態，以及 <code>200</code> 時的資料結構。</p><h2 id="進階技巧：提供多個請求範例"><a href="#進階技巧：提供多個請求範例" class="headerlink" title="進階技巧：提供多個請求範例"></a>進階技巧：提供多個請求範例</h2><p><strong>問題</strong>：<code>POST /users</code> 這個 API 用來建立使用者，請求的 JSON 本文可能有多種情境。例如，「只填寫必填欄位」和「填寫所有欄位」的 JSON 會長得不一樣。如何讓文件使用者清楚地了解這些不同情境？</p><p><strong>解決方案</strong>：使用 <code>@RequestBody</code> 搭配 <code>@ExampleObject</code>，為同一個 API 提供多個不同的請求範例。</p><p>讓我們來豐富 <code>createUser</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in UserController.java</span></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.media.ExampleObject;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.parameters.RequestBody;</span><br><span class="line"><span class="comment">// 請注意，為了避免與 Spring 的 @RequestBody 衝突，這裡我們使用全限定名</span></span><br><span class="line"><span class="comment">// 或是只 import 其中一個，另一個用全限定名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Operation(summary = &quot;建立新使用者&quot;)</span></span><br><span class="line"><span class="meta">@ApiResponses(...)</span> <span class="comment">// 省略...</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(</span></span><br><span class="line"><span class="params">    // Spring 的 <span class="meta">@RequestBody</span> 註解，用於參數綁定</span></span><br><span class="line"><span class="params">    <span class="meta">@org</span>.springframework.web.bind.annotation.RequestBody </span></span><br><span class="line"><span class="params">    CreateUserRequest request)</span> &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>springdoc</code> 的 <code>@RequestBody</code> 和 Spring MVC 的 <code>@RequestBody</code> 作用不同且容易混淆。<code>springdoc</code> 的是<strong>純描述用</strong>，而 Spring MVC 的是<strong>功能性</strong>的。一種常見作法是將描述用的 <code>@RequestBody</code> 放在方法上，而將功能性的 <code>@RequestBody</code> 寫在參數前。</p><p>現在，我們在 <code>createUser</code> 方法上加入 <code>springdoc</code> 的 <code>@RequestBody</code> 註解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 createUser 方法上</span></span><br><span class="line"><span class="meta">@Operation(summary = &quot;建立新使用者&quot;)</span></span><br><span class="line"><span class="meta">@io</span>.swagger.v3.oas.annotations.parameters.RequestBody(</span><br><span class="line">    description = <span class="string">&quot;建立新使用者的請求資料&quot;</span>, required = <span class="literal">true</span>,</span><br><span class="line">    content = <span class="meta">@Content(</span></span><br><span class="line"><span class="meta">        schema = @Schema(implementation = CreateUserRequest.class),</span></span><br><span class="line"><span class="meta">        examples = &#123;</span></span><br><span class="line"><span class="meta">            @ExampleObject(</span></span><br><span class="line"><span class="meta">                name = &quot;基本使用者範例&quot;,</span></span><br><span class="line"><span class="meta">                summary = &quot;只提供必要欄位&quot;,</span></span><br><span class="line"><span class="meta">                value = &quot;&#123;\&quot;username\&quot;: \&quot;basic_user\&quot;, \&quot;email\&quot;: \&quot;basic@example.com\&quot;, \&quot;age\&quot;: 20&#125;&quot;</span></span><br><span class="line"><span class="meta">            ),</span></span><br><span class="line"><span class="meta">            @ExampleObject(</span></span><br><span class="line"><span class="meta">                name = &quot;完整使用者範例&quot;,</span></span><br><span class="line"><span class="meta">                summary = &quot;提供所有可選欄位&quot;,</span></span><br><span class="line"><span class="meta">                value = &quot;&#123;\&quot;username\&quot;: \&quot;full_user\&quot;, \&quot;email\&quot;: \&quot;full@example.com\&quot;, \&quot;age\&quot;: 35&#125;&quot;</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">)</span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(...)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>刷新 Swagger UI，您會發現在 <code>POST /users</code> 的請求本文區塊，出現了一個下拉選單，讓使用者可以在「基本使用者範例」和「完整使用者範例」之間切換，極大地提升了文件的實用性。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們學會了 OpenAPI 文件的基礎詞彙，成功地將一份陽春的文件，打造成了資訊豐富的使用手冊。我們現在能夠：</p><ul><li>使用 <code>@Tag</code> 為 API 進行分組。</li><li>使用 <code>@Operation</code> 和 <code>@Parameter</code> 描述 API 的用途與參數。</li><li>使用 <code>@ApiResponses</code> 定義所有可能的回應結果。</li><li>使用 <code>@ExampleObject</code> 提供多種情境的請求範例。</li></ul><p>我們已經精通了如何描述 API 的「行為」。但 API 的核心是「資料」。在下一篇文章中，我們將專注於 <strong><code>@Schema</code></strong> 註解，學習如何為我們的資料模型 (DTO) 建立一份詳盡的規格書。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> OpenAPI 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> OpenAPI </tag>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenAPI 實戰 01 - 專業 API 文件學習路徑</title>
      <link href="/2025/08/22/java-spring-openapi-01/"/>
      <url>/2025/08/22/java-spring-openapi-01/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：溝通的藝術與科學"><a href="#前言：溝通的藝術與科學" class="headerlink" title="前言：溝通的藝術與科學"></a>前言：溝通的藝術與科學</h2><p>在軟體開發的團隊中，我們時常上演著一出現代版的「巴別塔」寓言。後端工程師打造了功能強大的 API，但前端工程師卻不知道如何正確地呼叫；測試工程師收到了錯誤的回應，卻不明白 <code>400</code> 這個數字背後代表的具體業務錯誤。</p><blockquote><p><strong>前端問</strong>：「這個新增使用者的 API，<code>status</code> 欄位到底該傳數字還是字串？」<br><strong>後端說</strong>：「我改了個東西，你那邊 re-sync 一下就好。什麼？欄位名稱也改了？啊…我看一下程式碼…」<br><strong>測試問</strong>：「為什麼我傳了跟上次一樣的參數，這次卻回了 <code>500</code> 錯誤？」</p></blockquote><p>這一切混亂的根源，都指向一個共同的問題：缺乏一份清晰、準確、且與程式碼<strong>永遠同步</strong>的「API 設計藍圖」。</p><p><strong>OpenAPI (Swagger)</strong> 就是解決這個問題的「通用語言」。它不僅僅是一個自動產生文件的工具，更是一種<strong>溝通的規範與藝術</strong>。它能將後端 API 的複雜邏輯，轉化為一份任何人都能讀懂、甚至能直接互動測試的說明書。</p><p>本系列將帶您學習的，不僅是如何使用幾個註解，更是如何成為一位善用 API 文件進行高效溝通的專業開發者。這趟旅程將帶您從一份僅僅是「有就好」的文件，昇華到一份讓所有協作者都讚不絕口的「卓越」文件。</p><h2 id="「OpenAPI-實戰」學習地圖：從合格到卓越"><a href="#「OpenAPI-實戰」學習地圖：從合格到卓越" class="headerlink" title="「OpenAPI 實戰」學習地圖：從合格到卓越"></a>「OpenAPI 實戰」學習地圖：從合格到卓越</h2><hr><h3 id="OpenAPI-實戰-02-基礎註解詳解：豐富您的-API-端點"><a href="#OpenAPI-實戰-02-基礎註解詳解：豐富您的-API-端點" class="headerlink" title="OpenAPI 實戰 02 - 基礎註解詳解：豐富您的 API 端點"></a><strong><code>OpenAPI 實戰 02 - 基礎註解詳解：豐富您的 API 端點</code></strong></h3><ul><li><strong>我們面臨的問題</strong>：僅靠 <code>springdoc</code> 自動產生的文件，雖然列出了 API 路徑，但它就像一張沒有任何註記的地圖。前端同事看不懂 <code>POST /users</code> 這個端點究竟是做什麼的，需要哪些參數，又會回傳哪些可能的結果。</li><li><strong>本篇學習目標</strong>：我們將學習 API 文件的<strong>基礎詞彙</strong>。透過 <code>@Tag</code>, <code>@Operation</code>, <code>@Parameter</code> 等註解，為我們的 API 加上清晰的「標題」與「註解」。更重要的是，我們將學會使用 <code>@ApiResponses</code> 來定義所有可能的「對話結果」（成功、失敗、找不到資源等），讓 API 的行為不再有任何模糊地帶。</li></ul><hr><h3 id="OpenAPI-實戰-03-精通-Schema：定義您的資料模型"><a href="#OpenAPI-實戰-03-精通-Schema：定義您的資料模型" class="headerlink" title="OpenAPI 實戰 03 - 精通 @Schema：定義您的資料模型"></a><strong><code>OpenAPI 實戰 03 - 精通 @Schema：定義您的資料模型</code></strong></h3><ul><li><strong>我們面臨的問題</strong>：API 回傳了一個 JSON 物件，但前端同事必須像猜謎一樣，去猜測 <code>username</code> 欄位是否必填、<code>age</code> 欄位的格式是什麼、<code>status</code> 欄位有哪些可選值。</li><li><strong>本篇學習目標</strong>：我們將成為<strong>資料模型的建築師</strong>。本篇將專注於 <code>@Schema</code> 這個註解，學習如何為我們的 DTO（資料傳輸物件）打造一份詳盡的「規格書」。我們將為每個欄位加上描述、範例值，並標註其驗證規則（如 <code>required</code>, <code>allowableValues</code>），讓資料結構的每一個細節都清晰可見。</li></ul><hr><h3 id="OpenAPI-實戰-04-定義安全性方案-Security-Schemes"><a href="#OpenAPI-實戰-04-定義安全性方案-Security-Schemes" class="headerlink" title="OpenAPI 實戰 04 - 定義安全性方案 (Security Schemes)"></a><strong><code>OpenAPI 實戰 04 - 定義安全性方案 (Security Schemes)</code></strong></h3><ul><li><strong>我們面臨的問題</strong>：我們的 API 文件看起來很棒，但 90% 的端點都因為需要 JWT 驗證而無法在 Swagger UI 上直接測試。那個方便的 “Try it out” 按鈕形同虛設，文件的互動性大打折扣。</li><li><strong>本篇學習目標</strong>：我們將為 API 文件加上<strong>門鎖與鑰匙</strong>。本篇將教您如何使用 <code>@SecurityScheme</code> 來告訴 Swagger 我們的 API 是用 JWT Bearer Token 來保護的，並在 UI 上產生一個「Authorize」按鈕。完成後，任何人都可以用一個有效的 Token，直接在文件頁面上測試所有受保護的 API。</li></ul><hr><h3 id="OpenAPI-實戰-05-全域組態與最佳實踐"><a href="#OpenAPI-實戰-05-全域組態與最佳實踐" class="headerlink" title="OpenAPI 實戰 05 - 全域組態與最佳實踐"></a><strong><code>OpenAPI 實戰 05 - 全域組態與最佳實踐</code></strong></h3><ul><li><strong>我們面臨的問題</strong>：隨著專案規模擴大，我們發現自己在數十個 Controller 中，重複地撰寫著相同的 <code>@ApiResponse</code> (例如 401, 403, 500 的錯誤回應)。文件設定變得分散，難以維護。</li><li><strong>本篇學習目標</strong>：我們將學習 API 文件設計的 <strong>DRY (Don’t Repeat Yourself)</strong> 原則。本篇將教您如何透過定義一個全域的 <code>OpenAPI</code> Bean，來集中管理文件的標題、版本、伺服器資訊，甚至是全域的安全性需求與共用回應，讓您的文件設定既優雅又易於維護。</li></ul><hr><h3 id="學習之後，您將獲得什麼？"><a href="#學習之後，您將獲得什麼？" class="headerlink" title="學習之後，您將獲得什麼？"></a><strong>學習之後，您將獲得什麼？</strong></h3><p>完成這個系列後，您將不僅僅是學會了幾個註解，而是真正掌握了：</p><ul><li><strong>自動化能力</strong>：產出與程式碼永遠同步、無需手動維護的專業 API 文件。</li><li><strong>溝通效率</strong>：大幅降低與前端、測試、甚至其他後端團隊的溝通成本。</li><li><strong>設計思維</strong>：透過撰寫文件，反向思考並優化您的 API 設計。</li><li><strong>專業形象</strong>：交付一份清晰、完整、可互動的文件，是專業後端工程師的標誌。</li></ul><p>準備好提升您的 API 開發技能了嗎？讓我們從下一篇文章「**<code>OpenAPI 實戰 02 - 基礎註解詳解：豐富您的 API 端點</code>**」開始，為我們的 API 注入靈魂。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> OpenAPI 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> OpenAPI </tag>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logback 實戰 07 - AsyncAppender 與效能調校</title>
      <link href="/2025/08/15/java-spring-logback-07/"/>
      <url>/2025/08/15/java-spring-logback-07/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：日誌的效能瓶頸"><a href="#前言：日誌的效能瓶頸" class="headerlink" title="前言：日誌的效能瓶頸"></a>前言：日誌的效能瓶頸</h2><p>在我們至今的設定中，無論是輸出到主控台還是檔案，<code>log.info()</code> 的呼叫都是<strong>同步 (Synchronous)</strong> 的。這意味著，當您的業務執行緒（例如處理 HTTP 請求的執行緒）呼叫 <code>log.info()</code> 時，它必須<strong>親自</strong>完成將日誌訊息格式化並寫入到磁碟或終端的所有 I&#x2F;O 操作，然後才能繼續執行後續的業務邏輯。</p><p>在低流量的應用中，這個微小的 I&#x2F;O 延遲無關緊要。但在高併發、高吞吐量的生產環境中，成千上萬次的同步 I&#x2F;O 操作累積起來，將會成為一個<strong>嚴重的效能瓶頸</strong>，直接降低您 API 的回應速度與系統的處理能力。</p><p>為了解決這個問題，Logback 提供了一個終極武器——**<code>AsyncAppender</code>**。</p><h2 id="AsyncAppender-的運作原理"><a href="#AsyncAppender-的運作原理" class="headerlink" title="AsyncAppender 的運作原理"></a><code>AsyncAppender</code> 的運作原理</h2><p><code>AsyncAppender</code> 的核心思想是「<strong>解耦</strong>」——將日誌的「產生」與「寫入」兩個環節徹底分離。</p><p>您可以將其想像成一個高效的速食店點餐流程：</p><ul><li><strong>同步日誌</strong>：收銀員（業務執行緒）每接一單，都要親自跑到廚房把訂單貼好，再回來接下一單。隊伍會變得很長。</li><li><strong>非同步日誌</strong>：收銀員（業務執行緒）接完單後，直接把訂單放進櫃檯上的一個盒子（<strong>佇列</strong>）裡，然後立刻服務下一位顧客。廚房裡有專門的員工（<strong>背景執行緒</strong>）會不斷地從盒子裡取走訂單並處理。</li></ul><p><code>AsyncAppender</code> 的運作方式完全相同：</p><ol><li>它本身不負責寫入，而是作為一個**包裝器 (Wrapper)**，包裹住另一個真實的 Appender（例如我們的 <code>RollingFileAppender</code>）。</li><li>當業務執行緒產生一條日誌時，<code>AsyncAppender</code> 會將這條日誌事件快速地放入一個記憶體中的<strong>阻塞佇列 (BlockingQueue)</strong> 中，然後<strong>立即</strong>將控制權還給業務執行緒。</li><li><code>AsyncAppender</code> 內部擁有一個獨立的<strong>背景工作執行緒</strong>，這個執行緒會不斷地從佇列中取出日誌事件，並交給被它包裹的 <code>RollingFileAppender</code> 來執行真正的磁碟寫入操作。</li></ol><p>透過這種方式，主業務執行緒幾乎完全感受不到磁碟 I&#x2F;O 的延遲，從而大幅提升應用程式的效能與吞吐量。</p><h2 id="設定-AsyncAppender"><a href="#設定-AsyncAppender" class="headerlink" title="設定 AsyncAppender"></a>設定 <code>AsyncAppender</code></h2><p>設定 <code>AsyncAppender</code> 非常簡單，我們只需要定義一個新的 Appender，並修改我們 <code>prod</code> 環境的 Profile 即可。</p><p>打開 <code>logback-spring.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ASYNC_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>1024<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ol><li>我們定義了一個新的 Appender，<code>class</code> 指定為 <code>ch.qos.logback.classic.AsyncAppender</code>。</li><li><code>queueSize</code>：記憶體中緩衝佇列的大小。更大的佇列可以應對更高的瞬間日誌流量，但會消耗更多記憶體，且在應用程式崩潰時可能遺失更多日誌。</li><li><code>discardingThreshold</code>：一個為了保護應用程式不因日誌系統而崩潰的安全閥。預設行為（非 0）是優先保證 <code>WARN</code> 和 <code>ERROR</code> 級別的日誌被記錄。設定為 <code>0</code> 則表示所有級別的日誌都同等重要，佇列滿了就阻塞等待，這能確保日誌不遺失，但可能會短暫影響主執行緒。</li><li><code>&lt;appender-ref ref=&quot;FILE&quot; /&gt;</code>：這是最關鍵的一步，它告訴 <code>ASYNC_FILE</code> 這個 Appender，將從佇列中取出的日誌事件，交給我們之前定義好的 <code>FILE</code> Appender 處理。</li><li>最後，我們在 <code>prod</code> Profile 中，將 <code>&lt;root&gt;</code> logger 引用的 Appender 從 <code>FILE</code> 改為 <code>ASYNC_FILE</code>。</li></ol></li></ul><h2 id="安全關閉-Graceful-Shutdown-與注意事項"><a href="#安全關閉-Graceful-Shutdown-與注意事項" class="headerlink" title="安全關閉 (Graceful Shutdown) 與注意事項"></a>安全關閉 (Graceful Shutdown) 與注意事項</h2><p>使用非同步日誌帶來了高效能，但也引入了一個風險：如果應用程式異常崩潰（而不是正常關閉），那麼記憶體佇列中尚未被寫入磁碟的日誌將會<strong>永久遺失</strong>。</p><p>幸運的是，對於正常的關閉流程（例如 <code>Ctrl+C</code> 或部署系統發送的停止信號），Spring Boot 會自動處理 Logback 的**安全關閉鉤子 (Shutdown Hook)**。在應用程式關閉時，它會給 <code>AsyncAppender</code> 一段時間，讓其背景執行緒盡可能地將佇列中剩餘的日誌「刷 (flush)」到磁碟上。</p><p><strong>結論</strong>：非同步日誌是用「<strong>極小的日誌遺失風險</strong>（僅限於服務崩潰時）」來換取「<strong>巨大的效能提升</strong>」。對於絕大多數高併發應用程式來說，這是一筆非常值得的交易。</p><h2 id="旅程總結：成為日誌管理專家"><a href="#旅程總結：成為日誌管理專家" class="headerlink" title="旅程總結：成為日誌管理專家"></a>旅程總結：成為日誌管理專家</h2><p>恭喜您完成了「Logback 實戰」系列的全部 7 篇文章！</p><p>在這趟深度之旅中，我們從解構 <code>logback-spring.xml</code> 的基礎開始，逐步掌握了 Logback 的三大核心元件：</p><ul><li><strong>Appender</strong>：精準地控制日誌的「去向」。</li><li><strong>Layout</strong>：藝術地設計日誌的「樣貌」。</li><li><strong>Filter</strong>：智慧地過濾出我們「關心」的內容。</li></ul><p>我們學會了使用 <strong>MDC</strong> 為日誌注入全鏈路追蹤的靈魂，使用 <strong>Profiles</strong> 為不同環境量身定製日誌策略，並在最終章，使用 <strong>AsyncAppender</strong> 為我們的日誌系統加上了效能的渦輪引擎。</p><p>現在的您，已經具備了為任何規模的 Spring Boot 專案，設計、實作並維護一套專業、高效、且穩健的日誌管理系統的能力。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Logback 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logback 實戰 06 - 多環境日誌管理 (Spring Profiles)</title>
      <link href="/2025/08/15/java-spring-logback-06/"/>
      <url>/2025/08/15/java-spring-logback-06/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：單一設定的侷限性"><a href="#前言：單一設定的侷限性" class="headerlink" title="前言：單一設定的侷限性"></a>前言：單一設定的侷限性</h2><p>在一個真實的軟體開發生命週期中，我們的應用程式會在多個不同的環境中執行，而每個環境對於日誌的需求都大相逕庭：</p><ul><li>**開發環境 (dev)**：我們需要最詳盡的資訊來進行除錯。日誌級別應該是 <code>DEBUG</code>，最好能有彩色的主控台輸出，方便即時觀察。</li><li>**測試環境 (test)**：可能需要將日誌輸出到特定的檔案，以便整合測試工具進行分析。</li><li>**生產環境 (prod)**：效能與穩定性是首要考量。日誌級別應該是 <code>INFO</code> 或更高，主控台輸出應被最小化或關閉，所有重要的日誌都應可靠地寫入到滾動檔案中。</li></ul><p>如果為每個環境都維護一份完全獨立的 <code>logback-spring.xml</code>，那將是一場管理上的災難。幸運的是，Spring Boot 為 Logback 提供了與其強大的 <strong>Profiles</strong> 功能深度整合的能力，讓我們可以在<strong>同一份設定檔</strong>中，優雅地管理所有環境的日誌策略。</p><h2 id="lt-springProfile-gt-標籤-Logback-與-Spring-的深度整合"><a href="#lt-springProfile-gt-標籤-Logback-與-Spring-的深度整合" class="headerlink" title="&lt;springProfile&gt; 標籤 - Logback 與 Spring 的深度整合"></a><code>&lt;springProfile&gt;</code> 標籤 - Logback 與 Spring 的深度整合</h2><p>Spring Boot 擴充了 Logback 的功能，讓我們可以在 <code>logback-spring.xml</code> 中使用一個特殊的標籤：<code>&lt;springProfile&gt;</code>。</p><p><strong>其作用是</strong>：被 <code>&lt;springProfile&gt;</code> 標籤包裹起來的任何設定，<strong>只有在指定的 Spring Profile 被啟用時，才會生效</strong>。</p><p><strong>基本語法</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;!prod&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="實戰：打造多環境-logback-spring-xml"><a href="#實戰：打造多環境-logback-spring-xml" class="headerlink" title="實戰：打造多環境 logback-spring.xml"></a>實戰：打造多環境 <code>logback-spring.xml</code></h2><p>我們的策略是：</p><ol><li>在設定檔的「通用區」，定義好所有可能會用到的 <code>Appender</code>。</li><li>在不同的 <code>&lt;springProfile&gt;</code> 區塊中，根據環境需求，去「引用」這些已定義好的 <code>Appender</code> 並設定對應的日誌級別。</li></ol><p>讓我們來重構在 <code>Logback-02</code> 中建立的基礎模板：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;APP_NAME&quot;</span> <span class="attr">source</span>=<span class="string">&quot;spring.application.name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_DIR&quot;</span> <span class="attr">value</span>=<span class="string">&quot;logs&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_DIR&#125;/$&#123;APP_NAME:-application&#125;.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_DIR&#125;/archive/$&#123;APP_NAME:-application&#125;.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>透過這種「定義」與「啟用」分離的模式，我們的設定檔變得極其清晰且易於維護。</p><h2 id="結合-lt-springProperty-gt-實現動態路徑"><a href="#結合-lt-springProperty-gt-實現動態路徑" class="headerlink" title="結合 &lt;springProperty&gt; 實現動態路徑"></a>結合 <code>&lt;springProperty&gt;</code> 實現動態路徑</h2><p>我們還可以讓日誌路徑也跟隨 Profile 動態改變。</p><ol><li><p><strong>在 <code>application-&#123;profile&#125;.yml</code> 中定義路徑</strong></p><p><strong><code>src/main/resources/application-dev.yml</code></strong>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">logs/dev</span></span><br></pre></td></tr></table></figure><p><strong><code>src/main/resources/application-prod.yml</code></strong>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生產環境建議使用絕對路徑，並透過環境變數傳入</span></span><br><span class="line"><span class="comment"># logging:</span></span><br><span class="line"><span class="comment">#   file:</span></span><br><span class="line"><span class="comment">#     path: $&#123;APP_LOG_PATH:/var/log/my-app&#125; </span></span><br></pre></td></tr></table></figure></li><li><p><strong>在 <code>logback-spring.xml</code> 中讀取</strong><br>修改 <code>LOG_DIR</code> 變數的定義：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATH&quot;</span> <span class="attr">source</span>=<span class="string">&quot;logging.file.path&quot;</span> <span class="attr">defaultValue</span>=<span class="string">&quot;logs&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_DIR&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;LOG_PATH&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>現在，當您啟用 <code>dev</code> Profile 時，日誌會自動寫入 <code>logs/dev</code> 目錄；啟用 <code>prod</code> 時，則會寫入您為生產環境指定的路徑。</p><h2 id="測試-Profile-切換"><a href="#測試-Profile-切換" class="headerlink" title="測試 Profile 切換"></a>測試 Profile 切換</h2><p>回顧一下我們在「Spring Series 基礎」第 17 篇中學到的知識來切換 Profile。</p><ol><li><p><strong>測試 <code>dev</code> 環境</strong></p><ul><li>在 <code>application.yml</code> 中確保設定了 <code>spring.profiles.active: dev</code>。</li><li>啟動應用程式。</li><li><strong>觀察結果</strong>：您會看到主控台印出了詳細的 <code>DEBUG</code> 級別日誌，並且專案目錄下出現了 <code>logs/dev</code> 資料夾。</li></ul></li><li><p><strong>測試 <code>prod</code> 環境</strong></p><ul><li>停止應用程式。</li><li>使用<strong>命令列參數</strong>來覆寫設定並啟動，這是在伺服器上部署時的常用方法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for Maven</span></span><br><span class="line">mvn spring-boot:run -Dspring-boot.run.profiles=prod</span><br><span class="line"></span><br><span class="line"><span class="comment"># for executable JAR</span></span><br><span class="line">java -jar -Dspring.profiles.active=prod target/demo-app-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></li><li><strong>觀察結果</strong>：您會發現主控台的日誌變得非常乾淨（只顯示 <code>INFO</code> 及以上），且日誌檔案會被寫入到 <code>prod</code> 環境對應的路徑。</li></ul></li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們掌握了一項生產級的日誌組態管理技能。</p><ul><li>我們學會了 <strong><code>&lt;springProfile&gt;</code></strong> 這個連接 Spring 環境與 Logback 設定的關鍵橋樑。</li><li>我們實踐了將 Appender 的「定義」與「啟用」分離的設計模式，讓設定檔變得清晰且可維護。</li><li>我們能夠為<strong>開發</strong>與<strong>生產</strong>等不同環境，建立完全獨立的日誌級別、輸出目的地與檔案路徑策略。</li></ul><p>我們已經能夠為不同環境客製化日誌策略。在我們這個系列的最終章，我們將探討日誌的終極效能優化——<strong>非同步日誌</strong>，學習如何使用 <strong><code>AsyncAppender</code></strong> 來避免日誌寫入操作阻塞我們的主業務執行緒。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Logback 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logback 實戰 05 - Filter 精準過濾：只看您想看的日誌</title>
      <link href="/2025/08/15/java-spring-logback-05/"/>
      <url>/2025/08/15/java-spring-logback-05/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：當日誌級別-Level-不夠用時"><a href="#前言：當日誌級別-Level-不夠用時" class="headerlink" title="前言：當日誌級別 (Level) 不夠用時"></a>前言：當日誌級別 (Level) 不夠用時</h2><p>我們已經知道，可以透過在 <code>&lt;logger&gt;</code> 或 <code>&lt;root&gt;</code> 標籤上設定 <code>level</code> 屬性，來控制日誌的輸出。例如，設定 <code>level=&quot;INFO&quot;</code>，則只有 <code>INFO</code>, <code>WARN</code>, <code>ERROR</code> 級別的日誌會被處理。</p><p>然而，這種方式的控制粒度較粗。假設我們有以下需求：</p><ul><li><strong>需求一</strong>：建立一個專門的檔案，<strong>只</strong>存放 <code>ERROR</code> 級別的日誌，不包含任何 <code>INFO</code> 或 <code>WARN</code>。</li><li><strong>需求二</strong>：暫時為某個<strong>特定功能</strong>（例如：一個支付流程）開啟 <code>DEBUG</code> 級別的日誌，但又不想修改全域設定並重啟應用。</li></ul><p>僅僅依靠 <code>level</code> 屬性，是無法滿足這些精細需求的。為此，Logback 提供了<strong>過濾器 (Filter)</strong> 機制。Filter 可以被掛載在 <code>Appender</code> 上，根據日誌事件的各種屬性（不僅僅是級別），來決定是否要處理這條日誌。</p><h2 id="Filter-的運作原理"><a href="#Filter-的運作原理" class="headerlink" title="Filter 的運作原理"></a>Filter 的運作原理</h2><p>Filter 的決策邏輯是三值的 (Tri-state logic)，它會對每一個傳入的日誌事件，回傳以下三種結果之一：</p><ol><li><strong><code>ACCEPT</code> (接受)<strong>：日誌事件被立即處理，並且</strong>不會</strong>再經過後續的其他 Filter。</li><li><strong><code>DENY</code> (拒絕)<strong>：日誌事件被立即丟棄，並且</strong>不會</strong>再經過後續的其他 Filter。</li><li>**<code>NEUTRAL</code> (中立)**：Filter 無法做出決定，將日誌事件交給過濾鏈中的下一個 Filter 處理。如果這是最後一個 Filter，則日誌事件會被正常處理。</li></ol><h2 id="ThresholdFilter-設定日誌級別門檻"><a href="#ThresholdFilter-設定日誌級別門檻" class="headerlink" title="ThresholdFilter - 設定日誌級別門檻"></a><code>ThresholdFilter</code> - 設定日誌級別門檻</h2><p>這是最簡單的 Filter。它會過濾掉所有<strong>低於</strong>指定級別的日誌事件。</p><p><strong>使用場景</strong>：假設我們的 <code>root</code> logger 級別為 <code>DEBUG</code>，但我們希望寫入到檔案的日誌，只包含 <code>WARN</code> 及以上的級別，以避免檔案過於龐大。</p><p>在 <code>logback-spring.xml</code> 中，修改我們的 <code>FILE</code> Appender：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>WARN<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>運作方式</strong>：當一條 <code>INFO</code> 或 <code>DEBUG</code> 級別的日誌傳入時，<code>ThresholdFilter</code> 會回傳 <code>DENY</code>。當一條 <code>WARN</code> 或 <code>ERROR</code> 級別的日誌傳入時，它會回傳 <code>NEUTRAL</code>，交由 Appender 正常處理。</li></ul><h2 id="LevelFilter-精準匹配特定級別"><a href="#LevelFilter-精準匹配特定級別" class="headerlink" title="LevelFilter - 精準匹配特定級別"></a><code>LevelFilter</code> - 精準匹配特定級別</h2><p><code>LevelFilter</code> 提供了更精準的匹配能力，它可以針對某個<strong>完全相同</strong>的級別進行 <code>ACCEPT</code> 或 <code>DENY</code>。</p><p><strong>使用場景</strong>：建立一個專門的檔案，<strong>只</strong>存放所有 <code>ERROR</code> 級別的日誌，以便快速定位系統中的所有錯誤。</p><ol><li><p>在 <code>logback-spring.xml</code> 中，建立一個新的 <code>Appender</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ERROR_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_DIR&#125;/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>將這個新的 Appender 加到 <code>&lt;root&gt;</code> logger 中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR_FILE&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>現在，應用程式中任何地方產生的 <code>ERROR</code> 級別日誌，都會被同時寫入到 <code>demo-app.log</code> 和專屬的 <code>error.log</code> 中。</p><h2 id="動態過濾：Marker"><a href="#動態過濾：Marker" class="headerlink" title="動態過濾：Marker"></a>動態過濾：<code>Marker</code></h2><p>有時，我們希望過濾的依據不是日誌級別，而是日誌的「內容」或「業務場景」。例如，我們想為所有與「效能監控」相關的日誌建立一個獨立的日誌檔案。這時，<strong>標記 (Marker)</strong> 就派上用場了。</p><p><code>Marker</code> 是 SLF4J API 的一部分，允許我們為日誌事件「貼上標籤」。</p><ol><li><strong>在程式碼中使用 Marker</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Marker;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.MarkerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某個 Service 中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyService.class);</span><br><span class="line"><span class="comment">// 1. 取得一個名為 &quot;PERFORMANCE&quot; 的 Marker</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Marker</span> <span class="variable">PERFORMANCE_MARKER</span> <span class="operator">=</span> MarkerFactory.getMarker(<span class="string">&quot;PERFORMANCE&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomePerformanceCriticalTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 在 log 時傳入這個 Marker</span></span><br><span class="line">    log.info(PERFORMANCE_MARKER, <span class="string">&quot;開始執行高效能關鍵任務...&quot;</span>);</span><br><span class="line">    <span class="comment">// ... 執行任務 ...</span></span><br><span class="line">    log.debug(PERFORMANCE_MARKER, <span class="string">&quot;任務執行完畢，中間結果為...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>在 <code>logback-spring.xml</code> 中根據 Marker 過濾</strong><br>我們可以使用 <code>OnMarkerEvaluator</code> 來建立一個只接受特定 Marker 的 Filter。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;PERFORMANCE_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_DIR&#125;/performance.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">evaluator</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.boolex.OnMarkerEvaluator&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">marker</span>&gt;</span>PERFORMANCE<span class="tag">&lt;/<span class="name">marker</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">evaluator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>透過這種方式，我們就建立了一個獨立的 <code>performance.log</code> 檔案，它只會收集那些被我們明確標記為 <code>PERFORMANCE</code> 的日誌，這對於特定功能的除錯與監控極其有用。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們掌握了 Logback 中比日誌級別更強大、更靈活的過濾機制。</p><ul><li>我們理解了 Filter <code>ACCEPT</code> &#x2F; <code>DENY</code> &#x2F; <code>NEUTRAL</code> 的三值決策邏輯。</li><li>我們學會了使用 <strong><code>ThresholdFilter</code></strong> 來為 Appender 設定一個最低的日誌級別門檻。</li><li>我們學會了使用 <strong><code>LevelFilter</code></strong> 來將特定級別的日誌，精準地分離到獨立的檔案中。</li><li>我們掌握了 <strong><code>Marker</code></strong> 這個強大的工具，能夠根據業務場景為日誌打上標籤，並配合 Filter 實現內容導向的動態日誌過濾。</li></ul><p>我們已經掌握了日誌的過濾。在下一篇文章中，我們將探討一個在團隊協作與正式部署中非常重要的主題——<strong>多環境日誌管理</strong>，學習如何使用 Spring Profiles 為開發、測試和生產環境定義各自獨立的日誌策略。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Logback 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logback 實戰 04 - Layout 與 MDC：客製化日誌的樣貌與內容</title>
      <link href="/2025/08/15/java-spring-logback-04/"/>
      <url>/2025/08/15/java-spring-logback-04/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：日誌的藝術與科學"><a href="#前言：日誌的藝術與科學" class="headerlink" title="前言：日誌的藝術與科學"></a>前言：日誌的藝術與科學</h2><p>在 Logback 中，<code>Layout</code> 的職責是將一個日誌事件（Log Event）轉換成一個字串。換句話說，它決定了您的日誌最終的「長相」。一份格式設計精良的日誌，應該像一份清晰的電報，在最短的篇幅內，提供最豐富、最關鍵的資訊。</p><p>Logback 中最常用、功能也最強大的 Layout 就是 <code>PatternLayout</code>。它允許我們透過類似 <code>printf</code> 格式化字串的方式，來定義日誌的輸出樣式。</p><p>本篇文章將帶您：</p><ul><li>掌握 <code>PatternLayout</code> 中所有重要的轉換符。</li><li>深入解析 Spring Boot 預設的專業日誌格式。</li><li>學習使用 MDC 為每一筆請求注入獨一無二的「追蹤 ID」，實現全鏈路日誌追蹤。</li></ul><h2 id="PatternLayout-轉換符大全"><a href="#PatternLayout-轉換符大全" class="headerlink" title="PatternLayout 轉換符大全"></a><code>PatternLayout</code> 轉換符大全</h2><p><code>PatternLayout</code> 使用 <code>%</code> 加上一個轉換符來表示不同的日誌資訊。以下是常用轉換符的速查表：</p><table><thead><tr><th align="left">分類</th><th align="left">符號</th><th align="left">說明</th><th align="left">範例輸出</th></tr></thead><tbody><tr><td align="left"><strong>基本資訊</strong></td><td align="left"><code>%m</code>, <code>%msg</code></td><td align="left">日誌訊息本身</td><td align="left"><code>User logged in</code></td></tr><tr><td align="left"></td><td align="left"><code>%p</code>, <code>%level</code></td><td align="left">日誌級別</td><td align="left"><code>INFO</code>, <code>ERROR</code></td></tr><tr><td align="left"></td><td align="left"><code>%d</code></td><td align="left">日期時間</td><td align="left"><code>2025-08-15 17:11:17,648</code></td></tr><tr><td align="left"></td><td align="left"><code>%n</code></td><td align="left">換行符</td><td align="left">(換行)</td></tr><tr><td align="left"><strong>執行緒與來源</strong></td><td align="left"><code>%t</code>, <code>%thread</code></td><td align="left">執行緒名稱</td><td align="left"><code>http-nio-8080-exec-1</code></td></tr><tr><td align="left"></td><td align="left"><code>%logger</code>, <code>%c</code></td><td align="left">Logger 名稱 (通常是類別全名)</td><td align="left"><code>com.example.demoapp.service.UserService</code></td></tr><tr><td align="left"></td><td align="left"><code>%C</code></td><td align="left">類別名稱</td><td align="left"><code>com.example.demoapp.service.UserService</code></td></tr><tr><td align="left"></td><td align="left"><code>%M</code></td><td align="left">方法名稱</td><td align="left"><code>createUser</code></td></tr><tr><td align="left"></td><td align="left"><code>%L</code></td><td align="left">程式碼行號</td><td align="left"><code>42</code></td></tr><tr><td align="left"><strong>例外資訊</strong></td><td align="left"><code>%ex</code>, <code>%wEx</code></td><td align="left">例外堆疊追蹤</td><td align="left"><code>java.lang.RuntimeException: ...</code></td></tr><tr><td align="left"><strong>上下文資訊</strong></td><td align="left"><code>%X&#123;key&#125;</code></td><td align="left">從 MDC 取得指定 key 的值</td><td align="left"><code>traceId=abcdef123</code></td></tr></tbody></table><blockquote><p><strong>效能警告</strong>：<code>%M</code> (方法名) 和 <code>%L</code> (行號) 這兩個轉換符會對效能產生較大的影響，因為 Logback 需要遍歷堆疊追蹤來獲取這些資訊。<strong>強烈建議只在開發環境中使用它們</strong>。</p></blockquote><h2 id="實戰解析：拆解-Spring-Boot-的預設-Pattern"><a href="#實戰解析：拆解-Spring-Boot-的預設-Pattern" class="headerlink" title="實戰解析：拆解 Spring Boot 的預設 Pattern"></a>實戰解析：拆解 Spring Boot 的預設 Pattern</h2><p>現在，讓我們用剛學到的知識，來解構 Spring Boot 在 <code>defaults.xml</code> 中為我們定義的 <code>CONSOLE_LOG_PATTERN</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr(%5p) %clr($&#123;PID&#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; : %m%n%wEx</span><br></pre></td></tr></table></figure><ul><li><code>%clr(...)&#123;color&#125;</code>：這是 Spring Boot 提供的一個<strong>自訂轉換規則</strong>，用於為其包裹的內容加上顏色。</li><li><code>%d&#123;...&#125;</code>：日期時間。</li><li><code>%5p</code>：日誌級別，固定 5 個字元的寬度，靠右對齊 (例如 <code> INFO</code>, <code>ERROR</code>)。</li><li><code>$&#123;PID&#125;</code>：Spring Boot 提供的變數，代表當前應用的程序 ID。</li><li><code>[%15.15t]</code>：執行緒名稱。<code>15.15</code> 是一種格式化修飾符，表示最小寬度和最大寬度都是 15 個字元，用於對齊。</li><li><code>%-40.40logger&#123;39&#125;</code>：Logger 名稱。<code>-40</code> 表示寬度 40，靠左對齊。<code>&#123;39&#125;</code> 表示最多顯示 39 個字元，通常是為了縮短過長的套件名。</li><li><code>%m%n%wEx</code>：日誌訊息、換行符，以及簡化的例外堆疊追蹤。</li></ul><p>而 <code>FILE_LOG_PATTERN</code> 則幾乎完全相同，只是移除了所有 <code>%clr()</code> 的顏色標記，因為在檔案中儲存顏色控制碼是沒有意義的。</p><h2 id="終極武器：MDC-與全鏈路日誌"><a href="#終極武器：MDC-與全鏈路日誌" class="headerlink" title="終極武器：MDC 與全鏈路日誌"></a>終極武器：MDC 與全鏈路日誌</h2><p>在一個高併發的伺服器中，來自不同使用者請求的日誌會混雜在一起，使得追蹤某一次特定請求的完整流程變得極其困難。<strong>MDC (Mapped Diagnostic Context)</strong> 正是解決這個問題的完美方案。</p><p>MDC 可以被看作是一個與<strong>當前執行緒綁定</strong>的 <code>Map</code>。我們可以在請求開始時，為這次請求產生一個唯一的 ID (通稱為 <code>traceId</code>) 並放入 MDC 中。然後，在請求處理的整個過程中，這個 <code>traceId</code> 都會跟隨著這個執行緒。最後，我們只需在日誌 pattern 中加上對它的引用，就能讓同一次請求產生的所有日誌，都帶上相同的身份標籤。</p><h3 id="步驟一：建立-Filter-來設定-MDC"><a href="#步驟一：建立-Filter-來設定-MDC" class="headerlink" title="步驟一：建立 Filter 來設定 MDC"></a>步驟一：建立 Filter 來設定 MDC</h3><p>在請求的入口處（Filter）設定 MDC，在請求結束時清除它，是標準且可靠的做法。</p><p>在 <code>com.example.demoapp.filter</code> 套件下，建立新檔案 <code>MdcFilter.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MdcFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 為每一筆請求產生一個唯一的 traceId</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).substring(<span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line">        MDC.put(<span class="string">&quot;traceId&quot;</span>, traceId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 讓請求繼續傳遞</span></span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 請求結束後，務必清除 MDC，避免在執行緒重用時發生資訊錯亂</span></span><br><span class="line">            MDC.remove(<span class="string">&quot;traceId&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步驟二：更新-Logback-Pattern"><a href="#步驟二：更新-Logback-Pattern" class="headerlink" title="步驟二：更新 Logback Pattern"></a>步驟二：更新 Logback Pattern</h3><p>現在，讓我們修改 <code>logback-spring.xml</code> 中的 <code>CONSOLE_LOG_PATTERN</code>，將 <code>traceId</code> 加進去。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE_LOG_PATTERN&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">value</span>=<span class="string">&quot;%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr(%5p) %clr($&#123;PID&#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; [%15.15t] %clr([%X&#123;traceId:-N/A&#125;])&#123;yellow&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; : %m%n%wEx&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>**<code>%X&#123;traceId:-N/A&#125;</code>**：<code>%X&#123;key&#125;</code> 是從 MDC 中獲取值的語法。我們使用了 <code>:-N/A</code> 的預設值語法，這樣對於那些不是由 HTTP 請求觸發的日誌（例如應用程式啟動日誌），這個欄位會顯示 <code>N/A</code>。</li></ul><h3 id="測試效果"><a href="#測試效果" class="headerlink" title="測試效果"></a>測試效果</h3><p>重新啟動應用程式。現在，當您發送一筆 API 請求時，您會看到從 <code>MdcFilter</code> 到 <code>Controller</code> 再到 <code>Service</code>，由這次請求觸發的所有日誌行，都帶上了**完全相同且唯一的 <code>traceId</code>**！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2025-08-15 17:11:17.648  INFO 12345 --- [o-8080-exec-1] [a8b3c1d4e5f6] c.e.d.controller.UserController  : Received request to create user...</span><br><span class="line">2025-08-15 17:11:17.650  INFO 12345 --- [o-8080-exec-1] [a8b3c1d4e5f6] c.e.d.service.UserService        : 準備註冊新使用者: testuser</span><br></pre></td></tr></table></figure><p>現在，您可以輕易地在龐大的日誌檔案中，篩選出某一次特定請求的完整執行鏈路。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們徹底掌握了日誌的「樣貌」與「內容」。</p><ul><li>我們學習了一份完整的 <strong><code>PatternLayout</code> 轉換符</strong>清單，了解了每一行日誌是如何由這些基礎元件構成的。</li><li>我們深入分析了 Spring Boot 專業的預設日誌格式，學習了其中的顏色、對齊與截斷技巧。</li><li>我們掌握了 <strong>MDC</strong> 這個終極武器，並透過實作一個 <code>Filter</code>，成功地為我們的應用程式加入了<strong>全鏈路日誌追蹤</strong>能力。</li></ul><p>我們已經完全掌握了日誌的「樣貌」與「內容」。在下一篇文章中，我們將探討日誌的「過濾」，學習如何使用 <strong>Filter</strong> 來實現比日誌級別更精準的控制，只記錄我們真正關心的訊息。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Logback 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logback 實戰 03 - Appender 深度探討：決定日誌的去向</title>
      <link href="/2025/08/15/java-spring-logback-03/"/>
      <url>/2025/08/15/java-spring-logback-03/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：日誌的目的地"><a href="#前言：日誌的目的地" class="headerlink" title="前言：日誌的目的地"></a>前言：日誌的目的地</h2><p>在 Logback 的世界裡，<code>Appender</code> 的職責非常單純而重要：<strong>它負責將格式化後的日誌事件，發送到指定的目的地</strong>。這個目的地可以是主控台、檔案、資料庫、甚至是遠端的日誌伺服器。</p><p>在上一篇文章中，我們的基礎模板已經定義了 <code>ConsoleAppender</code> 和 <code>RollingFileAppender</code>。本篇文章將帶您深入探索這兩種最常用 Appender 的進階設定，並介紹一個功能極其強大的「瑞士刀」級別 Appender——<code>SiftingAppender</code>，它能幫助我們實現動態的日誌分離。</p><h2 id="ConsoleAppender-不只是印出文字"><a href="#ConsoleAppender-不只是印出文字" class="headerlink" title="ConsoleAppender - 不只是印出文字"></a><code>ConsoleAppender</code> - 不只是印出文字</h2><p>我們基礎模板中的 <code>ConsoleAppender</code> 看似簡單，但其中隱藏了一個提升開發體驗的關鍵設定。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">withJansi</span>&gt;</span>true<span class="tag">&lt;/<span class="name">withJansi</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>**<code>&lt;withJansi&gt;true&lt;/withJansi&gt;</code>**：這個標籤是 Spring Boot 預設日誌能顯示顏色的秘密所在。它啟用了 Jansi 這個函式庫，使得 Logback 能夠在各種終端環境中，正確地解析並渲染 ANSI 顏色控制碼。這也是我們將在下一篇文章中深入探討的 <code>%clr()</code> 轉換符能夠生效的前提。</li></ul><h2 id="RollingFileAppender-精通日誌歸檔"><a href="#RollingFileAppender-精通日誌歸檔" class="headerlink" title="RollingFileAppender - 精通日誌歸檔"></a><code>RollingFileAppender</code> - 精通日誌歸檔</h2><p>對於生產環境而言，<code>RollingFileAppender</code> 是最重要的 Appender。它能夠在滿足特定條件時（例如每天凌晨，或檔案大小達到上限），自動將當前的日誌檔案歸檔，並建立一個新的檔案來繼續寫入，避免單一檔案無限增長。</p><p>其核心在於 <strong><code>&lt;rollingPolicy&gt;</code></strong> 標籤的設定。</p><h3 id="1-TimeBasedRollingPolicy-基於時間的滾動策略"><a href="#1-TimeBasedRollingPolicy-基於時間的滾動策略" class="headerlink" title="1. TimeBasedRollingPolicy (基於時間的滾動策略)"></a>1. <code>TimeBasedRollingPolicy</code> (基於時間的滾動策略)</h3><p>這是我們模板中使用的策略，也是最常見的策略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_DIR&#125;/archive/demo-app-%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>10GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>**<code>&lt;fileNamePattern&gt;</code>**：這是滾動策略的靈魂。<ul><li><code>%d</code> 是日期時間的佔位符，其格式遵循 Java 的 <code>SimpleDateFormat</code>。</li><li><code>...%d&#123;yyyy-MM-dd&#125;.log</code>：表示日誌將按<strong>天</strong>滾動。</li><li><code>...%d&#123;yyyy-MM-dd_HH&#125;.log</code>：表示日誌將按<strong>小時</strong>滾動。</li></ul></li><li>**<code>&lt;maxHistory&gt;</code>**：設定歸檔檔案的最大保留數量（根據 <code>fileNamePattern</code> 的單位，例如 30 天或 30 小時）。</li><li>**<code>&lt;totalSizeCap&gt;</code>**：設定所有歸檔檔案加總的大小上限，當超過時，最舊的檔案會被刪除。</li></ul><h3 id="2-SizeAndTimeBasedRollingPolicy-基於大小與時間的滾動策略"><a href="#2-SizeAndTimeBasedRollingPolicy-基於大小與時間的滾動策略" class="headerlink" title="2. SizeAndTimeBasedRollingPolicy (基於大小與時間的滾動策略)"></a>2. <code>SizeAndTimeBasedRollingPolicy</code> (基於大小與時間的滾動策略)</h3><p>在高日誌量的應用中，可能一天產生的日誌就超過了好幾個 GB。此時，我們需要一個更精細的策略：不僅按天滾動，當天內的單一檔案如果超過大小限制，也要進行滾動。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_DIR&#125;/archive/demo-app-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>60<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>20GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>**<code>%i</code>**：這是大小滾動的計數器。例如，當 <code>demo-app-2025-08-15.0.log</code> 檔案大小達到 <code>100MB</code> 時，Logback 會將其保留，並建立一個新的 <code>demo-app-2025-08-15.1.log</code> 檔案來繼續寫入。</li></ul><h2 id="SiftingAppender-動態分離日誌的瑞士刀"><a href="#SiftingAppender-動態分離日誌的瑞士刀" class="headerlink" title="SiftingAppender - 動態分離日誌的瑞士刀"></a><code>SiftingAppender</code> - 動態分離日誌的瑞士刀</h2><p>想像一個場景：線上有多個使用者在同時操作，其中一位使用者 <code>user-123</code> 回報了問題。如果我們能有一個只包含 <code>user-123</code> 所有操作日誌的獨立檔案，問題排查將會變得無比輕鬆。<code>SiftingAppender</code> 正是為此而生。</p><p><code>SiftingAppender</code> 像一個日誌的「路由器」，它能根據 <strong>MDC (Mapped Diagnostic Context)</strong> 中的一個值（例如 <code>userId</code>），為每一個不重複的值，動態地建立一個專屬的 Appender。</p><p><strong>實戰範例：按 <code>userId</code> 分離日誌檔案</strong></p><ol><li><strong>在程式碼中設定 MDC</strong><br>我們將在下一篇文章中深入 MDC，這裡先簡單示範。您可以在處理請求的早期（例如在一個 Filter 或 Controller 中）將使用者 ID 放入 MDC。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某個 Controller 方法中</span></span><br><span class="line">MDC.put(<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;user-123&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;使用者正在執行關鍵操作...&quot;</span>);</span><br><span class="line">MDC.remove(<span class="string">&quot;userId&quot;</span>); <span class="comment">// 操作結束後務必清除</span></span><br></pre></td></tr></table></figure></li><li><strong>設定 <code>SiftingAppender</code></strong><br>在 <code>logback-spring.xml</code> 中加入以下設定：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;SIFT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.sift.SiftingAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>userId<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>unknown<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sift</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE-$&#123;userId&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_DIR&#125;/users/$&#123;userId&#125;.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span> <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sift</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;SIFT&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li><strong>程式碼詳解</strong>：<ul><li>**<code>&lt;discriminator&gt;</code>**：定義了篩選的規則。這裡我們指定使用 MDC 中 <code>key</code> 為 <code>userId</code> 的值。如果日誌事件中沒有這個 key，則使用 <code>defaultValue</code> “unknown”。</li><li>**<code>&lt;sift&gt;</code>**：定義了 Appender 的「工廠」。對於每一個不重複的 <code>userId</code> 值（如 “user-123”, “user-456”），它都會建立一個 <code>&lt;sift&gt;</code> 區塊內定義的 <code>FileAppender</code>。注意，我們可以在 <code>name</code> 和 <code>&lt;file&gt;</code> 路徑中，使用 <code>$&#123;userId&#125;</code> 來存取這個動態的值。</li></ul></li></ul><p>現在，當您執行帶有 MDC 設定的程式碼時，除了通用的日誌檔案外，還會在 <code>logs/users/</code> 目錄下，看到一個名為 <code>user-123.log</code> 的檔案，裡面只包含了該使用者的專屬日誌！</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們已經完全掌握了日誌的「去向」。</p><ul><li>我們了解了 <code>ConsoleAppender</code> 如何透過 <code>&lt;withJansi&gt;</code> 支援彩色輸出。</li><li>我們精通了 <code>RollingFileAppender</code>，能夠根據<strong>時間</strong>和<strong>大小</strong>來設定專業的日誌歸檔策略。</li><li>我們學習了 <code>SiftingAppender</code> 這個強大的工具，能夠根據<strong>上下文</strong>動態地將日誌分離到不同的檔案中，這在複雜系統的除錯中是無價的。</li></ul><p>我們現在已經完全掌握了日誌的「去向」。在下一篇文章中，我們將深入探討日誌的「樣貌」，學習如何透過 <strong>Layout</strong> 和 <strong>MDC</strong> 來徹底客製化每一行日誌的格式與內容，並為我們的日誌注入全鏈路追蹤的靈魂。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Logback 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logback 實戰 02 - 解構 logback-spring.xml：變數、路徑與 Spring 整合</title>
      <link href="/2025/08/15/java-spring-logback-02/"/>
      <url>/2025/08/15/java-spring-logback-02/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：一切從設定檔開始"><a href="#前言：一切從設定檔開始" class="headerlink" title="前言：一切從設定檔開始"></a>前言：一切從設定檔開始</h2><p>歡迎來到「Logback 實戰」系列的第一篇實作教學。在我們深入探討日誌的輸出目的地 (<code>Appender</code>)、格式 (<code>Layout</code>) 與過濾 (<code>Filter</code>) 之前，我們必須先徹底理解承載這一切設定的容器——<code>logback-spring.xml</code> 檔案本身。</p><p>一個結構清晰、善用變數、並且能與 Spring 環境無縫整合的設定檔，是專業日誌管理的基礎。本篇文章將帶您：</p><ul><li>了解 <code>logback-spring.xml</code> 與 Spring Boot 預設設定的關係。</li><li>學習設定檔的基礎結構與常用標籤。</li><li>掌握在 Logback 中定義與使用變數的兩種核心方式。</li><li>解決日誌檔案路徑在不同環境下的管理難題。</li></ul><p>最終，我們將整合所有知識，打造一個您可以直接應用在未來任何專案中的「黃金模板」。</p><h2 id="核心觀念：覆蓋-Override-vs-引入-Include"><a href="#核心觀念：覆蓋-Override-vs-引入-Include" class="headerlink" title="核心觀念：覆蓋 (Override) vs. 引入 (Include)"></a>核心觀念：覆蓋 (Override) vs. 引入 (Include)</h2><p>當您在專案的 <code>src/main/resources</code> 目錄下建立一個 <code>logback-spring.xml</code> 檔案時，Spring Boot 的內建預設日誌設定將會<strong>完全失效</strong>。這意味著您必須從頭定義所有內容，包括日誌級別、輸出目的地和格式。</p><p>這顯然不是我們想要的，因為 Spring Boot 的預設設定（例如日誌顏色）其實非常好用。因此，業界的最佳實踐是**「引入並擴充」**，而不是完全覆蓋。</p><p>我們可以透過 <code>&lt;include&gt;</code> 標籤來引入 Spring Boot 的預設設定檔，然後在此基礎上進行客製化。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/console-appender.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="lt-configuration-gt-根元素詳解"><a href="#lt-configuration-gt-根元素詳解" class="headerlink" title="&lt;configuration&gt; 根元素詳解"></a><code>&lt;configuration&gt;</code> 根元素詳解</h2><p><code>logback-spring.xml</code> 的根元素是 <code>&lt;configuration&gt;</code>，它有幾個常用屬性：</p><ul><li><code>scan=&quot;true&quot;</code>：啟用設定檔的熱重載功能。當您在應用程式執行時修改並儲存此檔案，Logback 會自動重新載入設定。</li><li><code>scanPeriod=&quot;60 seconds&quot;</code>：設定 Logback 每隔多久檢查一次檔案是否有變更。</li><li><code>debug=&quot;false&quot;</code>：是否要印出 Logback 本身的內部除錯訊息。通常保持 <code>false</code>。</li></ul><!-- end list --><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">statusListener</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.status.NopStatusListener&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="變數系統：-lt-property-gt-與-lt-springProperty-gt"><a href="#變數系統：-lt-property-gt-與-lt-springProperty-gt" class="headerlink" title="變數系統：&lt;property&gt; 與 &lt;springProperty&gt;"></a>變數系統：<code>&lt;property&gt;</code> 與 <code>&lt;springProperty&gt;</code></h2><p>在設定檔中直接寫死路徑或格式字串是一種不好的習慣。Logback 提供了強大的變數系統。</p><h3 id="1-Logback-原生變數：-lt-property-gt"><a href="#1-Logback-原生變數：-lt-property-gt" class="headerlink" title="1. Logback 原生變數：&lt;property&gt;"></a>1. Logback 原生變數：<code>&lt;property&gt;</code></h3><p>這是 Logback 內建的變數定義方式。</p><ul><li><strong>定義</strong>：<code>&lt;property name=&quot;變數名&quot; value=&quot;變數值&quot;/&gt;</code></li><li><strong>使用</strong>：<code>$&#123;變數名&#125;</code></li><li><strong>預設值語法</strong>：<code>$&#123;變數名:-預設值&#125;</code>。如果 <code>變數名</code> 沒有被定義，就會使用冒號後面的預設值。</li></ul><!-- end list --><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_DIR&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;APP_HOME:-logs&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-與-Spring-的橋樑：-lt-springProperty-gt"><a href="#2-與-Spring-的橋樑：-lt-springProperty-gt" class="headerlink" title="2. 與 Spring 的橋樑：&lt;springProperty&gt;"></a>2. 與 Spring 的橋樑：<code>&lt;springProperty&gt;</code></h3><p>這是 Spring Boot 提供的擴充功能，也是 <code>logback-spring.xml</code> 比 <code>logback.xml</code> 更強大的地方。它允許我們讀取 Spring 環境中的任何屬性，包括 <code>application.yml</code> 中的設定值。</p><ul><li><strong>語法</strong>：<code>&lt;springProperty scope=&quot;context&quot; name=&quot;Logback變數名&quot; source=&quot;application.yml中的屬性路徑&quot;/&gt;</code></li></ul><!-- end list --><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;APP_NAME&quot;</span> <span class="attr">source</span>=<span class="string">&quot;spring.application.name&quot;</span> <span class="attr">defaultValue</span>=<span class="string">&quot;my-app&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="日誌路徑管理"><a href="#日誌路徑管理" class="headerlink" title="日誌路徑管理"></a>日誌路徑管理</h2><p>這是設定日誌時最常見的陷阱之一。</p><p><strong>問題：相對路徑的基準點是什麼？</strong><br>當您在 <code>&lt;file&gt;</code> 標籤中設定一個相對路徑，如 <code>logs/app.log</code>，這個路徑是相對於<strong>啟動 Java 虛擬機 (JVM) 時的「工作目錄」</strong>，而不是專案本身的目錄。</p><ul><li>如果您在 <code>/my-project/</code> 目錄下執行 <code>java -jar target/app.jar</code>，日誌會寫入 <code>/my-project/logs/</code>。</li><li>如果您在 <code>/</code> 根目錄下執行 <code>java -jar /my-project/target/app.jar</code>，日誌會寫入 <code>/logs/</code>。</li></ul><p><strong>最佳實踐：使用外部屬性定義日誌根目錄</strong><br>為了確保日誌路徑的穩定與可控，最佳實踐是透過系統屬性或環境變數從外部傳入一個絕對路徑。</p><ol><li><strong>啟動應用時傳入屬性</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -DAPP_HOME=/var/log/my-app -jar your-app.jar</span><br></pre></td></tr></table></figure></li><li><strong>在 <code>logback-spring.xml</code> 中接收</strong>：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_DIR&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;APP_HOME:-logs&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_DIR&#125;/application.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="整合實戰：我們的基礎模板"><a href="#整合實戰：我們的基礎模板" class="headerlink" title="整合實戰：我們的基礎模板"></a>整合實戰：我們的基礎模板</h2><p>現在，讓我們將以上所有概念，結合您之前提供的範例，整合成一份專業、可重用的 <code>logback-spring.xml</code> 基礎模板。這份模板將是我們後續所有教學的起點。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;APP_NAME&quot;</span> <span class="attr">source</span>=<span class="string">&quot;spring.application.name&quot;</span> <span class="attr">defaultValue</span>=<span class="string">&quot;application&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATH&quot;</span> <span class="attr">source</span>=<span class="string">&quot;logging.file.path&quot;</span> <span class="attr">defaultValue</span>=<span class="string">&quot;logs&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_DIR&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;LOG_PATH&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_FILE_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;APP_NAME&#125;.log&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_DIR&#125;/$&#123;LOG_FILE_NAME&#125;<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_DIR&#125;/$&#123;APP_NAME&#125;.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span> <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們為 Logback 的學習打下了堅實的基礎。</p><ul><li>我們理解了<strong>覆蓋 vs. 引入</strong>的核心觀念，並選擇了最佳實踐。</li><li>我們解構了 <code>logback-spring.xml</code> 的基礎標籤與屬性。</li><li>我們掌握了使用 <code>&lt;property&gt;</code> 和 <code>&lt;springProperty&gt;</code> 兩種方式來管理變數。</li><li>我們學會了如何以專業的方式管理日誌檔案的輸出路徑。</li><li>我們最終產出了一份可直接應用於專案的<strong>基礎模板</strong>。</li></ul><p>有了這個穩固的設定檔基礎，我們就可以開始探索 Logback 的三大核心元件了。在下一篇文章中，我們將首先深入探討 **<code>Appender</code>**，學習如何將我們的日誌精準地投遞到各種不同的目的地。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Logback 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logback 實戰 01 - 專業日誌管理學習路徑</title>
      <link href="/2025/08/15/java-spring-logback-01/"/>
      <url>/2025/08/15/java-spring-logback-01/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：超越-log-info-的藝術"><a href="#前言：超越-log-info-的藝術" class="headerlink" title="前言：超越 log.info() 的藝術"></a>前言：超越 <code>log.info()</code> 的藝術</h2><p>歡迎來到我們的第一個深度探討系列——「Logback 實戰」！</p><p>在「Spring Series 基礎」中，我們已經學會了如何使用 <code>@Slf4j</code> 和一個基礎的 <code>logback-spring.xml</code> 來記錄日誌。然而，專業的日誌管理遠不止於此。它是一門藝術，更是一門科學，是確保應用程式在複雜的生產環境中<strong>可觀測 (Observable)<strong>、</strong>可追蹤 (Traceable)</strong> 與<strong>可維護 (Maintainable)</strong> 的基石。</p><p>當線上系統出現詭異的錯誤時，一份設計精良的日誌是您最可靠的偵探；當系統面臨效能瓶頸時，日誌能為您指出問題的根源。本系列旨在帶您超越 <code>log.info()</code> 的層次，深入 Logback 框架的每一個核心角落。</p><p>這篇文章作為系列的起點，將為您呈現一張完整的學習地圖。我們將這趟深度之旅劃分為 7 個循序漸進的篇章，帶您徹底掌握 Logback 在 Spring Boot 中的專業應用。</p><h2 id="「Logback-實戰」完整學習地圖"><a href="#「Logback-實戰」完整學習地圖" class="headerlink" title="「Logback 實戰」完整學習地圖"></a>「Logback 實戰」完整學習地圖</h2><hr><h3 id="Logback-實戰-02-解構-logback-spring-xml：變數、路徑與-Spring-整合"><a href="#Logback-實戰-02-解構-logback-spring-xml：變數、路徑與-Spring-整合" class="headerlink" title="Logback 實戰 02 - 解構 logback-spring.xml：變數、路徑與 Spring 整合"></a><strong><code>Logback 實戰 02 - 解構 logback-spring.xml：變數、路徑與 Spring 整合</code></strong></h3><ul><li><strong>學習目標</strong>：在開始設定具體功能前，先徹底理解 <code>logback-spring.xml</code> 這個檔案本身的結構、變數系統與最佳實踐。</li><li><strong>學習項目規劃</strong>：<ul><li><strong>核心觀念</strong>：講解 <code>logback-spring.xml</code> 如何<strong>完全覆蓋</strong> Spring Boot 預設，以及使用 <code>&lt;include&gt;</code> 引入預設值的最佳實踐。</li><li><strong>根元素詳解</strong>：學習 <code>&lt;configuration&gt;</code> 標籤的 <code>scan</code>, <code>scanPeriod</code> 等屬性。</li><li><strong>變數系統</strong>：掌握 <code>&lt;property&gt;</code> 的定義、<code>$&#123;VAR:-defaultValue&#125;</code> 預設值語法，以及 <code>&lt;springProperty&gt;</code> 如何與 <code>application.yml</code> 互動。</li><li><strong>日誌路徑管理</strong>：深入探討<strong>相對&#x2F;絕對路徑</strong>的行為，並學習使用環境變數 (<code>$&#123;APP_HOME&#125;</code>) 的生產環境部署策略。</li></ul></li></ul><hr><h3 id="Logback-實戰-03-Appender-深度探討：決定日誌的去向"><a href="#Logback-實戰-03-Appender-深度探討：決定日誌的去向" class="headerlink" title="Logback 實戰 03 - Appender 深度探討：決定日誌的去向"></a><strong><code>Logback 實戰 03 - Appender 深度探討：決定日誌的去向</code></strong></h3><ul><li><strong>學習目標</strong>：<code>Appender</code> 決定了日誌的最終輸出目的地。本篇將帶您深入了解幾種最常用 Appender 的進階設定與使用場景。</li><li><strong>學習項目規劃</strong>：<ul><li>**<code>ConsoleAppender</code>**：學習 <code>&lt;withJansi&gt;true</code> 如何啟用終端機的彩色日誌輸出。</li><li><strong><code>RollingFileAppender</code><strong>：精通檔案滾動策略，包含基於</strong>時間</strong> (<code>TimeBasedRollingPolicy</code>) 與<strong>大小和時間</strong> (<code>SizeAndTimeBasedRollingPolicy</code>) 的日誌歸檔。</li><li>**<code>SiftingAppender</code>**：學習如何根據 MDC 中的動態值（例如 <code>userId</code>），將日誌自動分離到不同的檔案中。</li></ul></li></ul><hr><h3 id="Logback-實戰-04-Layout-與-MDC：客製化日誌的樣貌與內容"><a href="#Logback-實戰-04-Layout-與-MDC：客製化日誌的樣貌與內容" class="headerlink" title="Logback 實戰 04 - Layout 與 MDC：客製化日誌的樣貌與內容"></a><strong><code>Logback 實戰 04 - Layout 與 MDC：客製化日誌的樣貌與內容</code></strong></h3><ul><li><strong>學習目標</strong>：<code>Layout</code> 決定了每一行日誌的輸出格式。本篇將教您如何完全客製化日誌樣式，並透過 MDC 為日誌注入豐富的上下文追蹤資訊。</li><li><strong>學習項目規劃</strong>：<ul><li>**精通 <code>PatternLayout</code>**：深入解析 Spring Boot 預設的 <code>CONSOLE_LOG_PATTERN</code>，學習 <code>%clr</code>, <code>$&#123;PID&#125;</code>, 以及 <code>%-40.40logger&#123;39&#125;</code> 等進階格式符號。</li><li>**MDC (Mapped Diagnostic Context)**：學習如何透過實作 <code>Filter</code>，為每一筆 HTTP 請求加上唯一的 <code>traceId</code>，並使用 <code>%X&#123;traceId&#125;</code> 將其印在日誌上。</li><li><strong>進階技巧</strong>：學習使用 <code>%replace</code> 來過濾日誌中的敏感資訊（如密碼）。</li></ul></li></ul><hr><h3 id="Logback-實戰-05-Filter-精準過濾：只看您想看的日誌"><a href="#Logback-實戰-05-Filter-精準過濾：只看您想看的日誌" class="headerlink" title="Logback 實戰 05 - Filter 精準過濾：只看您想看的日誌"></a><strong><code>Logback 實戰 05 - Filter 精準過濾：只看您想看的日誌</code></strong></h3><ul><li><strong>學習目標</strong>：<code>Filter</code> 提供了比日誌級別 <code>level</code> 更細緻、更強大的過濾能力。</li><li><strong>學習項目規劃</strong>：<ul><li>**<code>LevelFilter</code>**：學習如何精準地「只匹配」或「排除」特定級別的日誌。</li><li>**<code>ThresholdFilter</code>**：學習如何過濾掉低於某個閾值級別的所有日誌。</li><li>**<code>TurboFilter</code> 與 <code>Marker</code>**：學習如何為特定日誌加上標記，並結合 <code>TurboFilter</code> 實現更動態、更高性能的日誌過濾。</li></ul></li></ul><hr><h3 id="Logback-實戰-06-多環境日誌管理-Spring-Profiles"><a href="#Logback-實戰-06-多環境日誌管理-Spring-Profiles" class="headerlink" title="Logback 實戰 06 - 多環境日誌管理 (Spring Profiles)"></a><strong><code>Logback 實戰 06 - 多環境日誌管理 (Spring Profiles)</code></strong></h3><ul><li><strong>學習目標</strong>：為開發 (dev)、測試 (test)、生產 (prod) 等不同環境，定義各自獨立且合適的日誌策略。</li><li><strong>學習項目規劃</strong>：<ul><li><strong><code>&lt;springProfile&gt;</code> 標籤</strong>：學習在 <code>logback-spring.xml</code> 中使用此標籤來包裹特定環境的設定區塊。</li><li><strong>環境策略實踐</strong>：設計一套適合開發（詳細、輸出到 Console）與生產（精簡、輸出到檔案）的日誌組態。</li><li><strong>組合應用</strong>：結合 <code>&lt;springProperty&gt;</code>，從 <code>application-&#123;profile&#125;.yml</code> 中動態讀取日誌路徑等設定。</li></ul></li></ul><hr><h3 id="Logback-實戰-07-AsyncAppender-與效能調校"><a href="#Logback-實戰-07-AsyncAppender-與效能調校" class="headerlink" title="Logback 實戰 07 - AsyncAppender 與效能調校"></a><strong><code>Logback 實戰 07 - AsyncAppender 與效能調校</code></strong></h3><ul><li><strong>學習目標</strong>：在高併發的系統中，同步寫入日誌可能會成為效能瓶頸。本篇將帶您學習如何使用非同步日誌來提升應用程式的吞吐量。</li><li><strong>學習項目規劃</strong>：<ul><li><strong><code>AsyncAppender</code> 原理</strong>：了解其如何透過阻塞佇列與背景執行緒，將日誌寫入操作與主業務執行緒解耦。</li><li><strong>設定與調校</strong>：學習如何將現有 Appender 包裝成 <code>AsyncAppender</code>，並探討 <code>queueSize</code>、<code>discardingThreshold</code> 等重要參數的設定考量。</li><li>**安全關閉 (Graceful Shutdown)**：了解如何確保在應用程式關閉時，佇列中的日誌能被完全寫入，避免資訊遺失。</li></ul></li></ul><hr><p>這趟深度之旅將徹底改造您對日誌的認知，讓您具備設計與管理專業級日誌系統的能力。</p><p>請準備好，從下一篇文章「**<code>Logback 實戰 02 - 解構 logback-spring.xml：變數、路徑與 Spring 整合</code>**」開始，我們將一同解構 <code>logback-spring.xml</code> 的每一個細節。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Logback 實戰 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 30 - 部署至雲端平台 (初步探討)</title>
      <link href="/2025/08/15/java-spring-boot-30/"/>
      <url>/2025/08/15/java-spring-boot-30/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：我們的下一步？"><a href="#前言：我們的下一步？" class="headerlink" title="前言：我們的下一步？"></a>前言：我們的下一步？</h2><p>恭喜您！歷經了前面 29 篇文章的學習與實踐，您已經從零開始，成功地開發、測試、保護並將一個功能完備的 Spring Boot 應用程式打包成了一個標準化的 Docker 容器。</p><p>現在，我們手裡握著這個裝載著我們心血結晶的「箱子」（Docker 映像檔），只剩下最後一個、也是最關鍵的問題：<strong>該把這個箱子放在哪裡，才能讓全世界的使用者都能訪問到它？</strong></p><p>答案就是<strong>雲端平台</strong>。</p><p>本篇文章作為我們基礎系列的最終章，將不會深入探討某一個特定平台的繁瑣技術細節（因為每一個平台本身都足以成為一個獨立的系列）。相反地，本文旨在為您提供一張「雲端部署的世界地圖」，介紹核心的部署概念與主流的平台選擇，幫助您為下一步的學習與實踐指明方向。</p><h2 id="部署的核心任務"><a href="#部署的核心任務" class="headerlink" title="部署的核心任務"></a>部署的核心任務</h2><p>將一個應用程式部署到線上，通常涉及以下幾個核心任務：</p><ol><li><strong>準備基礎設施</strong>：需要有伺服器（虛擬機）、網路設定、防火牆規則等。</li><li><strong>執行應用程式</strong>：需要在伺服器上安裝好 Docker 環境，並執行我們的容器。</li><li><strong>對外暴露服務</strong>：需要設定公開的 IP 位址、網域名稱 (DNS)，甚至可能需要負載平衡器。</li><li><strong>管理資料庫</strong>：生產環境不能使用 H2 記憶體資料庫，我們需要一個真實、持久化的資料庫服務（如 PostgreSQL, MySQL）。</li><li><strong>監控與日誌</strong>：應用程式上線後，需要有方法來查看遠端伺服器上的日誌，並監控其運行狀況。</li></ol><p>雲端平台的主要價值，就是將以上這些複雜的任務大幅簡化。</p><h2 id="雲端服務模式：IaaS-vs-PaaS"><a href="#雲端服務模式：IaaS-vs-PaaS" class="headerlink" title="雲端服務模式：IaaS vs. PaaS"></a>雲端服務模式：IaaS vs. PaaS</h2><p>在選擇雲端平台時，我們主要會遇到兩種服務模式：</p><h3 id="1-IaaS-Infrastructure-as-a-Service-基礎設施即服務"><a href="#1-IaaS-Infrastructure-as-a-Service-基礎設施即服務" class="headerlink" title="1. IaaS (Infrastructure as a Service - 基礎設施即服務)"></a>1. IaaS (Infrastructure as a Service - 基礎設施即服務)</h3><ul><li><strong>比喻</strong>：租賃一塊空地和一堆建材。</li><li><strong>您得到什麼</strong>：最原始的運算資源，如虛擬機 (VM)、儲存空間和網路。例如 AWS EC2, Google Compute Engine。</li><li><strong>您需要管理</strong>：從作業系統的安裝與更新、環境配置（安裝 Java, Docker）、網路設定、資料庫安裝與維護…幾乎所有事情都需要您親力親為。</li><li><strong>優劣</strong>：提供最大的客製化彈性與控制權，但管理起來最複雜，人力成本最高。</li></ul><h3 id="2-PaaS-Platform-as-a-Service-平台即服務"><a href="#2-PaaS-Platform-as-a-Service-平台即服務" class="headerlink" title="2. PaaS (Platform as a Service - 平台即服務)"></a>2. PaaS (Platform as a Service - 平台即服務)</h3><ul><li><strong>比喻</strong>：租賃一間精裝修的公寓，您只需帶著自己的行李（程式碼）即可入住。</li><li><strong>您得到什麼</strong>：一個完整的應用程式執行平台。您只需要提供您的程式碼或 Docker 映像檔，平台會自動處理作業系統、執行環境、伺服器擴展、負載平衡等所有繁瑣的底層工作。</li><li><strong>您需要管理</strong>：只需要專注於您的應用程式本身。</li><li><strong>優劣</strong>：極大地簡化了部署與維運的複雜性，讓開發者能專注於業務，是上手最快的方式。</li></ul><blockquote><p><strong>給初學者的建議</strong>：<strong>從 PaaS 開始</strong>。它能讓您在不被繁雜的伺服器管理事務分散注意力的情況下，快速體驗到將應用程式上線的完整流程。</p></blockquote><h2 id="熱門-PaaS-平台簡介"><a href="#熱門-PaaS-平台簡介" class="headerlink" title="熱門 PaaS 平台簡介"></a>熱門 PaaS 平台簡介</h2><p>以下是幾個非常適合用來部署我們 Spring Boot Docker 容器的熱門 PaaS 平台：</p><ul><li><p><strong>Heroku</strong>：PaaS 領域的先驅之一，以其極致的簡潔與優異的開發者體驗而聞名。通常只需將程式碼推送到 Heroku 的 Git 倉庫，或將 Docker 映像檔推送到其容器倉庫，即可完成部署。非常適合個人專案、新創公司與快速原型開發。</p></li><li><p><strong>AWS Elastic Beanstalk</strong>：Amazon Web Services (AWS) 提供的 PaaS 服務。它能與龐大的 AWS 生態系（如 RDS 資料庫、S3 儲存）無縫整合，提供強大的擴展性。您只需上傳 JAR 檔或指向一個 Docker 映像檔，它就會自動為您佈建所需的 AWS 資源。</p></li><li><p><strong>Google Cloud Run</strong>：Google Cloud 提供的現代化 Serverless 容器平台。它的最大特色是「按實際用量付費」，甚至可以在沒有任何請求時，自動縮容到零實例，極具成本效益。您只需將 Docker 映像檔推送到 Google 的容器倉庫即可部署。</p></li></ul><h2 id="部署流程概覽（以-Docker-映像檔為例）"><a href="#部署流程概覽（以-Docker-映像檔為例）" class="headerlink" title="部署流程概覽（以 Docker 映像檔為例）"></a>部署流程概覽（以 Docker 映像檔為例）</h2><p>無論您選擇哪個 PaaS 平台，部署我們在上一篇建立的 Docker 映像檔，其通用流程大致如下：</p><ol><li><strong>程式碼準備</strong>：確保您的 <code>application-prod.yml</code> 已設定好使用<strong>環境變數</strong>來讀取資料庫密碼等敏感資訊。</li><li><strong>建置映像檔</strong>：在本機執行 <code>mvn spring-boot:build-image</code>，並為其指定一個正式的名稱，例如 <code>your-id/demo-app:1.0</code>。</li><li><strong>推送映像檔至倉庫 (Registry)<strong>：您不能直接將本機的映像檔部署到雲端。您需要先將它推送到一個雲端的</strong>容器倉庫</strong>，例如 Docker Hub, AWS ECR, 或 Google Artifact Registry。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push your-id/demo-app:1.0</span><br></pre></td></tr></table></figure></li><li><strong>在雲端平台設定</strong>：<ul><li>在您選擇的 PaaS 平台上（如 Heroku），建立一個新的應用程式。</li><li>將應用程式的來源指向您剛剛推送到容器倉庫的映像檔。</li><li>在平台上<strong>建立一個資料庫服務</strong>（例如 Heroku Postgres），並取得其連線 URL、使用者名稱和密碼。</li><li>在平台的<strong>環境變數設定</strong>頁面，設定好 <code>SPRING_PROFILES_ACTIVE=prod</code>，以及資料庫連線所需的 <code>PROD_DB_PASSWORD</code> 等變數。</li></ul></li><li><strong>部署與啟動</strong>：點擊平台的「部署」按鈕。平台會自動從倉庫拉取您的映像檔，啟動容器，並將其連接到您設定好的資料庫，最後提供給您一個公開的網址。</li></ol><h2 id="旅程的終點，亦是新的起點"><a href="#旅程的終點，亦是新的起點" class="headerlink" title="旅程的終點，亦是新的起點"></a>旅程的終點，亦是新的起點</h2><p>恭喜您完成了「Spring Series 基礎」的全部 30 篇文章！</p><p>回首這段旅程，我們從一個簡單的 API 開始，逐步加入了資料庫整合、日誌、API 文件、專業的錯誤處理、完整的自動化測試、滴水不漏的安全性驗證，最終，我們將應用程式打包成了一個可隨處運行的 Docker 容器，並展望了通往世界的雲端之路。</p><p>您現在所掌握的，已經是一套足以應對真實世界專案開發的完整核心技能。這份「基礎系列」為您打下了堅實的地基，而我們在之前規劃的<strong>支線任務</strong>——關於 JPA、Security 等主題的深度探討系列，將是您在這塊地基上，建造高樓大廈的下一步。</p><p>軟體開發的世界學無止境，願您永保好奇，持續學習。感謝您的跟隨，期待在下一個系列再會！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 29 - 使用 Buildpacks 建置 Docker 映像檔</title>
      <link href="/2025/08/14/java-spring-boot-29/"/>
      <url>/2025/08/14/java-spring-boot-29/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：告別「在我電腦上可以跑」的窘境"><a href="#前言：告別「在我電腦上可以跑」的窘境" class="headerlink" title="前言：告別「在我電腦上可以跑」的窘境"></a>前言：告別「在我電腦上可以跑」的窘境</h2><p>我們已經成功開發了一個功能豐富的 Spring Boot 應用程式。現在，下一個問題是：如何將它部署到真實的伺服器或雲端平台上？</p><p>傳統的方式可能是：在伺服器上安裝好特定版本的 Java，然後將我們打包好的 JAR 檔複製上去，再透過指令列執行。這種方式常常會引發經典的窘境——「在我電腦上明明可以跑，為什麼在伺服器上就不行了？」，問題通常出在環境不一致（如 Java 版本、作業系統依賴等）。</p><p>為了解決這個問題，<strong>容器化 (Containerization)</strong> 技術應運而生，而 <strong>Docker</strong> 正是這項技術的代名詞。</p><p><strong>Docker 容器</strong>可以被想像成一個輕量級、獨立的「箱子」，這個箱子裡打包了執行我們應用程式所需的一切：程式碼、執行環境 (JVM)、系統工具、函式庫等等。這個「箱子」可以在任何安裝了 Docker 的機器上以完全相同的方式執行，從而徹底解決了環境不一致的問題。</p><p>本篇文章將帶您學習如何使用 Spring Boot 內建的 <strong>Cloud Native Buildpacks</strong> 功能，以一種極其簡單的方式，將我們的應用程式打包成一個專業的 Docker 映像檔 (Image)。</p><h2 id="Docker-與傳統-Dockerfile"><a href="#Docker-與傳統-Dockerfile" class="headerlink" title="Docker 與傳統 Dockerfile"></a>Docker 與傳統 <code>Dockerfile</code></h2><p><strong>前置條件</strong>：在開始之前，請確保您的電腦上已經安裝並正在執行 <strong>Docker Desktop</strong> (適用於 Windows&#x2F;macOS) 或 Docker Engine (適用於 Linux)。您可以從 <a href="https://www.docker.com/products/docker-desktop/">Docker 官網</a>下載。</p><p>傳統上，要建立一個 Docker 映像檔，我們需要手動撰寫一個名為 <code>Dockerfile</code> 的設定檔，內容大致如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 傳統方式：手動撰寫 Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">21</span>-slim</span><br><span class="line"><span class="keyword">ARG</span> JAR_FILE=target/*.jar</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> <span class="variable">$&#123;JAR_FILE&#125;</span> app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>這種方式需要開發者自己選擇基礎映像檔、撰寫指令、並手動進行最佳化，有一定的學習成本。</p><h2 id="現代化的選擇：Cloud-Native-Buildpacks"><a href="#現代化的選擇：Cloud-Native-Buildpacks" class="headerlink" title="現代化的選擇：Cloud Native Buildpacks"></a>現代化的選擇：Cloud Native Buildpacks</h2><p>幸運的是，Spring Boot 2.3 版之後，內建了對 <strong>Cloud Native Buildpacks</strong> 的支援，徹底改變了遊戲規則。</p><p><strong>Buildpacks</strong> 是一種比 <code>Dockerfile</code> 更高層次的抽象。您可以把它想像成一個「智慧建築師」，它會自動檢測您的專案類型（「喔，這是一個 Spring Boot 應用！」），然後運用它的專業知識，自動地為您選擇最佳的基礎作業系統、設定最合適的 JVM，並以最高效的方式，建置出一個分層優化、安全且標準化的 Docker 映像檔。</p><p><strong>使用 Buildpacks 的優點</strong>：</p><ul><li>**無需 <code>Dockerfile</code>**：完全不需要撰寫任何 Docker 相關的設定檔。</li><li><strong>分層優化</strong>：Buildpacks 會智慧地將應用程式拆分成多個圖層（作業系統、JVM、相依性函式庫、您自己的程式碼）。當您修改程式碼並重新建置時，只需要更新變動的圖層，大幅提升了建置與部署的速度。</li><li><strong>安全性</strong>：當底層的作業系統或 JVM 出現安全漏洞時，平台可以集中更新基礎映像檔，您只需重新建置即可套用安全補丁，而無需修改任何應用程式程式碼。</li></ul><h2 id="步驟一：使用-Buildpacks-建置您的第一個映像檔"><a href="#步驟一：使用-Buildpacks-建置您的第一個映像檔" class="headerlink" title="步驟一：使用 Buildpacks 建置您的第一個映像檔"></a>步驟一：使用 Buildpacks 建置您的第一個映像檔</h2><p>得益於 <code>spring-boot-maven-plugin</code>（它已預設包含在我們的 <code>pom.xml</code> 中），將我們的應用程式打包成 Docker 映像檔，只需要<strong>一個指令</strong>。</p><ol><li><p><strong>打開終端機</strong><br>在您的專案根目錄下（與 <code>pom.xml</code> 同一層），打開 VSCode 的整合式終端機。</p></li><li><p><strong>執行建置指令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:build-image</span><br></pre></td></tr></table></figure><p>第一次執行時，Maven 會需要一些時間來下載所需的「建置器 (builder)」映像檔。請耐心等待。當您看到 <code>Successfully built image ...</code> 的訊息時，就代表成功了！</p></li><li><p><strong>（選用）自訂映像檔名稱</strong><br>預設情況下，映像檔的名稱會是 <code>pom.xml</code> 中的 <code>artifactId</code> 和 <code>version</code> 的組合（例如 <code>demo-app:0.0.1-SNAPSHOT</code>）。您可以使用 <code>-D</code> 參數來指定一個更具意義的名稱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:build-image -Dspring-boot.build-image.imageName=your-dockerhub-id/demo-app:1.0</span><br></pre></td></tr></table></figure></li></ol><h2 id="步驟二：執行您的-Docker-容器"><a href="#步驟二：執行您的-Docker-容器" class="headerlink" title="步驟二：執行您的 Docker 容器"></a>步驟二：執行您的 Docker 容器</h2><ol><li><p><strong>驗證映像檔</strong><br>在終端機中執行以下指令，來查看您本機的所有 Docker 映像檔：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>您應該能在列表中看到我們剛剛建立的 <code>demo-app</code> 映像檔。</p></li><li><p><strong>執行容器</strong><br>使用 <code>docker run</code> 指令來從這個映像檔啟動一個新的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 demo-app:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li><strong>指令詳解</strong>：<ul><li><code>docker run</code>：從映像檔建立並啟動一個容器。</li><li><code>-p 8080:8080</code>：<strong>埠口映射 (Port Mapping)<strong>。這一步非常關鍵。它將我們</strong>本機電腦 (Host) 的 8080 埠</strong>，映射到<strong>容器內部 (Container) 的 8080 埠</strong>（Spring Boot 應用預設監聽的埠口）。這使得我們可以透過本機的瀏覽器來訪問在容器中執行的應用程式。</li><li><code>demo-app:0.0.1-SNAPSHOT</code>：您要執行的映像檔名稱。</li></ul></li></ul><!-- end list --><ol start="3"><li><p><strong>測試應用</strong><br>容器啟動後，它就像一個獨立的迷你伺服器。打開您的瀏覽器，訪問 <code>http://localhost:8080/swagger-ui.html</code> 或任何其他的 API 端點。您會發現，應用程式的行為與我們之前直接在本機執行時<strong>完全一樣</strong>！</p></li><li><p><strong>管理容器</strong></p><ul><li>查看正在執行的容器：<code>docker ps</code></li><li>停止容器：<code>docker stop &lt;容器ID&gt;</code>（容器 ID 可以從 <code>docker ps</code> 的結果中找到）</li></ul></li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們成功地將我們的 Spring Boot 應用程式「容器化」，使其成為一個可移植、獨立且環境一致的專業交付產物。</p><ul><li>我們理解了 <strong>Docker 容器</strong>對於解決「環境不一致」問題的重要性。</li><li>我們學會了使用 Spring Boot 內建的 <strong>Cloud Native Buildpacks</strong> 功能，僅用一個 <code>mvn</code> 指令就完成了 Docker 映像檔的建置，而無需手寫 <code>Dockerfile</code>。</li><li>我們掌握了如何使用 <code>docker run</code> 指令來啟動我們的應用程式容器，並透過埠口映射從外部訪問它。</li></ul><p>我們已經將我們的應用程式打包成一個標準的 Docker 容器。在我們這個基礎系列的最後一篇文章中，我們將一起探討將這個容器<strong>部署到雲端平台</strong>的基本思路與常見選擇，為您的專案上線畫上圓滿的句點。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 28 - 檔案上傳與下載</title>
      <link href="/2025/08/13/java-spring-boot-28/"/>
      <url>/2025/08/13/java-spring-boot-28/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：處理非文字資料"><a href="#前言：處理非文字資料" class="headerlink" title="前言：處理非文字資料"></a>前言：處理非文字資料</h2><p>我們的應用程式到目前為止，處理的都是純文字或 JSON 格式的資料。然而，真實世界的應用程式，例如社群媒體、文件管理系統或電子商務平台，都離不開處理檔案的需求：使用者需要上傳頭像、分享圖片、提交 PDF 文件，或是下載報表等。</p><p>Spring Boot 對於處理檔案上傳（基於 <code>multipart/form-data</code> 請求）提供了極佳的內建支援。本篇文章將帶您學習如何：</p><ol><li>設定應用程式以接收檔案上傳，並限制其大小。</li><li>建立一個 API 端點，使用 Spring 的 <code>MultipartFile</code> 介面來接收上傳的檔案，並將其儲存到伺服器。</li><li>建立另一個 API 端點，允許使用者安全地從伺服器下載先前上傳的檔案。</li></ol><h2 id="步驟一：設定檔案上傳組態"><a href="#步驟一：設定檔案上傳組態" class="headerlink" title="步驟一：設定檔案上傳組態"></a>步驟一：設定檔案上傳組態</h2><p>雖然 Spring Boot 預設已啟用檔案上傳功能，但設定合理的檔案大小限制是一個非常重要的安全實踐，可以防止惡意使用者透過上傳超大檔案來耗盡您的伺服器資源。</p><p>打開 <code>src/main/resources/application.yml</code>，加入以下組態：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 spring: 層級下新增</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line">  <span class="attr">multipart:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">max-file-size:</span> <span class="string">10MB</span>   <span class="comment"># 設定單一檔案的最大大小</span></span><br><span class="line">    <span class="attr">max-request-size:</span> <span class="string">100MB</span> <span class="comment"># 設定整個請求的最大大小 (可包含多個檔案)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我們也定義一個客製化屬性來存放檔案儲存路徑</span></span><br><span class="line"><span class="attr">file:</span></span><br><span class="line">  <span class="attr">storage:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">&quot;./uploads&quot;</span> <span class="comment"># 將檔案儲存在應用程式根目錄下的 uploads 資料夾</span></span><br></pre></td></tr></table></figure><ul><li><code>max-file-size</code>: 限制單一檔案的大小。</li><li><code>max-request-size</code>: 限制一次 HTTP 請求的總大小。</li></ul><h2 id="步驟二：實作檔案儲存服務"><a href="#步驟二：實作檔案儲存服務" class="headerlink" title="步驟二：實作檔案儲存服務"></a>步驟二：實作檔案儲存服務</h2><p>將檔案儲存與讀取的邏輯，封裝在一個獨立的 Service 中是一種良好的設計模式。</p><p>在 <code>com.example.demoapp.service</code> 套件下，建立新檔案 <code>FileStorageService.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.UrlResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardCopyOption;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileStorageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Path rootLocation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileStorageService</span><span class="params">(<span class="meta">@Value(&quot;$&#123;file.storage.location&#125;&quot;)</span> String storageLocation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rootLocation = Paths.get(storageLocation);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果儲存目錄不存在，就建立它</span></span><br><span class="line">            Files.createDirectories(<span class="built_in">this</span>.rootLocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;無法初始化檔案儲存位置！&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 儲存檔案</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">store</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> StringUtils.cleanPath(file.getOriginalFilename());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isEmpty() || filename.contains(<span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;檔案為空或包含無效路徑！ &quot;</span> + filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Path</span> <span class="variable">targetLocation</span> <span class="operator">=</span> <span class="built_in">this</span>.rootLocation.resolve(filename);</span><br><span class="line">            <span class="comment">// 將檔案的輸入流複製到目標位置，如果已存在則覆蓋</span></span><br><span class="line">            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">            <span class="keyword">return</span> filename;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;儲存檔案失敗！ &quot;</span> + filename, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 讀取檔案</span></span><br><span class="line">    <span class="keyword">public</span> Resource <span class="title function_">loadAsResource</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Path</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.rootLocation.resolve(filename);</span><br><span class="line">            <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(file.toUri());</span><br><span class="line">            <span class="keyword">if</span> (resource.exists() || resource.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> resource;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;無法讀取檔案: &quot;</span> + filename);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;無法讀取檔案: &quot;</span> + filename, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ul><li>建構子透過 <code>@Value</code> 註解讀取我們在 <code>application.yml</code> 中定義的儲存路徑，並在需要時建立該目錄。</li><li><code>store</code> 方法接收一個 <code>MultipartFile</code> 物件，進行基本的安全檢查後，將其內容儲存到我們的目標路徑下。</li><li><code>loadAsResource</code> 方法根據檔案名稱，將本地檔案載入成一個 Spring 的 <code>Resource</code> 物件，這是一個便於後續操作的資源抽象。</li></ul></li></ul><h2 id="步驟三：建立檔案上傳與下載-Controller"><a href="#步驟三：建立檔案上傳與下載-Controller" class="headerlink" title="步驟三：建立檔案上傳與下載 Controller"></a>步驟三：建立檔案上傳與下載 Controller</h2><p>現在，我們來建立對應的 API 端點。</p><p>在 <code>com.example.demoapp.controller</code> 套件下，建立新檔案 <code>FileController.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.service.FileStorageService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.ServletUriComponentsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/files&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileStorageService fileStorageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handleFileUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> fileStorageService.store(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 產生可供下載的 URI</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">downloadUri</span> <span class="operator">=</span> ServletUriComponentsBuilder.fromCurrentContextPath()</span><br><span class="line">                .path(<span class="string">&quot;/files/download/&quot;</span>)</span><br><span class="line">                .path(filename)</span><br><span class="line">                .toUriString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(<span class="string">&quot;檔案上傳成功！ 下載連結: &quot;</span> + downloadUri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/download/&#123;filename:.+&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Resource&gt; <span class="title function_">serveFile</span><span class="params">(<span class="meta">@PathVariable</span> String filename)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">file</span> <span class="operator">=</span> fileStorageService.loadAsResource(filename);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 設定回應標頭，告知瀏覽器這是一個需要下載的附件</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">                .header(HttpHeaders.CONTENT_DISPOSITION, <span class="string">&quot;attachment; filename=\&quot;&quot;</span> + file.getFilename() + <span class="string">&quot;\&quot;&quot;</span>)</span><br><span class="line">                .body(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ul><li><strong><code>/upload</code> 端點</strong>：<ul><li><code>@RequestParam(&quot;file&quot;) MultipartFile file</code>：這是接收檔案的關鍵。Spring 會自動將 <code>multipart/form-data</code> 請求中，名稱為 <code>file</code> 的部分，綁定到 <code>MultipartFile</code> 物件上。</li><li><code>ServletUriComponentsBuilder</code>：這是一個好用的工具類別，可以用來建構下載連結，這是一種 RESTful 的良好實踐。</li></ul></li><li><strong><code>/download/&#123;filename:.+&#125;</code> 端點</strong>：<ul><li><code>ResponseEntity&lt;Resource&gt;</code>：回傳 Spring 的 <code>Resource</code> 物件，Spring Boot 會自動處理將檔案內容串流到 HTTP 回應中。</li><li><code>HttpHeaders.CONTENT_DISPOSITION</code>: <strong>這是觸發瀏覽器下載行為的關鍵標頭</strong>。<code>attachment</code> 表示這是一個附件，瀏覽器應提示使用者儲存，而不是試圖直接在頁面上顯示它。</li></ul></li></ul></li></ul><h2 id="步驟四：測試檔案上傳與下載"><a href="#步驟四：測試檔案上傳與下載" class="headerlink" title="步驟四：測試檔案上傳與下載"></a>步驟四：測試檔案上傳與下載</h2><p>檔案上傳無法直接透過瀏覽器網址列測試，您需要使用 API 測試工具。</p><p>**測試上傳 (以 Postman 為例)**：</p><ol><li>建立一個新請求，方法設為 <code>POST</code>，URL 為 <code>http://localhost:8080/files/upload</code>。</li><li>切換到 “Body” 頁籤，選擇 “form-data”。</li><li>在 KEY 欄位輸入 <code>file</code>。在其右側的下拉選單中，將類型從 “Text” 改為 “File”。</li><li>在 VALUE 欄位，點擊 “Select Files” 並從您的電腦中選擇一個檔案（例如一張圖片）。</li><li>點擊「傳送 (Send)」。您應該會收到成功的訊息與下載連結。</li></ol><p><strong>測試下載</strong>：</p><ol><li>複製上傳成功後回傳的下載連結中的檔案名稱（例如 <code>my-image.png</code>）。</li><li>打開瀏覽器，直接訪問下載 URL：<code>http://localhost:8080/files/download/my-image.png</code>。</li><li>瀏覽器應該會自動跳出儲存檔案的對話框。</li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們成功地為應用程式加入了檔案處理的完整流程。</p><ul><li>我們學會了如何設定 Spring Boot 來處理 <code>multipart</code> 請求，並加上安全的大小限制。</li><li>我們建立了一個專門的 Service 來封裝檔案的儲存與讀取邏輯。</li><li>我們掌握了如何使用 <code>MultipartFile</code> 來接收上傳的檔案。</li><li>我們學會了如何回傳 <code>Resource</code> 物件，並設定 <code>Content-Disposition</code> 標頭來實現檔案下載。</li></ul><p>我們已經掌握了 Web 開發中多項實用的功能。在接下來的文章中，我們將學習如何將我們的應用程式打包成一個獨立的、可移植的 <strong>Docker 容器</strong>，為最終的部署做好準備。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 27 - 使用 Spring Mail 寄送電子郵件</title>
      <link href="/2025/08/13/java-spring-boot-27/"/>
      <url>/2025/08/13/java-spring-boot-27/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：從模擬到真實"><a href="#前言：從模擬到真實" class="headerlink" title="前言：從模擬到真實"></a>前言：從模擬到真實</h2><p>在上一篇文章中，我們使用 <code>Thread.sleep()</code> 來模擬一個耗時的背景任務，並成功地透過 <code>@Async</code> 實現了非同步執行，從而提升了 API 的回應速度。當時我們舉的例子，正是「寄送歡迎郵件」。</p><p>現在，是時候將這個模擬功能，替換成一個真實的電子郵件寄送服務了。Spring Boot 透過 <code>spring-boot-starter-mail</code> 提供了對 JavaMail API 的絕佳支援，讓寄送郵件這件原本可能很繁瑣的事情，變得異常簡單。</p><p>本篇文章將帶您整合 Spring Mail，設定 SMTP 伺服器，並學習如何使用 <code>JavaMailSender</code> 來寄送純文字與 HTML 格式的郵件。最重要的是，我們將把這個功能與上一篇學到的 <code>@Async</code> 知識完美結合，打造一個不阻塞主執行緒的高效郵件通知服務。</p><h2 id="步驟一：整合-Spring-Boot-Mail"><a href="#步驟一：整合-Spring-Boot-Mail" class="headerlink" title="步驟一：整合 Spring Boot Mail"></a>步驟一：整合 Spring Boot Mail</h2><ol><li><p><strong>加入 Maven 相依性</strong><br>打開 <code>pom.xml</code> 檔案，在 <code>&lt;dependencies&gt;</code> 區塊中，加入 Spring Boot Mail 的起步依賴：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>設定 SMTP 伺服器</strong><br>要寄送郵件，我們的應用程式需要知道該透過哪個郵件伺服器（SMTP Server）來發送。</p><blockquote><p><strong>開發階段強烈推薦</strong>：使用像 <a href="https://mailtrap.io/"><strong>Mailtrap.io</strong></a> 這樣的郵件測試服務。它提供一個「假的」SMTP 伺服器，所有您寄送的郵件都會被它攔截並顯示在一個虛擬的收件匣中，而不會真的寄送到真實的電子信箱。這可以避免您在開發過程中不小心寄出垃圾郵件，也無需去申請或設定真實的 SMTP 服務。</p></blockquote><p>打開 <code>src/main/resources/application.yml</code>，加入以下郵件相關的設定（請替換為您自己的 SMTP 伺服器資訊，此處以 Mailtrap 為例）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">sandbox.smtp.mailtrap.io</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">2525</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">your-mailtrap-username</span> <span class="comment"># 替換成您的 Mailtrap 使用者名稱</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your-mailtrap-password</span> <span class="comment"># 替換成您的 Mailtrap 密碼</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">smtp:</span></span><br><span class="line">          <span class="attr">auth:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">starttls:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="步驟二：實作郵件寄送服務"><a href="#步驟二：實作郵件寄送服務" class="headerlink" title="步驟二：實作郵件寄送服務"></a>步驟二：實作郵件寄送服務</h2><p>現在，我們來修改上一篇文章建立的 <code>NotificationService</code>，讓它具備真正的郵件寄送能力。Spring Boot 會在偵測到郵件相關設定後，自動在 IoC 容器中為我們準備好一個 <code>JavaMailSender</code> 的 Bean，我們只需要注入它即可。</p><p>修改 <code>com.example.demoapp.service.NotificationService.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.mail.MessagingException;</span><br><span class="line"><span class="keyword">import</span> jakarta.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.SimpleMailMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.JavaMailSender;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.MimeMessageHelper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendWelcomeEmail</span><span class="params">(String to, String username)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;開始寄送純文字歡迎郵件給 &#123;&#125;...&quot;</span>, username);</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">        message.setFrom(<span class="string">&quot;no-reply@demoapp.com&quot;</span>); <span class="comment">// 您的寄件人信箱</span></span><br><span class="line">        message.setTo(to);</span><br><span class="line">        message.setSubject(<span class="string">&quot;歡迎加入我們的平台！&quot;</span>);</span><br><span class="line">        message.setText(<span class="string">&quot;親愛的 &quot;</span> + username + <span class="string">&quot;,\n\n歡迎您！感謝您的註冊。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mailSender.send(message);</span><br><span class="line">        log.info(<span class="string">&quot;純文字歡迎郵件已成功寄送給 &#123;&#125;!&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendWelcomeHtmlEmail</span><span class="params">(String to, String username)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;開始寄送 HTML 歡迎郵件給 &#123;&#125;...&quot;</span>, username);</span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 MimeMessageHelper 來輔助建立複雜的郵件</span></span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            helper.setFrom(<span class="string">&quot;no-reply@demoapp.com&quot;</span>);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(<span class="string">&quot;🎉 歡迎加入我們的平台！(HTML)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 準備 HTML 內容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">htmlContent</span> <span class="operator">=</span> <span class="string">&quot;&lt;h1&gt;親愛的 &quot;</span> + username + <span class="string">&quot;,&lt;/h1&gt;&quot;</span></span><br><span class="line">                               + <span class="string">&quot;&lt;p&gt;這是一封 &lt;strong&gt;HTML&lt;/strong&gt; 格式的歡迎郵件。&lt;/p&gt;&quot;</span></span><br><span class="line">                               + <span class="string">&quot;&lt;p style=&#x27;color:blue;&#x27;&gt;感謝您的註冊！&lt;/p&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            helper.setText(htmlContent, <span class="literal">true</span>); <span class="comment">// true 表示這是一封 HTML 郵件</span></span><br><span class="line">            mailSender.send(mimeMessage);</span><br><span class="line">            log.info(<span class="string">&quot;HTML 歡迎郵件已成功寄送給 &#123;&#125;!&quot;</span>, username);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;寄送 HTML 郵件失敗: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ul><li><strong>寄送純文字郵件</strong>：使用 <code>SimpleMailMessage</code> 物件，設定好寄件人、收件人、主旨和內容後，直接呼叫 <code>mailSender.send()</code> 即可，非常簡單。</li><li><strong>寄送 HTML 郵件</strong>：對於包含樣式、圖片等豐富格式的郵件，需要使用 <code>MimeMessage</code>。Spring 提供了 <code>MimeMessageHelper</code> 這個輔助類別，讓我們可以輕鬆地設定 HTML 內容（注意 <code>setText</code> 的第二個參數 <code>true</code>）以及處理附件（未來可以擴充）。</li></ul></li></ul><h2 id="步驟三：觸發郵件寄送"><a href="#步驟三：觸發郵件寄送" class="headerlink" title="步驟三：觸發郵件寄送"></a>步驟三：觸發郵件寄送</h2><p>讓我們在 <code>UserService</code> 中，當使用者建立成功後，呼叫寄送 HTML 郵件的方法。</p><p>修改 <code>UserService.java</code> 的 <code>createUser</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in UserService.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(CreateUserRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// ... 原有的建立使用者邏輯 ...</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">// ... 設定 user 屬性 ...</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userRepository.save(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 呼叫非同步方法寄送 HTML 郵件</span></span><br><span class="line">    notificationService.sendWelcomeHtmlEmail(savedUser.getEmail(), savedUser.getUsername());</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;createUser 方法已執行完畢，立即回傳。&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> savedUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步驟四：測試郵件寄送"><a href="#步驟四：測試郵件寄送" class="headerlink" title="步驟四：測試郵件寄送"></a>步驟四：測試郵件寄送</h2><ol><li><strong>啟動應用程式</strong>。</li><li><strong>打開您的 Mailtrap 收件匣</strong>。</li><li>使用 Postman 等工具，發送一個 <code>POST /users</code> 請求來建立新使用者。請確保請求本文中的 <code>email</code> 欄位有值。</li><li><strong>觀察結果</strong>：<ul><li>API 的回應幾乎是<strong>即時</strong>的，這證明了 <code>@Async</code> 仍在正常工作。</li><li>稍等片刻，您應該會在 Mailtrap 的收件匣中，看到一封新郵件。點開它，您將會看到經過 HTML 渲染後的漂亮內容。</li></ul></li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們成功地為應用程式整合了一項極其實用的功能。</p><ul><li>我們加入了 <code>spring-boot-starter-mail</code> 相依性。</li><li>我們學會了如何設定 SMTP 伺服器，並推薦了在開發階段使用 <strong>Mailtrap</strong> 的最佳實踐。</li><li>我們掌握了使用 <code>JavaMailSender</code> 來寄送<strong>純文字</strong>與 <strong>HTML</strong> 兩種格式的郵件。</li><li>我們將郵件寄送與 <strong><code>@Async</code></strong> 完美結合，確保了即使郵件服務緩慢，也不會影響我們 API 的主要效能。</li></ul><p>我們已經掌握了寄送郵件這項實用的功能。在下一篇文章中，我們將探討另一個在 Web 開發中極為常見的需求——<strong>檔案上傳與下載</strong>，學習如何處理來自客戶端的檔案並提供檔案下載功能。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 26 - 非同步 (@Async) 與排程 (@Scheduled) 任務</title>
      <link href="/2025/08/13/java-spring-boot-26/"/>
      <url>/2025/08/13/java-spring-boot-26/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：解放您的主執行緒"><a href="#前言：解放您的主執行緒" class="headerlink" title="前言：解放您的主執行緒"></a>前言：解放您的主執行緒</h2><p>在開發應用程式時，我們經常會遇到兩類特殊的任務場景：</p><ol><li><p><strong>耗時的背景任務</strong>：想像一下，當一個使用者註冊成功後，我們需要寄送一封歡迎郵件。如果寄送郵件的過程需要 5 秒鐘，那麼我們的註冊 API 就必須等待這 5 秒結束後，才能回傳成功訊息給使用者。這會導致 API 回應緩慢，嚴重影響使用者體驗。</p></li><li><p><strong>週期性的自動化任務</strong>：我們可能需要在每天凌晨定時產生統計報表，或者每小時清理一次過期的暫存檔案。</p></li></ol><p>對於這些場景，Spring Boot 提供了兩個強大而簡潔的註解來優雅地解決：<code>@Async</code> 用於非同步執行，<code>@Scheduled</code> 用於任務排程。本篇文章將帶您掌握這兩個重要的生產力工具。</p><h2 id="非同步任務-Async"><a href="#非同步任務-Async" class="headerlink" title="非同步任務 (@Async)"></a>非同步任務 (<code>@Async</code>)</h2><p><code>@Async</code> 註解能讓一個方法在<strong>獨立的背景執行緒</strong>中執行，而呼叫它的主執行緒則可以立即返回，無需等待該方法執行完畢。這對於優化那些包含耗時操作（如 I&#x2F;O、網路請求）的 API 回應時間非常有效。</p><h3 id="步驟一：啟用非同步功能"><a href="#步驟一：啟用非同步功能" class="headerlink" title="步驟一：啟用非同步功能"></a>步驟一：啟用非同步功能</h3><p>要使用 <code>@Async</code>，必須先在您的應用程式中明確地啟用它。</p><p>打開主應用程式類別 <code>DemoAppApplication.java</code>，並在上方加入 <code>@EnableAsync</code> 註解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">// &lt;&lt;-- 啟用 Spring 的非同步方法執行功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoAppApplication</span> &#123;</span><br><span class="line">    <span class="comment">// ... main 方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步驟二：建立一個非同步服務"><a href="#步驟二：建立一個非同步服務" class="headerlink" title="步驟二：建立一個非同步服務"></a>步驟二：建立一個非同步服務</h3><p>讓我們建立一個模擬寄送郵件的服務。</p><p>在 <code>com.example.demoapp.service</code> 套件下，建立新檔案 <code>NotificationService.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">// 1. 將這個方法標示為非同步執行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendWelcomeEmail</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;[非同步任務] - 開始寄送歡迎郵件給 &#123;&#125;...&quot;</span>, username);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 模擬一個耗時 5 秒的網路操作</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;[非同步任務] - 歡迎郵件已成功寄送給 &#123;&#125;!&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<code>@Async</code> 註解告訴 Spring，當這個方法被呼叫時，請從內部的執行緒池中取出一個執行緒來執行它，不要阻塞當前的呼叫者。</li></ul><h3 id="步驟三：呼叫非同步方法"><a href="#步驟三：呼叫非同步方法" class="headerlink" title="步驟三：呼叫非同步方法"></a>步驟三：呼叫非同步方法</h3><p>現在，我們在 <code>UserService</code> 建立使用者的邏輯中，呼叫這個非同步方法。</p><p>修改 <code>UserService.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NotificationService notificationService; <span class="comment">// 注入 NotificationService</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(CreateUserRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 原有的建立使用者邏輯 ...</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userRepository.save(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 呼叫非同步方法，這個呼叫會立即返回</span></span><br><span class="line">        notificationService.sendWelcomeEmail(savedUser.getUsername());</span><br><span class="line">        </span><br><span class="line">        log.info(<span class="string">&quot;createUser 方法已執行完畢，立即回傳。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> savedUser;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="測試效果"><a href="#測試效果" class="headerlink" title="測試效果"></a>測試效果</h3><ol><li>啟動應用程式。</li><li>使用 Postman 等工具發送 <code>POST /users</code> 請求。</li><li><strong>觀察結果</strong>：您會發現 API 的回應幾乎是<strong>瞬間</strong>完成的，Postman 馬上就收到了成功訊息。與此同時，觀察主控台的日誌，您會先看到 <code>&quot;createUser 方法已執行完畢...&quot;</code>，然後才看到 <code>&quot;[非同步任務] - 開始寄送...&quot;</code>，接著等待 5 秒後，才會看到 <code>&quot;[非同步任務] - ...已成功寄送!&quot;</code>。這完美地證明了郵件寄送的任務是在背景執行的，完全沒有阻塞 API 的回應。</li></ol><h2 id="排程任務-Scheduled"><a href="#排程任務-Scheduled" class="headerlink" title="排程任務 (@Scheduled)"></a>排程任務 (<code>@Scheduled</code>)</h2><p><code>@Scheduled</code> 註解可以讓一個方法在指定的時間或間隔被自動執行，非常適合處理週期性的維護或報告任務。</p><h3 id="步驟一：啟用排程功能"><a href="#步驟一：啟用排程功能" class="headerlink" title="步驟一：啟用排程功能"></a>步驟一：啟用排程功能</h3><p>與 <code>@Async</code> 類似，我們也需要在主應用程式類別上啟用排程功能。</p><p>修改 <code>DemoAppApplication.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// &lt;&lt;-- 啟用 Spring 的排程任務功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoAppApplication</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="步驟二：建立一個排程任務元件"><a href="#步驟二：建立一個排程任務元件" class="headerlink" title="步驟二：建立一個排程任務元件"></a>步驟二：建立一個排程任務元件</h3><ol><li><p>在 <code>com.example.demoapp</code> 下建立新套件 <code>scheduler</code>。</p></li><li><p>在 <code>scheduler</code> 套件中，建立新檔案 <code>ReportScheduler.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.scheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReportScheduler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. fixedRate: 從上次任務「開始」時計算，每隔 10 秒執行一次</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 10000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateReportPer10Seconds</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;fixedRate 排程：正在產生報表... &#123;&#125;&quot;</span>, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. fixedDelay: 從上次任務「結束」後，延遲 15 秒再執行下一次</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 15000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanUpTemporaryFiles</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;fixedDelay 排程：正在清理暫存檔... &#123;&#125;&quot;</span>, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. cron: 使用 Cron 表達式，在每天凌晨 1 點整執行</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runDailyMidnightTask</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Cron 排程：執行每日午夜任務...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li><strong>註解詳解</strong>：<ul><li><code>fixedRate</code>: 以固定的頻率執行。如果任務執行時間超過頻率間隔，下一個任務會在當前任務結束後立即開始。</li><li><code>fixedDelay</code>: 保證兩次任務執行之間至少有指定的延遲時間。</li><li><code>cron</code>: 功能最強大，使用標準的 Cron 表達式來定義複雜的排程計畫（格式為：秒 分 時 日 月 週）。</li></ul></li></ul><h3 id="測試效果-1"><a href="#測試效果-1" class="headerlink" title="測試效果"></a>測試效果</h3><p>啟動應用程式後，您無需做任何操作。直接觀察主控台日誌，您會看到 <code>fixedRate</code> 和 <code>fixedDelay</code> 的日誌會按照我們設定的間隔自動地被印出來。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們掌握了 Spring Boot 中處理背景與自動化任務的兩大利器：</p><ul><li>我們學會了使用 <strong><code>@Async</code></strong> 和 <strong><code>@EnableAsync</code></strong> 來將耗時操作非同步化，從而顯著提升 API 的回應速度。</li><li>我們學會了使用 <strong><code>@Scheduled</code></strong> 和 **<code>@EnableScheduling</code>**，透過 <code>fixedRate</code>, <code>fixedDelay</code>, 和 <code>cron</code> 等方式，來建立靈活的自動化排程任務。</li></ul><p>這兩項功能是建構高效能、高自動化現代應用程式的必備技能。</p><p>我們已經為應用程式加入了背景處理和自動化任務的能力。在下一篇文章中，我們將探討另一個常見的實用功能——<strong>使用 Spring Mail 寄送電子郵件</strong>，這將與我們的 <code>@Async</code> 知識完美結合。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 25 - AOP 切面導向程式設計</title>
      <link href="/2025/08/13/java-spring-boot-25/"/>
      <url>/2025/08/13/java-spring-boot-25/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：當程式碼充滿重複的「雜訊」"><a href="#前言：當程式碼充滿重複的「雜訊」" class="headerlink" title="前言：當程式碼充滿重複的「雜訊」"></a>前言：當程式碼充滿重複的「雜訊」</h2><p>想像一下，隨著我們的應用程式越來越複雜，我們可能會有一個新的需求：需要記錄所有 <code>Service</code> 層中重要方法的執行時間，以便進行效能監控。</p><p>如果不懂 AOP，我們可能會這樣做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(CreateUserRequest request)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;Executing createUser...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 核心業務邏輯 ---</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userRepository.save(user);</span><br><span class="line">        <span class="comment">// -------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;createUser executed in &#123;&#125; ms&quot;</span>, (endTime - startTime));</span><br><span class="line">        <span class="keyword">return</span> savedUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很快，我們就會發現這種做法是一場災難。日誌記錄、效能監控這些程式碼，與核心的業務邏輯（建立使用者）混雜在一起，嚴重違反了「單一職責原則」。這些非業務核心，但又普遍存在於多個模組中的功能（如日誌、交易、安全驗證），我們稱之為「**橫切性關注點 (Cross-Cutting Concerns)**」。</p><p><strong>AOP (Aspect-Oriented Programming, 切面導向程式設計)</strong> 正是為了解決這個問題而誕生的。它允許我們將這些「橫切性關注點」模組化，然後以一種聲明式的方式，將它們「織入 (Weave)」到我們需要的地方，而完全不侵入原始的業務邏輯程式碼。</p><h2 id="AOP-核心術語"><a href="#AOP-核心術語" class="headerlink" title="AOP 核心術語"></a>AOP 核心術語</h2><p>在開始實作前，我們先快速了解幾個 AOP 的核心術語：</p><ul><li>**切面 (Aspect)**：一個封裝了特定橫切性關注點的模組。例如，一個「日誌切面」或一個「交易管理切面」。</li><li><strong>連接點 (Join Point)<strong>：程式執行過程中的一個特定點，例如方法的執行、例外的拋出。在 Spring AOP 中，連接點總是</strong>方法的執行</strong>。</li><li><strong>通知 (Advice)<strong>：切面在特定連接點上所執行的</strong>具體動作</strong>。Spring 提供了五種通知類型：<ul><li><code>@Before</code>：在目標方法執行前執行。</li><li><code>@After</code>：在目標方法執行後執行（無論成功或失敗）。</li><li><code>@AfterReturning</code>：在目標方法成功執行後執行。</li><li><code>@AfterThrowing</code>：在目標方法拋出例外後執行。</li><li><code>@Around</code>：<strong>環繞通知</strong>，功能最強大，可以在目標方法執行前後都加入自訂邏輯。</li></ul></li><li><strong>切入點 (Pointcut)<strong>：一個</strong>表達式</strong>，用於篩選出符合條件的連接點。它精準地定義了通知應該被應用在「哪些」方法上。</li><li><strong>織入 (Weaving)<strong>：將切面應用到目標物件，並建立一個新的代理 (Proxy) 物件的過程。Spring AOP 在</strong>執行階段 (Runtime)</strong> 進行織入。</li></ul><h2 id="步驟一：整合-Spring-AOP"><a href="#步驟一：整合-Spring-AOP" class="headerlink" title="步驟一：整合 Spring AOP"></a>步驟一：整合 Spring AOP</h2><p>首先，我們需要加入 Spring AOP 的起步依賴。</p><p>打開 <code>pom.xml</code>，加入以下依賴：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="步驟二：建立您的第一個日誌切面"><a href="#步驟二：建立您的第一個日誌切面" class="headerlink" title="步驟二：建立您的第一個日誌切面"></a>步驟二：建立您的第一個日誌切面</h2><p>現在，讓我們來建立一個日誌切面，來實現我們在開頭提到的「記錄方法執行時間」的需求。</p><ol><li><p>在 <code>com.example.demoapp</code> 下建立新套件 <code>aspect</code>。</p></li><li><p>在 <code>aspect</code> 套件中，建立新檔案 <code>LoggingAspect.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span>      <span class="comment">// 1. 使用 Lombok 進行日誌記錄</span></span><br><span class="line"><span class="meta">@Aspect</span>     <span class="comment">// 2. 宣告這個類別是一個切面</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">// 3. 將這個切面交給 Spring IoC 容器管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 定義一個切入點，匹配 service 套件下的所有 public 方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.example.demoapp.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceLogPointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 定義環繞通知 (Around Advice)，並應用到上面定義的切入點</span></span><br><span class="line">    <span class="meta">@Around(&quot;serviceLogPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logServiceMethods</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法執行前的邏輯</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        log.info(<span class="string">&quot;==&gt; 進入方法: &#123;&#125;()，參數: &#123;&#125;&quot;</span>, methodName, Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 執行原始的目標方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">executionTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法執行後的邏輯</span></span><br><span class="line">        log.info(<span class="string">&quot;&lt;== 離開方法: &#123;&#125;()，回傳值: &#123;&#125;&quot;</span>, methodName, result);</span><br><span class="line">        log.info(<span class="string">&quot;    方法 &#123;&#125;() 執行時間: &#123;&#125; ms&quot;</span>, methodName, executionTime);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li><strong>程式碼詳解</strong>：<ol><li><code>@Aspect</code>：將一個 Java 類別定義為切面。</li><li><code>@Component</code>：切面本身也需要被 Spring 容器管理，才能去偵測並代理其他的 Bean。</li><li><code>@Pointcut</code>：定義了一個可重用的切入點表達式。<code>execution(...)</code> 是最常用的切入點指示符，這段表達式的意思是：「匹配 <code>com.example.demoapp.service</code> 套件下，任何類別的、任何名稱的、任何參數的 <code>public</code> 方法」。</li><li><code>@Around</code>：定義了一個環繞通知。這是最強大的通知類型，它能完全控制目標方法的執行。</li><li><code>ProceedingJoinPoint</code>：<code>@Around</code> 通知的特殊參數，它代表了被攔截的目標方法。</li><li><code>joinPoint.proceed()</code>：<strong>這是環繞通知的核心</strong>。呼叫此方法，才會真正地去執行原始的業務邏輯（例如 <code>userService.createUser()</code>）。您可以在呼叫它之前和之後，加入您自己的橫切邏輯。</li></ol></li></ul><h2 id="步驟三：觀察-AOP-的執行效果"><a href="#步驟三：觀察-AOP-的執行效果" class="headerlink" title="步驟三：觀察 AOP 的執行效果"></a>步驟三：觀察 AOP 的執行效果</h2><p>最神奇的地方在於，我們<strong>完全不需要修改任何一行 <code>UserService</code> 的程式碼</strong>！</p><ol><li><strong>啟動應用程式</strong>。</li><li>使用 Postman 等工具，呼叫任何一個會觸發 <code>UserService</code> 方法的 API，例如 <code>POST /users</code> 來建立一個新使用者。</li><li><strong>觀察主控台日誌</strong>。</li></ol><p>您將會看到類似以下的輸出，我們的日誌邏輯已經完美地「包裹」住了原始的業務邏輯：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">==&gt; 進入方法: createUser()，參數: [CreateUserRequest(username=newuser, email=new@example.com, age=28)]</span><br><span class="line">Saving user &#x27;newuser&#x27; to database.  // 這是 UserService 內部原有的日誌</span><br><span class="line">&lt;== 離開方法: createUser()，回傳值: User(id=1, username=newuser, ...)</span><br><span class="line">    方法 createUser() 執行時間: 15 ms</span><br></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們一起探索了 Spring AOP 的強大威力。</p><ul><li>我們理解了 AOP 的核心思想，是將<strong>橫切性關注點</strong>（如日誌、交易）與<strong>核心業務邏輯</strong>分離。</li><li>我們學習了 AOP 的核心術語，如<strong>切面 (Aspect)<strong>、</strong>通知 (Advice)</strong> 和**切入點 (Pointcut)**。</li><li>我們親手建立了一個日誌切面，在<strong>不修改任何業務程式碼</strong>的前提下，為 Service 層的所有方法加上了效能監控。</li></ul><p>事實上，我們之前學過的 <code>@Transactional</code> 就是 Spring AOP 的一個經典應用。掌握 AOP，能讓您寫出結構更清晰、耦合度更低、更易於維護的應用程式。</p><p>我們已經學會了如何使用 AOP 來優雅地處理橫切性關注點。在下一篇文章中，我們將繼續探討生產力相關的主題，學習如何設定<strong>非同步任務與排程任務</strong>，讓我們的應用程式能夠處理耗時的背景工作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 24 - 整合 JWT 實現無狀態驗證</title>
      <link href="/2025/08/13/java-spring-boot-24/"/>
      <url>/2025/08/13/java-spring-boot-24/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：為何需要無狀態驗證？"><a href="#前言：為何需要無狀態驗證？" class="headerlink" title="前言：為何需要無狀態驗證？"></a>前言：為何需要無狀態驗證？</h2><p>在上一篇文章中，我們實現了基於資料庫的身分驗證。但 Spring Security 預設的 HTTP Basic 和表單登入機制，是**有狀態的 (Stateful)**。這意味著在使用者登入成功後，伺服器會建立一個 Session 來儲存使用者的登入狀態。</p><p>這種傳統方式對於現代化的架構（如微服務、前後端分離的單頁應用 SPA、手機 App）來說，存在一些挑戰：</p><ul><li><strong>擴展性問題</strong>：如果伺服器有多台實例，需要額外的機制來同步 Session 狀態。</li><li><strong>耦合性高</strong>：客戶端與特定的伺服器 Session 綁定。</li></ul><p>為此，<strong>無狀態驗證 (Stateless Authentication)</strong> 應運而生。其核心思想是，<strong>伺服器不保存任何關於使用者登入狀態的資訊</strong>。每一次來自客戶端的請求，都必須包含所有足以讓伺服器驗證其身分的資訊。<strong>JWT (JSON Web Token)</strong> 正是實現此目標的業界標準。</p><p>本篇文章將帶您從零開始，為我們的應用程式整合一套完整的 JWT 驗證流程。</p><h2 id="什麼是-JWT-JSON-Web-Token-？"><a href="#什麼是-JWT-JSON-Web-Token-？" class="headerlink" title="什麼是 JWT (JSON Web Token)？"></a>什麼是 JWT (JSON Web Token)？</h2><p>JWT 是一個開放標準 (RFC 7519)，它定義了一種緊湊且自包含 (self-contained) 的方式，用於在各方之間安全地傳遞資訊。它由三個部分組成，並用 <code>.</code> 分隔：</p><p><code>xxxxx.yyyyy.zzzzz</code> (Header.Payload.Signature)</p><ol><li>**標頭 (Header)**：包含令牌的類型（即 JWT）和所使用的簽名演算法（如 HMAC SHA256 或 RSA）。</li><li>**酬載 (Payload)**：包含「聲明 (Claims)」。聲明是關於實體（通常是使用者）和其他資料的陳述。常見的聲明有 <code>sub</code> (Subject，通常是使用者名稱)、<code>iat</code> (Issued At，發行時間)、<code>exp</code> (Expiration Time，過期時間)。</li><li><strong>簽章 (Signature)<strong>：</strong>這是確保令牌未被篡改的關鍵</strong>。它是由編碼後的標頭、編碼後的酬載，加上一個只有伺服器知道的**密鑰 (Secret Key)**，再透過標頭中指定的演算法進行加密生成的。</li></ol><p><strong>JWT 驗證流程</strong>：</p><ol><li>使用者使用帳號密碼登入。</li><li>伺服器驗證成功後，使用密鑰產生一個 JWT 並回傳給客戶端。</li><li>客戶端將收到的 JWT 儲存起來（例如在瀏覽器的 <code>localStorage</code> 中）。</li><li>對於後續的每一次請求，客戶端都需要在 HTTP 的 <code>Authorization</code> 標頭中，以 <code>Bearer &lt;token&gt;</code> 的形式附上這個 JWT。</li><li>伺服器收到請求後，從標頭中提取 JWT，並使用<strong>相同的密鑰</strong>來驗證簽章的有效性。如果驗證通過，就代表使用者已通過認證。</li></ol><h2 id="步驟一：加入-JWT-函式庫依賴"><a href="#步驟一：加入-JWT-函式庫依賴" class="headerlink" title="步驟一：加入 JWT 函式庫依賴"></a>步驟一：加入 JWT 函式庫依賴</h2><p>我們將使用 <code>jjwt</code> 這個流行的函式庫來處理 JWT 的產生與驗證。</p><p>打開 <code>pom.xml</code>，加入以下依賴：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="步驟二：建立-JWT-工具服務"><a href="#步驟二：建立-JWT-工具服務" class="headerlink" title="步驟二：建立 JWT 工具服務"></a>步驟二：建立 JWT 工具服務</h2><p>將所有 JWT 相關的邏輯封裝在一個獨立的 Service 中，是一種良好的實踐。</p><p>在 <code>com.example.demoapp.service</code> 套件下，建立新檔案 <code>JwtService.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.security.Keys;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 強固的密鑰。在生產環境中，應從安全的組態檔或環境變數讀取。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECRET_KEY</span> <span class="operator">=</span> <span class="string">&quot;a-very-long-and-secure-secret-key-for-jwt-demo-app-in-spring-series&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 產生 Token</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(UserDetails userDetails)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .subject(userDetails.getUsername())</span><br><span class="line">                .issuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()))</span><br><span class="line">                .expiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">10</span>)) <span class="comment">// 10 小時後過期</span></span><br><span class="line">                .signWith(getSigningKey())</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 驗證 Token</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTokenValid</span><span class="params">(String token, UserDetails userDetails)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> extractUsername(token);</span><br><span class="line">        <span class="keyword">return</span> (username.equals(userDetails.getUsername())) &amp;&amp; !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 從 Token 中提取使用者名稱</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">extractUsername</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> extractClaim(token, Claims::getSubject);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 檢查 Token 是否過期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isTokenExpired</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> extractExpiration(token).before(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date <span class="title function_">extractExpiration</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> extractClaim(token, Claims::getExpiration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取所有聲明</span></span><br><span class="line">    <span class="keyword">private</span> Claims <span class="title function_">extractAllClaims</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                .verifyWith(getSigningKey())</span><br><span class="line">                .build()</span><br><span class="line">                .parseSignedClaims(token)</span><br><span class="line">                .getPayload();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取單一聲明</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">extractClaim</span><span class="params">(String token, Function&lt;Claims, T&gt; claimsResolver)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> extractAllClaims(token);</span><br><span class="line">        <span class="keyword">return</span> claimsResolver.apply(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得簽章用的密鑰</span></span><br><span class="line">    <span class="keyword">private</span> SecretKey <span class="title function_">getSigningKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Keys.hmacShaKeyFor(SECRET_KEY.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步驟三：建立-JWT-認證過濾器"><a href="#步驟三：建立-JWT-認證過濾器" class="headerlink" title="步驟三：建立 JWT 認證過濾器"></a>步驟三：建立 JWT 認證過濾器</h2><p>這個過濾器 (Filter) 是實現 JWT 驗證的核心。它會在每一次請求進來時執行，檢查是否存在有效的 JWT，若有，則設定好 Spring Security 的上下文。</p><p>在 <code>com.example.demoapp</code> 下建立新套件 <code>filter</code>，並新增 <code>JwtAuthFilter.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.service.JwtService;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.NonNull;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.WebAuthenticationDetailsSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtService jwtService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> HttpServletRequest request,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> HttpServletResponse response,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">authHeader</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> String jwt;</span><br><span class="line">        <span class="keyword">final</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (authHeader == <span class="literal">null</span> || !authHeader.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jwt = authHeader.substring(<span class="number">7</span>);</span><br><span class="line">        username = jwtService.extractUsername(jwt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (username != <span class="literal">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> <span class="built_in">this</span>.userDetailsService.loadUserByUsername(username);</span><br><span class="line">            <span class="keyword">if</span> (jwtService.isTokenValid(jwt, userDetails)) &#123;</span><br><span class="line">                <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">                        userDetails,</span><br><span class="line">                        <span class="literal">null</span>,</span><br><span class="line">                        userDetails.getAuthorities()</span><br><span class="line">                );</span><br><span class="line">                authToken.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authToken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：這個過濾器繼承了 <code>OncePerRequestFilter</code>，確保每次請求只執行一次。它的邏輯是：<ol><li>從 <code>Authorization</code> 標頭中獲取 <code>Bearer</code> Token。</li><li>如果 Token 存在，就使用 <code>JwtService</code> 提取使用者名稱。</li><li>如果使用者名稱存在且當前 Security Context 中尚無認證資訊，就從 <code>UserDetailsService</code> 載入使用者資料。</li><li>驗證 Token 的有效性。</li><li>如果有效，就建立一個 <code>UsernamePasswordAuthenticationToken</code> 物件，並將其設定到 <code>SecurityContextHolder</code> 中。這一步等同於告知 Spring Security：「這位使用者已經通過認證了」。</li></ol></li></ul><h2 id="步驟四：更新安全組態"><a href="#步驟四：更新安全組態" class="headerlink" title="步驟四：更新安全組態"></a>步驟四：更新安全組態</h2><p>現在，我們需要修改 <code>SecurityConfig</code>，告訴 Spring Security 使用我們的 JWT 過濾器，並進入無狀態模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.filter.JwtAuthFilter;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.http.SessionCreationPolicy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.SecurityFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtAuthFilter jwtAuthFilter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationProvider authenticationProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .csrf(AbstractHttpConfigurer::disable) <span class="comment">// 1. 停用 CSRF</span></span><br><span class="line">                .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>, <span class="string">&quot;/swagger-ui/**&quot;</span>, <span class="string">&quot;/v3/api-docs/**&quot;</span>).permitAll() <span class="comment">// 2. 公開認證與 API 文件路徑</span></span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) <span class="comment">// 3. 設定 Session 為無狀態</span></span><br><span class="line">                .authenticationProvider(authenticationProvider) <span class="comment">// 4. 設定自訂的驗證提供者</span></span><br><span class="line">                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class); <span class="comment">// 5. 將 JWT 過濾器加到驗證鏈中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ol><li><strong>停用 CSRF</strong>：對於無狀態的 JWT 驗證，CSRF 防護是不必要的。</li><li><strong>公開認證路徑</strong>：我們需要一個公開的 API 端點（例如 <code>/api/auth/login</code>）讓使用者可以用帳號密碼來「換取」JWT。</li><li><strong>無狀態 Session</strong>：<code>SessionCreationPolicy.STATELESS</code> 是關鍵設定，它告訴 Spring Security 不要建立或使用任何 HTTP Session。</li><li><code>authenticationProvider</code>：我們需要一個 <code>AuthenticationProvider</code> Bean，它會使用我們的 <code>UserDetailsService</code> 和 <code>PasswordEncoder</code>。（此 Bean 的定義通常放在一個單獨的 <code>ApplicationConfig</code> 類別中，此處為簡化暫略）。</li><li><strong>加入過濾器</strong>：<code>addFilterBefore()</code> 將我們的 <code>JwtAuthFilter</code> 插入到 Spring Security 的過濾鏈中，並確保它在標準的帳號密碼驗證過濾器之前執行。</li></ol></li></ul><h2 id="步驟五：建立認證端點"><a href="#步驟五：建立認證端點" class="headerlink" title="步驟五：建立認證端點"></a>步驟五：建立認證端點</h2><p>最後，我們需要一個 API 來讓使用者登入並獲取 JWT。<br>(此步驟涉及建立 <code>AuthenticationController</code>, <code>AuthenticationService</code>, <code>AuthenticationManager</code> Bean 等，因篇幅所限，此處提供核心概念)</p><ul><li>建立一個公開的 <code>POST /api/auth/login</code> 端點。</li><li>接收使用者的帳號密碼。</li><li>使用 Spring Security 的 <code>AuthenticationManager</code> 來驗證憑證的正確性。</li><li>如果驗證成功，就使用 <code>JwtService</code> 為該使用者產生一個 JWT。</li><li>將產生的 JWT 作為回應回傳給客戶端。</li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們完成了一次重大的安全架構升級，從有狀態的 Session 驗證，遷移到了現代化的無狀態 JWT 驗證。</p><ul><li>我們理解了 <strong>JWT</strong> 的結構及其在無狀態驗證中的核心作用。</li><li>我們整合了 <code>jjwt</code> 函式庫，並建立了一個專門的 <code>JwtService</code> 來處理 Token 的生命週期。</li><li>我們實作了一個客製化的 <strong>JWT 認證過濾器</strong>，在每個請求中驗證 Token 的有效性。</li><li>我們更新了安全組態，使其進入<strong>無狀態模式</strong>，並將我們的過濾器整合進去。</li></ul><p>這套架構具有高度的擴展性與靈活性，是現今微服務與前後端分離應用程式的標準安全實踐。</p><p>我們已經為應用程式建立了一套非常強固的安全機制。在進入最後的「生產力與部署」階段之前，我們將探討一個讓程式碼更具擴充性的設計模式——<strong>AOP 切面導向程式設計</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 23 - 基於資料庫的使用者驗證</title>
      <link href="/2025/08/13/java-spring-boot-23/"/>
      <url>/2025/08/13/java-spring-boot-23/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：告別預設使用者"><a href="#前言：告別預設使用者" class="headerlink" title="前言：告別預設使用者"></a>前言：告別預設使用者</h2><p>在上一篇文章中，我們成功地使用 Spring Security 保護了我們的應用程式。但目前，我們依賴的是 Spring Boot 在記憶體中建立的、有著隨機密碼的預設使用者 <code>user</code>。這對於真實世界的應用程式是遠遠不夠的，我們需要一個能夠管理成千上萬使用者的、將使用者憑證安全地儲存在資料庫中的驗證系統。</p><p>本篇文章將帶您完成這個關鍵的改造。我們將把 Spring Security 與我們已經建立好的 <code>users</code> 資料庫表格連接起來。過程中，您將學習到 Spring Security 中三個核心的介面與元件：</p><ul><li><strong><code>PasswordEncoder</code></strong>: 用於安全地加密與比對密碼。</li><li><strong><code>UserDetails</code></strong>: 代表使用者安全資訊的標準介面。</li><li><strong><code>UserDetailsService</code></strong>: 負責從資料來源（如資料庫）讀取 <code>UserDetails</code> 的服務。</li></ul><h2 id="步驟一：密碼的儲存：PasswordEncoder"><a href="#步驟一：密碼的儲存：PasswordEncoder" class="headerlink" title="步驟一：密碼的儲存：PasswordEncoder"></a>步驟一：密碼的儲存：<code>PasswordEncoder</code></h2><p><strong>安全第一！</strong> 在任何情況下，我們都<strong>絕不能</strong>將使用者的密碼以明文形式儲存在資料庫中。所有密碼都必須經過<strong>雜湊 (Hashing)</strong> 處理。</p><p>Spring Security 提供了 <code>PasswordEncoder</code> 介面來標準化密碼的編碼與比對。目前業界推薦的標準是 <strong>BCrypt</strong>，它是一種加鹽的、強度很高的雜湊演算法。</p><p>我們需要做的，就是將 <code>BCryptPasswordEncoder</code> 的實例註冊為一個 Bean，以便在整個應用程式中重複使用。</p><p>打開 <code>config/SecurityConfig.java</code>，加入以下 <code>@Bean</code> 定義：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in SecurityConfig.java</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... securityFilterChain Bean ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步驟二：讓-User-實體符合安全規範-UserDetails"><a href="#步驟二：讓-User-實體符合安全規範-UserDetails" class="headerlink" title="步驟二：讓 User 實體符合安全規範 (UserDetails)"></a>步驟二：讓 <code>User</code> 實體符合安全規範 (<code>UserDetails</code>)</h2><p>Spring Security 並不知道我們 <code>User</code> Entity 的存在，但它認識一個名為 <code>UserDetails</code> 的標準介面。這個介面定義了一個使用者安全模型所需的核心方法，如獲取使用者名稱、密碼、權限等。</p><p>我們需要讓我們的 <code>User</code> 實體<strong>實作 (implements)</strong> 這個介面，成為 Spring Security 可以理解的物件。</p><ol><li><p>**修改 <code>entity/User.java</code>**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.persistence.*;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123; <span class="comment">// 1. 實作 UserDetails 介面</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... username, email, age 屬性 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 2. 新增 password 欄位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 以下是 UserDetails 介面的方法實作 ---</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="comment">// 3. 回傳使用者的權限集合，我們將在後續文章中實作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 為了簡單起見，我們先讓以下帳號狀態相關的方法都回傳 true</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>更新資料庫綱要</strong>：<br>由於我們在 <code>User</code> 實體中新增了 <code>password</code> 欄位，我們需要建立一個新的 Flyway 遷移腳本來更新資料庫。<br>在 <code>src/main/resources/db/migration</code> 目錄下，建立新檔案 <code>V3__Add_password_to_users_table.sql</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> password <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;temp&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>我們暫時給一個預設值以滿足 <code>NOT NULL</code> 約束。</p></blockquote></li></ol><h2 id="步驟三：建立-UserDetailsService"><a href="#步驟三：建立-UserDetailsService" class="headerlink" title="步驟三：建立 UserDetailsService"></a>步驟三：建立 <code>UserDetailsService</code></h2><p><code>UserDetailsService</code> 是連接 Spring Security 驗證邏輯與我們資料來源的<strong>橋樑</strong>。它只有一個核心方法 <code>loadUserByUsername(String username)</code>，其職責就是：根據傳入的使用者名稱，去資料庫中找到對應的使用者，並將其作為一個 <code>UserDetails</code> 物件回傳。</p><ol><li><p><strong>建立 Service 實作</strong><br>在 <code>com.example.demoapp.service</code> 套件下，建立新檔案 <code>UserDetailsServiceImpl.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span> <span class="comment">// 1. 將其標示為一個 Service Bean</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123; <span class="comment">// 2. 實作 UserDetailsService 介面</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 3. 實作唯一的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 4. 使用我們之前在 UserRepository 中定義的查詢方法</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.findByUsername(username)</span><br><span class="line">                .orElseThrow(() -&gt; </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;找不到使用者：&quot;</span> + username));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：當 Spring Security 需要驗證使用者時，它會呼叫這個 <code>loadUserByUsername</code> 方法。我們透過注入的 <code>UserRepository</code> 來查詢資料庫。如果找不到使用者，就拋出 <code>UsernameNotFoundException</code>，這是 Spring Security 規定的標準行為。</li></ul></li></ol><h2 id="步驟四：整合一切"><a href="#步驟四：整合一切" class="headerlink" title="步驟四：整合一切"></a>步驟四：整合一切</h2><p>我們已經準備好了 <code>PasswordEncoder</code>, <code>UserDetails</code> (我們的 <code>User</code> 實體), 和 <code>UserDetailsService</code> (我們的 <code>UserDetailsServiceImpl</code>)。接下來該如何將它們組裝起來？</p><p>好消息是：<strong>您什麼都不用做！</strong></p><p>這再次體現了 Spring Boot 的自動化設定威力。當 Spring Boot 啟動時，它會偵測到您的 IoC 容器中存在一個 <code>UserDetailsService</code> 的 Bean 和一個 <code>PasswordEncoder</code> 的 Bean，它會<strong>自動</strong>將這兩者配置到其驗證管理器 (AuthenticationManager) 中，取代掉預設的記憶體驗證。</p><h2 id="步驟五：測試資料庫驗證"><a href="#步驟五：測試資料庫驗證" class="headerlink" title="步驟五：測試資料庫驗證"></a>步驟五：測試資料庫驗證</h2><p>現在，我們需要一個真實存在於資料庫中的使用者來進行測試。</p><p>修改 <code>DemoAppApplication.java</code> 中的 <code>CommandLineRunner</code>，讓它在啟動時為我們建立一個帶有加密密碼的測試使用者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in DemoAppApplication.java</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoAppApplication</span> &#123;</span><br><span class="line">    <span class="comment">// ... main method ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommandLineRunner <span class="title function_">demo</span><span class="params">(UserRepository repository, PasswordEncoder passwordEncoder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (args) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 為了方便測試，先清空資料</span></span><br><span class="line">            repository.deleteAll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立一個有加密密碼的測試使用者</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">testUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            testUser.setUsername(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            testUser.setEmail(<span class="string">&quot;user@example.com&quot;</span>);</span><br><span class="line">            testUser.setAge(<span class="number">30</span>);</span><br><span class="line">            <span class="comment">// 使用我們定義的 PasswordEncoder Bean 來加密密碼</span></span><br><span class="line">            testUser.setPassword(passwordEncoder.encode(<span class="string">&quot;password&quot;</span>)); </span><br><span class="line">            repository.save(testUser);</span><br><span class="line">            System.out.println(<span class="string">&quot;\n--- 建立測試使用者: user / password ---&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>開始測試</strong>：</p><ol><li>重新啟動您的應用程式。Flyway 會執行 <code>V3</code> 腳本，<code>CommandLineRunner</code> 會建立我們的測試使用者。</li><li>使用 Postman 等工具，訪問任一受保護的 API，例如 <code>GET http://localhost:8080/users</code>。</li><li>在認證方式中選擇 <strong>Basic Auth</strong>。</li><li>輸入<strong>使用者名稱</strong>：<code>user</code>，<strong>密碼</strong>：<code>password</code>。</li><li>發送請求。</li></ol><p>請求成功！Spring Security 接收到明文密碼 <code>password</code>，使用 <code>BCryptPasswordEncoder</code> 將其加密，然後與資料庫中 <code>user</code> 對應的加密後密碼進行比對，比對成功後，認證通過。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們完成了一次巨大的升級，將應用程式的認證機制從記憶體提升到了資料庫。</p><ul><li>我們學會了使用 <code>PasswordEncoder</code> (特別是 <code>BCrypt</code>) 來安全地處理密碼。</li><li>我們透過實作 <code>UserDetails</code> 介面，讓我們的 <code>User</code> 實體能夠被 Spring Security 所理解。</li><li>我們建立了 <code>UserDetailsService</code> 作為橋樑，從 <code>UserRepository</code> 中讀取使用者資料。</li><li>我們體驗了 Spring Boot 如何自動地將這些元件組合起來，完成整個驗證流程。</li></ul><p>我們現在已經可以根據資料庫中的使用者進行身分驗證。接下來，我們需要更進一步，為 API 提供一種更現代化、更適合前後端分離架構的驗證方式——**JWT (JSON Web Token)**。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 22 - Spring Security 基礎與 Filter Chain</title>
      <link href="/2025/08/13/java-spring-boot-22/"/>
      <url>/2025/08/13/java-spring-boot-22/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：為您的-API-加上門鎖"><a href="#前言：為您的-API-加上門鎖" class="headerlink" title="前言：為您的 API 加上門鎖"></a>前言：為您的 API 加上門鎖</h2><p>到目前為止，我們建立的所有 API 端點都像是一座「不設防的城市」，任何人只要知道網址，就可以隨意地存取、新增或刪除使用者資料。這在真實世界的應用程式中是絕對無法接受的。</p><p>為了保護我們的應用程式，我們需要引入兩大核心安全概念：</p><ol><li>**認證 (Authentication)**：驗證「你是誰？」。系統需要確認使用者的身分，例如透過使用者名稱和密碼。</li><li>**授權 (Authorization)**：驗證「你能做什麼？」。確認了使用者身分後，系統需要判斷這個使用者是否擁有執行特定操作的權限。</li></ol><p><strong>Spring Security</strong> 是 Spring 生態系中，專門用來處理這兩大問題的官方框架。它功能強大、高度可客製化，是保護 Spring 應用程式的業界標準。雖然它以學習曲線陡峭聞名，但 Spring Boot 的自動化設定已經為我們鋪平了入門的道路。</p><p>本篇文章將帶您為專案整合 Spring Security，觀察它所帶來的預設安全行為，理解其背後核心的「過濾鏈 (Filter Chain)」機制，並最終建立我們的第一個客製化安全組態。</p><h2 id="步驟一：加入-Spring-Security-依賴與預設行為"><a href="#步驟一：加入-Spring-Security-依賴與預設行為" class="headerlink" title="步驟一：加入 Spring Security 依賴與預設行為"></a>步驟一：加入 Spring Security 依賴與預設行為</h2><ol><li><p><strong>加入 Maven 相依性</strong><br>打開 <code>pom.xml</code> 檔案，在 <code>&lt;dependencies&gt;</code> 區塊中，加入 Spring Security 的起步依賴：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重新啟動應用程式</strong><br><strong>不做任何其他程式碼修改</strong>，直接重新啟動您的 Spring Boot 應用。</p></li><li><p><strong>觀察變化</strong></p><ul><li><strong>主控台</strong>：您會在啟動日誌中發現多了一行類似這樣的訊息：<br><code>Using generated security password: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code></li><li><strong>API 測試</strong>：使用 Postman 或瀏覽器，再次嘗試訪問之前的任何 API，例如 <code>GET http://localhost:8080/users</code>。</li></ul></li></ol><p>您會發現，請求失敗了！如果您使用瀏覽器，會被重導到一個預設的登入頁面；如果您使用 Postman，會收到 <code>401 Unauthorized</code> 的回應。</p><p>這就是 Spring Security 的威力。僅僅是加入一個依賴，Spring Boot 的自動化設定就為我們完成了以下工作：</p><ul><li><strong>保護了所有 API 端點</strong>，預設要求所有請求都必須經過認證。</li><li>啟用<strong>表單登入 (Form Login)</strong> 與 <strong>HTTP Basic</strong> 兩種認證方式。</li><li>在記憶體中建立了一個預設使用者，其使用者名稱為 <code>user</code>，密碼則是每次啟動時隨機產生並印在主控台上的那一長串字元。</li></ul><h2 id="步驟二：核心機制：Servlet-過濾鏈-Filter-Chain"><a href="#步驟二：核心機制：Servlet-過濾鏈-Filter-Chain" class="headerlink" title="步驟二：核心機制：Servlet 過濾鏈 (Filter Chain)"></a>步驟二：核心機制：Servlet 過濾鏈 (Filter Chain)</h2><p>Spring Security 是如何攔截到所有請求的呢？答案是透過 **Servlet 過濾鏈 (Servlet Filter Chain)**。</p><p>您可以將其想像成一系列站在您應用程式門口的「保全人員 (Filter)」。每一個 HTTP 請求，在真正到達我們的 Controller 之前，都必須先依序通過這一排保全的檢查。</p><p>每一個「保全 (Filter)」都有其特定的職責：</p><ul><li><code>UsernamePasswordAuthenticationFilter</code>：負責處理使用者名稱和密碼的登入請求。</li><li><code>CsrfFilter</code>：負責防禦 CSRF 攻擊。</li><li><code>LogoutFilter</code>：負責處理登出請求。</li><li><code>AuthorizationFilter</code>：負責檢查使用者是否有權限訪問特定資源。</li><li>…還有很多其他的 Filter。</li></ul><p>這一整排保全所組成的隊伍，就是 <strong>Filter Chain</strong>。而我們接下來要做的「安全設定」，本質上就是在告訴 Spring Security：「我想要如何組織我的保全隊伍，以及每一位保全的執勤規則是什麼」。</p><h2 id="步驟三：建立第一個客製化安全設定"><a href="#步驟三：建立第一個客製化安全設定" class="headerlink" title="步驟三：建立第一個客製化安全設定"></a>步驟三：建立第一個客製化安全設定</h2><p>預設的行為雖然安全，但並不實用。我們需要定義自己的安全規則，例如，我們希望 API 文件 (Swagger UI) 是可以公開訪問的。</p><p>在 Spring Security 5.7 版之後，官方推薦使用「元件化」的方式來進行安全設定，也就是將 <code>SecurityFilterChain</code> 註冊為一個 Bean。</p><ol><li><p><strong>建立設定檔</strong><br>在 <code>com.example.demoapp.config</code> 套件下，建立新檔案 <code>SecurityConfig.java</code>。</p></li><li><p><strong>撰寫組態程式碼</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.SecurityFilterChain;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.config.Customizer.withDefaults;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 1. 標示為 Spring 的組態類別</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span> <span class="comment">// 2. 啟用 Spring Security 的 Web 安全性功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 3. 將 SecurityFilterChain 物件註冊為一個 Bean，交由 Spring 管理</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                <span class="comment">// 4. 對 /swagger-ui/** 和 /v3/api-docs/** 的請求，允許所有人 (permitAll) 訪問</span></span><br><span class="line">                .requestMatchers(<span class="string">&quot;/swagger-ui/**&quot;</span>, <span class="string">&quot;/v3/api-docs/**&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 5. 其他所有 (anyRequest) 的請求，都必須經過認證 (authenticated)</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .httpBasic(withDefaults()) <span class="comment">// 6. 啟用 HTTP Basic 認證</span></span><br><span class="line">            .formLogin(withDefaults()); <span class="comment">// 7. 啟用表單登入</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li><strong>程式碼詳解</strong>：<ol><li><code>@Configuration</code> &amp; <code>@EnableWebSecurity</code>：啟用 Spring 的 Java 組態功能與 Web 安全性。</li><li><code>@Bean public SecurityFilterChain ...</code>：我們定義了一個 <code>SecurityFilterChain</code> 型別的 Bean。Spring Security 會偵測到這個 Bean，並將其作為主要的安全性設定。</li><li><code>.authorizeHttpRequests(...)</code>：這是定義「授權」規則的地方。</li><li><code>.requestMatchers(...).permitAll()</code>：這是我們的第一條客製化規則。<code>requestMatchers</code> 用於匹配 HTTP 請求的路徑，<code>permitAll()</code> 表示允許所有使用者（無論是否登入）訪問。</li><li><code>.anyRequest().authenticated()</code>：這是一個「兜底」規則，表示<strong>任何其他</strong>未被前面規則匹配到的請求，都必須是已認證的狀態才能訪問。<strong>規則的順序非常重要</strong>，Spring Security 會由上到下依序匹配。</li><li><code>.httpBasic()</code> 和 <code>.formLogin()</code>：我們明確地啟用這兩種認證方式。<code>withDefaults()</code> 表示使用 Spring Security 提供的預設設定。</li></ol></li></ul><h2 id="步驟四：測試客製化設定"><a href="#步驟四：測試客製化設定" class="headerlink" title="步驟四：測試客製化設定"></a>步驟四：測試客製化設定</h2><ol><li>重新啟動您的應用程式。</li><li><strong>測試公開路徑</strong>：在瀏覽器中訪問 <code>http://localhost:8080/swagger-ui.html</code>。這次，您應該可以直接看到 API 文件頁面，而不會被要求登入。</li><li><strong>測試受保護路徑</strong>：在瀏覽器中訪問 <code>http://localhost:8080/users</code>。您仍然會被重導到登入頁面。</li></ol><p>這證明了我們的客製化規則已經生效！</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們成功地為應用程式加上了第一道安全防線。</p><ul><li>我們了解了僅僅加入 <code>spring-boot-starter-security</code> 依賴，就能立即保護我們的應用。</li><li>我們學習了 <strong>Servlet 過濾鏈 (Filter Chain)</strong> 是 Spring Security 運作的核心機制。</li><li>我們學會了使用現代化的元件化方式，建立一個 <strong><code>SecurityFilterChain</code> Bean</strong> 來客製化安全規則。</li><li>我們撰寫了第一條授權規則，將特定路徑公開，同時保護其他所有路徑。</li></ul><p>我們已經建立了基本的安全規則，但目前我們還在使用 Spring Boot 預設的 <code>user</code> 和隨機密碼。這在真實世界中是不可行的。在下一篇文章中，我們將學習如何捨棄預設使用者，並設定一個從<strong>資料庫中讀取使用者資訊</strong>的驗證機制。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 21 - 整合測試：MockMvc 與 Controller 層測試</title>
      <link href="/2025/08/13/java-spring-boot-21/"/>
      <url>/2025/08/13/java-spring-boot-21/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：為何單元測試還不夠？"><a href="#前言：為何單元測試還不夠？" class="headerlink" title="前言：為何單元測試還不夠？"></a>前言：為何單元測試還不夠？</h2><p>在上一篇文章中，我們學會了如何使用 Mockito 來為 <code>UserService</code> 撰寫單元測試。這確保了我們核心業務邏輯的正確性，但它並不能回答以下這些問題：</p><ul><li><code>UserController</code> 裡的 <code>@PostMapping(&quot;/users&quot;)</code> 註解是否設定正確？</li><li>當一個 HTTP 請求傳入時，其 JSON 本文是否能被成功地反序列化成我們的 <code>CreateUserRequest</code> DTO？</li><li>當 Controller 方法回傳一個 Java 物件時，它是否能被正確地序列化成 JSON 字串？</li><li>回應的 HTTP 狀態碼（如 200 OK, 404 Not Found）是否符合預期？</li></ul><p>這些問題都涉及到 Spring MVC 框架的多個元件（Controller、JSON 轉換器、請求映射等）如何<strong>協同工作</strong>。要驗證這些，我們需要進行**整合測試 (Integration Testing)**。</p><p>本篇文章將教您如何使用 Spring Boot 提供的強大測試工具 <code>MockMvc</code>，在<strong>不啟動完整 Web 伺服器</strong>的情況下，模擬真實的 HTTP 請求，並對 Controller 層的行為進行完整的端對端驗證。</p><h2 id="整合測試的核心工具：-WebMvcTest-與-MockMvc"><a href="#整合測試的核心工具：-WebMvcTest-與-MockMvc" class="headerlink" title="整合測試的核心工具：@WebMvcTest 與 MockMvc"></a>整合測試的核心工具：<code>@WebMvcTest</code> 與 <code>MockMvc</code></h2><ol><li><p><strong><code>@WebMvcTest</code></strong></p><ul><li>這是一個「**切片測試 (Slice Test)**」註解。當我們使用它時，Spring Boot 不會載入整個應用程式的上下文，而只會載入與 <strong>Web 層相關</strong>的元件，例如 <code>@Controller</code>, <code>@RestController</code>, <code>@ControllerAdvice</code>, <code>Filter</code>, <code>WebMvcConfigurer</code> 等。</li><li><strong>它不會載入</strong> <code>@Service</code> 或 <code>@Repository</code> 等業務邏輯和資料存取層的 Bean。這使得測試更輕量、啟動更快，且目標更集中。</li><li>因為它沒有載入真實的 <code>UserService</code>，所以我們必須為其提供一個<strong>模擬 (Mock) 的 Bean</strong>。</li></ul></li><li><p><strong><code>MockMvc</code></strong></p><ul><li>這是 Spring Test 框架提供的一個核心類別。它允許我們像使用 API 測試工具一樣，對我們的 Controller 發送模擬的 HTTP 請求。</li><li>我們可以用它來建構 <code>GET</code>, <code>POST</code> 等各種請求，設定標頭 (Header) 和本文 (Body)，然後對回應的狀態碼、標頭和本文內容進行精準的斷言。</li></ul></li></ol><h2 id="撰寫您的第一個-Controller-層測試"><a href="#撰寫您的第一個-Controller-層測試" class="headerlink" title="撰寫您的第一個 Controller 層測試"></a>撰寫您的第一個 Controller 層測試</h2><p>我們將為 <code>UserController</code> 撰寫一個測試，來驗證「建立使用者」這個 API 的功能。</p><ol><li><p><strong>建立測試檔案</strong><br>在 <code>src/test/java/com/example/demoapp</code> 下建立新套件 <code>controller</code>，並在其中建立新檔案 <code>UserControllerTest.java</code>。</p></li><li><p><strong>撰寫測試程式碼</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.dto.CreateUserRequest;</span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.MockBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.ArgumentMatchers.any;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.when;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebMvcTest(UserController.class)</span> <span class="comment">// 1. 告訴 Spring Boot 這是一個針對 UserController 的 Web MVC 測試</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 2. 由 Spring Test 自動注入配置好的 MockMvc</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span> <span class="comment">// 3. 建立一個 UserService 的 Mock Bean，它會替換掉 IoC 容器中真實的 UserService</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 4. 注入 Jackson 的 ObjectMapper，方便我們將物件轉換為 JSON 字串</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;當 POST /users 時，應成功建立使用者並回傳使用者資訊&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whenCreateUser_thenShouldReturnCreatedUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Arrange (準備)</span></span><br><span class="line">        <span class="comment">// 1. 準備請求的 DTO</span></span><br><span class="line">        <span class="type">CreateUserRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateUserRequest</span>();</span><br><span class="line">        request.setUsername(<span class="string">&quot;testuser&quot;</span>);</span><br><span class="line">        request.setEmail(<span class="string">&quot;test@example.com&quot;</span>);</span><br><span class="line">        request.setAge(<span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 準備當 Service 被呼叫時，預計要回傳的 Entity</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">createdUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;testuser&quot;</span>, <span class="string">&quot;test@example.com&quot;</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 設定 Mock Service 的行為</span></span><br><span class="line">        when(userService.createUser(any(CreateUserRequest.class))).thenReturn(createdUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act &amp; Assert (執行與驗證)</span></span><br><span class="line">        mockMvc.perform(post(<span class="string">&quot;/users&quot;</span>) <span class="comment">// 4. 模擬發送 POST 請求</span></span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON) <span class="comment">// 5. 設定請求的 Content-Type 為 JSON</span></span><br><span class="line">                .content(objectMapper.writeValueAsString(request))) <span class="comment">// 6. 將請求 DTO 物件轉換為 JSON 字串作為請求本文</span></span><br><span class="line">                .andExpect(status().isOk()) <span class="comment">// 7. 驗證回應的 HTTP 狀態碼為 200 (OK)</span></span><br><span class="line">                .andExpect(jsonPath(<span class="string">&quot;$.id&quot;</span>).value(<span class="number">1L</span>)) <span class="comment">// 8. 使用 JsonPath 驗證回應 JSON 的內容</span></span><br><span class="line">                .andExpect(jsonPath(<span class="string">&quot;$.username&quot;</span>).value(<span class="string">&quot;testuser&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li><strong>程式碼詳解</strong>：<ol><li><code>@WebMvcTest(UserController.class)</code>：我們明確指定只載入與 <code>UserController</code> 相關的 Web 層元件。</li><li><code>@Autowired private MockMvc mockMvc</code>：<code>MockMvc</code> 物件由測試框架自動設定並注入。</li><li><code>@MockBean private UserService userService</code>：<strong>這是一個關鍵註解</strong>。它告訴 Spring：「不要去載入真實的 <code>UserService</code>，請在應用程式上下文中放入一個由 Mockito 建立的 <code>UserService</code> 的 Mock 物件」。這樣，當 <code>UserController</code> 注入 <code>UserService</code> 時，它得到的就是這個 Mock 物件。</li><li><code>mockMvc.perform(...)</code>：這是執行模擬請求的入口。<code>post(&quot;/users&quot;)</code> 表示我們要建構一個對 <code>/users</code> 的 <code>POST</code> 請求。</li><li><code>.andExpect(...)</code>：這是進行斷言的地方。<code>status().isOk()</code> 用於驗證 HTTP 狀態碼，<code>jsonPath(...)</code> 則是一個強大的工具，讓我們可以使用類似 XPath 的語法來驗證 JSON 回應本文中的特定欄位值。<code>$</code> 代表 JSON 的根節點。</li></ol></li></ul><h2 id="測試-GET-請求與失敗場景"><a href="#測試-GET-請求與失敗場景" class="headerlink" title="測試 GET 請求與失敗場景"></a>測試 GET 請求與失敗場景</h2><p><code>MockMvc</code> 同樣能輕鬆測試其他 HTTP 方法以及錯誤處理流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in UserControllerTest.java</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;當 GET /users/&#123;id&#125; 且使用者不存在時，應回傳 404 Not Found&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenGetUserWithNonExistentId_thenShouldReturnNotFound</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="comment">// 設定當 service 被呼叫時，回傳一個空的 Optional</span></span><br><span class="line">    when(userService.getUserById(<span class="number">99L</span>)).thenReturn(Optional.empty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act &amp; Assert</span></span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, <span class="number">99L</span>)) <span class="comment">// 模擬發送 GET 請求，並傳入路徑變數</span></span><br><span class="line">            .andExpect(status().isNotFound()); <span class="comment">// 驗證 HTTP 狀態碼為 404</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個測試不僅驗證了 <code>GET</code> 請求的映射，同時也間接驗證了我們在 <code>GlobalExceptionHandler</code> 中定義的例外處理邏輯是否能被正確觸發，這正是整合測試的價值所在。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們成功地從單元測試邁向了整合測試。</p><ul><li>我們理解了<strong>單元測試</strong>與<strong>整合測試</strong>的區別與各自的用途。</li><li>我們掌握了如何使用 <code>@WebMvcTest</code> 來建立一個輕量級的、專注於 Web 層的測試環境。</li><li>我們學會了使用 <code>@MockBean</code> 來將業務邏輯層替換為 Mock 物件。</li><li>我們精通了使用 <strong><code>MockMvc</code></strong> 來模擬各種 HTTP 請求，並對回應的狀態碼和 JSON 內容進行精準的斷言。</li></ul><p>為 Controller 層撰寫整合測試，能確保我們的 API 在請求映射、資料綁定、序列化以及錯誤處理等環節都能正確無誤地協同工作，是保障 API 品質的最後一道防線。</p><p>我們已經為應用程式的核心業務邏輯與 Web 層都建立了自動化測試。在下一階段，我們將進入<strong>安全性專題</strong>，學習如何使用 Spring Security 來保護我們的 API 不被未經授權的訪問。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 20 - 單元測試：Mockito 與 Service 層測試</title>
      <link href="/2025/08/13/java-spring-boot-20/"/>
      <url>/2025/08/13/java-spring-boot-20/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：為何需要自動化測試？"><a href="#前言：為何需要自動化測試？" class="headerlink" title="前言：為何需要自動化測試？"></a>前言：為何需要自動化測試？</h2><p>到目前為止，我們都是透過 API 測試軟體（如 Postman）或瀏覽器來手動驗證我們的功能。在專案初期，這種方式尚可應付。但隨著業務邏輯變得越來越複雜，手動測試將會面臨巨大的挑戰：</p><ul><li><strong>效率低下</strong>：每次修改程式碼後，都需要手動重複執行大量的測試案例。</li><li><strong>容易遺漏</strong>：人為操作難免會遺漏某些邊界條件或異常場景的測試。</li><li><strong>缺乏信心</strong>：您無法放心地進行程式碼重構，因為擔心會不小心破壞現有功能。</li></ul><p>為了解決這些問題，我們必須引入<strong>自動化測試</strong>。<strong>單元測試 (Unit Testing)</strong> 是自動化測試金字塔的基石，它專注於驗證軟體中最小的可測試單元（通常是一個方法或一個類別）是否如預期般運作。</p><p>本篇文章將帶您為 <code>UserService</code> 撰寫我們的第一個單元測試。我們將學習如何使用 Spring Boot 內建的 <strong>JUnit 5</strong> 和 <strong>Mockito</strong> 框架，來獨立地、高效地測試我們的業務邏輯。</p><h2 id="測試環境與核心概念"><a href="#測試環境與核心概念" class="headerlink" title="測試環境與核心概念"></a>測試環境與核心概念</h2><p>得益於 <code>spring-boot-starter-test</code>，我們的專案已經預先整合了所有需要的測試工具：</p><ul><li><strong>JUnit 5</strong>：Java 世界中最主流的測試框架，提供了執行測試與撰寫斷言的基礎。</li><li><strong>Mockito</strong>：一個強大的<strong>模擬 (Mocking)</strong> 框架，這是單元測試的靈魂。</li><li><strong>AssertJ</strong>：一個提供流式斷言 API 的函式庫，讓您的驗證程式碼更具可讀性。</li></ul><p><strong>什麼是模擬 (Mocking)？</strong><br>這是單元測試中最核心的概念。當我們測試 <code>UserService</code> 時，我們只想專注於 <code>UserService</code> 內部自己的業務邏輯是否正確，而<strong>不希望</strong>它的測試結果受到其依賴（如 <code>UserRepository</code>）的影響。我們不希望為了測試 <code>UserService</code>，還需要啟動一個真實的資料庫。</p><p><strong>模擬</strong>，就是建立一個「假的」依賴物件（例如一個假的 <code>UserRepository</code>）。我們可以完全控制這個假物件的行為，例如，我們可以告訴它：「當 <code>findById(1L)</code> 方法被呼叫時，請回傳這個我預先準備好的假 User 物件」。如此一來，我們就能在完全隔離的環境下，精準地測試 <code>UserService</code> 的邏輯。</p><h2 id="撰寫您的第一個-Service-層測試"><a href="#撰寫您的第一個-Service-層測試" class="headerlink" title="撰寫您的第一個 Service 層測試"></a>撰寫您的第一個 Service 層測試</h2><p>依照 Maven 的標準慣例，<code>src/main/java</code> 下的類別，其對應的測試類別應該放在 <code>src/test/java</code> 下相同的套件路徑中。</p><ol><li><p><strong>建立測試檔案</strong><br>在 <code>src/test/java/com/example/demoapp/service</code> 路徑下，建立一個新檔案 <code>UserServiceTest.java</code>。</p></li><li><p><strong>撰寫測試程式碼</strong><br>貼上以下程式碼，這是一個測試 <code>getUserById</code> 方法成功情境的範例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.exception.ResourceNotFoundException;</span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.mockito.InjectMocks;</span><br><span class="line"><span class="keyword">import</span> org.mockito.Mock;</span><br><span class="line"><span class="keyword">import</span> org.mockito.junit.jupiter.MockitoExtension;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span> <span class="comment">// 1. 啟用 Mockito 擴充功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span> <span class="comment">// 2. 建立一個 UserRepository 的「假」物件 (Mock)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span> <span class="comment">// 3. 建立 UserService 的實例，並將上面 @Mock 標註的物件注入其中</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// 4. 標示這是一個 JUnit 5 的測試方法</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;當使用者 ID 存在時，應成功回傳使用者&quot;)</span> <span class="comment">// 5. 為測試提供一個更具可讀性的名稱</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whenUserExists_thenGetUserById_shouldReturnUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Arrange (安排/準備)</span></span><br><span class="line">        <span class="comment">// 6. 準備假資料，並「設定」Mock 物件的行為</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">mockUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;testuser&quot;</span>, <span class="string">&quot;test@example.com&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        when(userRepository.findById(<span class="number">1L</span>)).thenReturn(Optional.of(mockUser));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act (執行)</span></span><br><span class="line">        <span class="comment">// 7. 實際呼叫我們要測試的方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">foundUser</span> <span class="operator">=</span> userService.getUserById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert (斷言/驗證)</span></span><br><span class="line">        <span class="comment">// 8. 驗證方法的執行結果是否符合我們的預期</span></span><br><span class="line">        assertNotNull(foundUser);</span><br><span class="line">        assertEquals(<span class="string">&quot;testuser&quot;</span>, foundUser.getUsername());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 9. (選用) 驗證 userRepository 的 findById 方法是否真的被呼叫了 1 次</span></span><br><span class="line">        verify(userRepository, times(<span class="number">1</span>)).findById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li>**程式碼詳解 (AAA 模式)**：一個好的單元測試通常遵循 <strong>Arrange-Act-Assert</strong> 模式。<ol><li>**<code>@ExtendWith(MockitoExtension.class)</code>**：啟用 Mockito 框架。</li><li>**<code>@Mock</code>**：在此屬性上建立一個 Mock 物件。它是一個完全由 Mockito 控制的「傀儡」。</li><li><strong><code>@InjectMocks</code><strong>：建立 <code>UserService</code> 的一個真實實例，但 Mockito 會自動將所有被 <code>@Mock</code> 標註的屬性</strong>注入</strong>到這個實例中。</li><li><strong>Arrange (準備)<strong>：這是測試的準備階段。我們使用 Mockito 的 <code>when(...).thenReturn(...)</code> 語法來「排練」Mock 物件的行為。這行程式碼的意思是：「</strong>當</strong> <code>userRepository</code> 的 <code>findById(1L)</code> 方法被呼叫時，<strong>就回傳</strong>一個包含 <code>mockUser</code> 的 <code>Optional</code> 物件」。</li><li>**Act (執行)**：執行我們真正想要測試的業務邏輯。</li><li>**Assert (驗證)**：使用 JUnit 的 <code>assert...()</code> 方法來驗證執行的結果是否和我們預期的一樣。<code>verify()</code> 則是用來驗證 Mock 物件的某个方法是否被如預期般地呼叫過。</li></ol></li></ul><h2 id="測試拋出例外的場景"><a href="#測試拋出例外的場景" class="headerlink" title="測試拋出例外的場景"></a>測試拋出例外的場景</h2><p>測試程式的「失敗路徑」與「成功路徑」同等重要。</p><p>在 <code>UserServiceTest.java</code> 中，加入以下第二個測試方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in UserServiceTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;當使用者 ID 不存在時，應拋出 ResourceNotFoundException&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenUserDoesNotExist_thenGetUserById_shouldThrowException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="comment">// 這次，我們設定當 findById 被呼叫時，回傳一個空的 Optional</span></span><br><span class="line">    when(userRepository.findById(<span class="number">99L</span>)).thenReturn(Optional.empty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act &amp; Assert</span></span><br><span class="line">    <span class="comment">// 我們使用 assertThrows 來驗證，當執行特定程式碼時，是否會拋出預期的例外</span></span><br><span class="line">    assertThrows(ResourceNotFoundException.class, () -&gt; &#123;</span><br><span class="line">        userService.getUserById(<span class="number">99L</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 驗證 findById 仍然被呼叫了</span></span><br><span class="line">    verify(userRepository, times(<span class="number">1</span>)).findById(<span class="number">99L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>assertThrows()</code></strong> 是 JUnit 5 提供的專門用來測試例外情境的斷言。它斷定在執行其第二個參數（一個 Lambda 運算式）時，必須拋出第一個參數所指定的例外類型。</li></ul><h2 id="如何執行測試"><a href="#如何執行測試" class="headerlink" title="如何執行測試"></a>如何執行測試</h2><ul><li><p><strong>方法一（推薦）：使用 IDE</strong><br>VSCode 的 Java 擴充功能包會在測試方法的左側（行號旁）顯示一個播放按鈕。您可以點擊「<strong>Run Test</strong>」或「<strong>Debug Test</strong>」來單獨執行或偵錯這個測試方法。</p></li><li><p><strong>方法二：使用 Maven</strong><br>打開 VSCode 的整合式終端機，在專案根目錄下執行以下指令，Maven 將會自動執行專案中所有的測試：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們正式踏入了自動化測試的大門。</p><ul><li>我們理解了<strong>單元測試</strong>與<strong>模擬 (Mocking)</strong> 的核心理念。</li><li>我們學會了如何使用 <strong>JUnit 5</strong> 和 <strong>Mockito</strong> 來設定測試環境。</li><li>我們遵循 <strong>AAA (Arrange-Act-Assert)</strong> 模式，為 Service 層的成功與失敗場景撰寫了單元測試。</li></ul><p>為核心業務邏輯撰寫單元測試，是確保應用程式品質、提升開發信心、讓未來重構變得安全無虞的基石。</p><p>單元測試確保了我們最小業務單元的正確性，但它無法驗證各個元件組合在一起時是否能正常工作。在下一篇文章中，我們將學習<strong>整合測試</strong>，使用 MockMvc 來模擬 HTTP 請求，對我們的 Controller 進行完整的測試。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 19 - 全域例外處理 (@ControllerAdvice)</title>
      <link href="/2025/08/13/java-spring-boot-19/"/>
      <url>/2025/08/13/java-spring-boot-19/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：告別混亂的-try-catch"><a href="#前言：告別混亂的-try-catch" class="headerlink" title="前言：告別混亂的 try-catch"></a>前言：告別混亂的 <code>try-catch</code></h2><p>在我們的 <code>UserService</code> 中，當我們試圖查詢一個不存在的使用者時，程式會拋出一個 <code>RuntimeException</code>。如果我們現在去請求一個不存在的使用者 ID，會發生什麼事？Spring Boot 會回傳一個預設的、對使用者不友善的錯誤頁面或通用的 JSON 錯誤訊息，並在後台印出長長的堆疊追蹤 (Stack Trace)。</p><p>一個直覺的解決方法，可能是在 <code>UserController</code> 的每個方法中都加上 <code>try-catch</code> 區塊。但這種做法會讓您的 Controller 充滿重複的錯誤處理程式碼，不僅非常混亂，也違反了「單一職責原則」。Controller 的職責應該是接收請求與委派任務，而不是處理各種瑣碎的例外情況。</p><p>為此，Spring 提供了一個極其優雅的解決方案：**<code>@ControllerAdvice</code><strong>。它允許我們建立一個</strong>全域的例外處理器**，將錯誤處理的邏輯從業務邏輯中完全分離出來，並讓我們能夠向客戶端回傳標準化、有意義的錯誤回應。</p><h2 id="步驟一：建立一個客製化例外"><a href="#步驟一：建立一個客製化例外" class="headerlink" title="步驟一：建立一個客製化例外"></a>步驟一：建立一個客製化例外</h2><p>在處理錯誤時，定義一個能清晰表達業務場景的客製化例外，是一種良好的實踐。讓我們來建立一個「資源找不到」的例外。</p><ol><li><p>在 <code>com.example.demoapp</code> 下建立新套件 <code>exception</code>。</p></li><li><p>在 <code>exception</code> 套件中，建立新檔案 <code>ResourceNotFoundException.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 此註解會讓 Spring 在拋出此例外時，預設回傳 404 NOT_FOUND 狀態碼</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 建立一個建構子，讓我們可以傳入客製化的錯誤訊息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResourceNotFoundException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="步驟二：在-Service-層中拋出例外"><a href="#步驟二：在-Service-層中拋出例外" class="headerlink" title="步驟二：在 Service 層中拋出例外"></a>步驟二：在 Service 層中拋出例外</h2><p>現在，讓我們修改 <code>UserService</code>，當找不到使用者時，拋出我們剛剛建立的客製化例外。</p><p>修改 <code>com.example.demoapp.service.UserService.java</code> 中的 <code>getUserById</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in UserService.java</span></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.exception.ResourceNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123; <span class="comment">// 為了範例清晰，暫時將回傳值改為 User</span></span><br><span class="line">    <span class="keyword">return</span> userRepository.findById(id)</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">ResourceNotFoundException</span>(<span class="string">&quot;找不到 ID 為 &quot;</span> + id + <span class="string">&quot; 的使用者。&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>現在，我們的業務邏輯能夠拋出一個具有明確語義的例外了。</p><h2 id="步驟三：建立全域例外處理器"><a href="#步驟三：建立全域例外處理器" class="headerlink" title="步驟三：建立全域例外處理器"></a>步驟三：建立全域例外處理器</h2><p>這是本篇的核心。我們將建立一個類別，專門用來「攔截」從任何 Controller 拋出的例外，並進行統一處理。</p><ol><li><p>在 <code>com.example.demoapp</code> 下建立新套件 <code>handler</code>。</p></li><li><p>在 <code>handler</code> 套件中，建立新檔案 <code>GlobalExceptionHandler.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.exception.ResourceNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span> <span class="comment">// 1. 宣告這是一個全域的例外處理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 標示這個方法專門處理 ResourceNotFoundException</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 建立一個標準化的錯誤回應本文</span></span><br><span class="line">        Map&lt;String, Object&gt; body = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        body.put(<span class="string">&quot;timestamp&quot;</span>, LocalDateTime.now());</span><br><span class="line">        body.put(<span class="string">&quot;status&quot;</span>, HttpStatus.NOT_FOUND.value());</span><br><span class="line">        body.put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;Resource Not Found&quot;</span>);</span><br><span class="line">        body.put(<span class="string">&quot;message&quot;</span>, ex.getMessage());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 回傳帶有 HTTP 狀態碼 404 與錯誤本文的回應</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(body, HttpStatus.NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 處理所有其他未被捕獲的例外，作為一個兜底方案</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title function_">handleGlobalException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; body = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        body.put(<span class="string">&quot;timestamp&quot;</span>, LocalDateTime.now());</span><br><span class="line">        body.put(<span class="string">&quot;status&quot;</span>, HttpStatus.INTERNAL_SERVER_ERROR.value());</span><br><span class="line">        body.put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;Internal Server Error&quot;</span>);</span><br><span class="line">        body.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;發生非預期的錯誤：&quot;</span> + ex.getMessage());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(body, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li><strong>程式碼詳解</strong>：<ol><li><code>@ControllerAdvice</code>：此註解將一個類別標示為「控制器建議」。它是一個 AOP 的概念，允許我們將一些橫跨多個 Controller 的通用邏輯（如例外處理）集中到一個地方。</li><li><code>@ExceptionHandler(...)</code>：標示一個方法為「例外處理器」。括號中的 <code>ResourceNotFoundException.class</code> 指定了這個方法只會攔截特定類型的例外。</li><li><strong>標準化的錯誤回應</strong>：建立一個 <code>Map</code> 或 DTO 來定義一個固定的、對前端友善的錯誤回應格式，是一個非常好的實踐。</li><li><code>ResponseEntity</code>：這是 Spring 提供的一個強大類別，它允許我們完全控制 HTTP 回應，包括狀態碼 (Status Code)、標頭 (Headers) 和本文 (Body)。</li><li><strong>兜底處理器</strong>：攔截通用的 <code>Exception.class</code> 可以確保任何未被我們預期到的錯誤，都能被妥善處理，而不會將敏感的堆疊追蹤資訊洩漏給客戶端。</li></ol></li></ul><h2 id="步驟四：測試例外處理"><a href="#步驟四：測試例外處理" class="headerlink" title="步驟四：測試例外處理"></a>步驟四：測試例外處理</h2><p>現在，讓我們來驗證我們的全域例外處理器是否生效。</p><ol><li>啟動您的應用程式。</li><li>使用 Postman 或 <code>curl</code>，發送一個 <code>GET</code> 請求到一個不存在的使用者 ID，例如 <code>http://localhost:8080/users/999</code>。</li></ol><p>您將不再看到 Spring Boot 預設的醜陋錯誤頁面，而是我們親手打造的、清晰的 JSON 錯誤回應，以及一個語義正確的 <code>404 Not Found</code> 狀態碼！</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-08-13T10:45:20.123456&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">404</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Resource Not Found&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;找不到 ID 為 999 的使用者。&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們學會了如何為我們的應用程式建立一套專業、穩固的錯誤處理機制。</p><ul><li>我們理解了將錯誤處理邏輯與業務邏輯混雜的弊端。</li><li>我們掌握了使用 <strong><code>@ControllerAdvice</code></strong> 來建立一個集中式的全域例外處理器。</li><li>我們學會了使用 <strong><code>@ExceptionHandler</code></strong> 來針對不同類型的例外，提供客製化的處理。</li><li>我們能夠向客戶端回傳<strong>標準化、結構清晰</strong>的 JSON 錯誤訊息。</li></ul><p>這種作法極大地提升了程式碼的可讀性與可維護性，是開發高品質 RESTful API 的必備技能。</p><p>我們已經學會了如何優雅地處理錯誤，讓我們的應用程式更加健壯。接下來，我們將探討如何驗證應用程式的正確性，學習如何使用 JUnit 5 與 Mockito 來為我們的業務邏輯撰寫<strong>單元測試</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 18 - 型別安全的組態屬性 (@ConfigurationProperties)</title>
      <link href="/2025/08/13/java-spring-boot-18/"/>
      <url>/2025/08/13/java-spring-boot-18/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：如何優雅地使用設定值？"><a href="#前言：如何優雅地使用設定值？" class="headerlink" title="前言：如何優雅地使用設定值？"></a>前言：如何優雅地使用設定值？</h2><p>在上一篇文章中，我們學會了使用 <code>application.yml</code> 來管理不同環境的組態。現在，一個新的問題擺在眼前：我們該如何在 Java 程式碼中，去「使用」這些我們定義好的設定值呢？</p><p>一種常見但較不推薦的方式是使用 <code>@Value(&quot;$&#123;...&#125;&quot;)</code> 註解，來一個個地將設定值注入到類別的屬性中。這種方式有幾個顯而易見的缺點：</p><ul><li><strong>重複性高</strong>：當需要注入的設定項一多，程式碼會變得非常冗長。</li><li><strong>易出錯</strong>：屬性名稱是以字串形式存在的，如果打錯字，只有在執行階段才會發現。</li><li><strong>非型別安全</strong>：本質上是字串的替換，缺乏編譯時期的類型檢查。</li><li><strong>不易管理</strong>：相關的設定值散落在程式碼的各個角落，難以集中管理。</li></ul><p>為此，Spring Boot 提供了一個更強大、更安全、也更優雅的最佳實踐——使用 <code>@ConfigurationProperties</code> 註解。它能將 <code>yml</code> 檔案中一整塊相關的、具有階層結構的設定，直接「綁定」到一個型別安全的 Java 物件上。</p><h2 id="步驟一：定義我們的客製化組態"><a href="#步驟一：定義我們的客製化組態" class="headerlink" title="步驟一：定義我們的客製化組態"></a>步驟一：定義我們的客製化組態</h2><p>首先，讓我們在 <code>application.yml</code> 的最下方，新增一塊我們自己應用的客製化設定。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 application.yml 最下方新增</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================================</span></span><br><span class="line"><span class="comment"># = CUSTOM APPLICATION PROPERTIES</span></span><br><span class="line"><span class="comment"># ==================================</span></span><br><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&quot;Spring Series Demo Application&quot;</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">&quot;1.0.1&quot;</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">&quot;Gemini&quot;</span></span><br><span class="line">  <span class="attr">contact:</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">&quot;contact@example.com&quot;</span></span><br><span class="line">    <span class="attr">phone:</span> <span class="string">&quot;123-456-7890&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我們定義了一個以 <code>app</code> 為根的階層式設定，其中還包含了一個巢狀的 <code>contact</code> 物件。</p><h2 id="步驟二：建立型別安全的屬性類別"><a href="#步驟二：建立型別安全的屬性類別" class="headerlink" title="步驟二：建立型別安全的屬性類別"></a>步驟二：建立型別安全的屬性類別</h2><p>現在，我們來建立一個 Java 類別，其結構要與我們在 <code>yml</code> 中定義的結構完全對應。</p><ol><li><p>在 <code>com.example.demoapp</code> 下建立新套件 <code>config</code>。</p></li><li><p>在 <code>config</code> 套件中，建立新檔案 <code>AppProperties.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">// 使用 Lombok 自動產生 getter/setter</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span> <span class="comment">// 1. 關鍵註解，指定要綁定的前綴</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> Contact contact; <span class="comment">// 2. 對應到 YML 中的巢狀物件</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span> <span class="comment">// 巢狀物件也需要 getter/setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Contact</span> &#123; <span class="comment">// 3. 使用靜態內部類別來組織</span></span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li><strong>程式碼詳解</strong>：<ol><li><code>@ConfigurationProperties(prefix = &quot;app&quot;)</code>：<strong>這是本篇的核心</strong>。這個註解告訴 Spring Boot：「請去設定檔中，尋找所有以 <code>app</code> 為開頭的設定項，並將它們的值，依照屬性名稱，一一綁定到這個類別的屬性上。」</li><li><code>private Contact contact;</code>：Java 類別中的巢狀物件，完美對應了 YML 中的階層結構。</li><li><code>public static class Contact</code>：將對應巢狀結構的類別，以靜態內部類別的形式定義在主屬性類別中，是一種常見且良好的組織方式。</li></ol></li></ul><h2 id="步驟三：啟用-ConfigurationProperties"><a href="#步驟三：啟用-ConfigurationProperties" class="headerlink" title="步驟三：啟用 @ConfigurationProperties"></a>步驟三：啟用 <code>@ConfigurationProperties</code></h2><p>光是建立屬性類別還不夠，我們還需要告訴 Spring Boot 去「啟用」這個綁定功能，並將 <code>AppProperties</code> 本身也註冊成一個 Bean，這樣其他元件才能注入並使用它。</p><p>最簡單的方式，就是在您的主應用程式類別 <code>DemoAppApplication.java</code> 上，加入 <code>@ConfigurationPropertiesScan</code> 註解。</p><p>修改 <code>DemoAppApplication.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他 import ...</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationPropertiesScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ConfigurationPropertiesScan</span> <span class="comment">// &lt;&lt;-- 新增此註解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoAppApplication</span> &#123;</span><br><span class="line">    <span class="comment">// ... main 方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@ConfigurationPropertiesScan</code> 會自動掃描主應用程式所在套件及其子套件下所有被 <code>@ConfigurationProperties</code> 標註的類別，並將它們註冊到 Spring 容器中。</p><h2 id="步驟四：在應用程式中使用屬性物件"><a href="#步驟四：在應用程式中使用屬性物件" class="headerlink" title="步驟四：在應用程式中使用屬性物件"></a>步驟四：在應用程式中使用屬性物件</h2><p>現在，<code>AppProperties</code> 已經是一個 Spring Bean，我們可以像注入其他 Service 一樣，將它注入到任何需要的地方。</p><p>讓我們修改 <code>HelloController.java</code> 來示範如何使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.config.AppProperties; <span class="comment">// 引入屬性類別</span></span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span> <span class="comment">// 使用 Lombok 進行建構子注入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AppProperties appProperties; <span class="comment">// 注入我們建立的屬性 Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 保留之前的方法 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/app-info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> AppProperties <span class="title function_">getAppInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>測試</strong>：啟動應用程式，並用瀏覽器訪問 <code>http://localhost:8080/app-info</code>。您將會看到一個 JSON 回應，其內容就是我們在 <code>application.yml</code> 中定義的所有 <code>app</code> 相關設定，這證明了屬性綁定已成功。</p><h2 id="步驟五：提升開發體驗-選用但強烈推薦"><a href="#步驟五：提升開發體驗-選用但強烈推薦" class="headerlink" title="步驟五：提升開發體驗 (選用但強烈推薦)"></a>步驟五：提升開發體驗 (選用但強烈推薦)</h2><p>當您在 <code>application.yml</code> 中輸入我們自訂的 <code>app.name</code> 等屬性時，可能會發現 VSCode 沒有任何提示。我們可以加入一個特殊的依賴，讓 IDE 能夠「認識」我們的客製化設定。</p><p>打開 <code>pom.xml</code>，加入以下依賴：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加入後，重新載入您的 Maven 專案。現在，當您再次編輯 <code>application.yml</code> 時，輸入 <code>app.</code> 後，VSCode 就會神奇地提供 <code>name</code>, <code>version</code>, <code>contact</code> 等選項的<strong>自動完成</strong>提示，並能為它們提供說明文件！</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們學會了 Spring Boot 中處理組態的現代化最佳實踐。</p><ul><li>我們比較了 <code>@Value</code> 的侷限性，並了解了 <code>@ConfigurationProperties</code> 的優勢。</li><li>我們透過建立一個 POJO，成功地將 YML 中的階層式設定，<strong>型別安全</strong>地映射到 Java 物件中。</li><li>我們學會了使用 <code>@ConfigurationPropertiesScan</code> 來啟用此功能。</li><li>我們加入了 <code>configuration-processor</code> 來大幅提升開發時的 IDE 體驗。</li></ul><p>這種方法讓組態管理變得集中、安全、易於重構且極度方便。</p><p>我們已經學會了如何以專業、安全的方式管理設定檔。接下來，我們將再次把焦點轉回程式碼的健壯性，學習如何使用 <strong><code>@ControllerAdvice</code></strong> 來建立一個全域的例外處理機制，讓我們能夠優雅地處理應用程式中可能發生的各種錯誤。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 17 - YML 組態檔與多環境管理 (Profiles)</title>
      <link href="/2025/08/13/java-spring-boot-17/"/>
      <url>/2025/08/13/java-spring-boot-17/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：當單一設定檔已不敷使用"><a href="#前言：當單一設定檔已不敷使用" class="headerlink" title="前言：當單一設定檔已不敷使用"></a>前言：當單一設定檔已不敷使用</h2><p>到目前為止，我們所有的應用程式設定都存放在一個 <code>application.properties</code> 檔案中。這在開發初期很方便，但當應用程式準備要部署到不同環境時，問題就出現了：</p><ul><li><strong>開發環境</strong>：我們可能使用 H2 記憶體資料庫，並希望看到詳細的 DEBUG 等級日誌。</li><li><strong>測試環境</strong>：可能需要連接到一台共用的測試資料庫。</li><li><strong>生產環境</strong>：必須連接到正式的、高可用的資料庫，且日誌級別應設為 INFO 或 WARN 以避免效能損耗。</li></ul><p>將所有環境的設定都混在同一個檔案裡，不僅混亂、容易出錯，而且極不安全。為了解決這個問題，Spring Boot 提供了兩個強大的工具：更具可讀性的 <strong>YML 組態格式</strong>，以及用於管理多環境設定的 <strong>Profiles</strong> 功能。</p><p>本篇文章將引導您完成兩件事：</p><ol><li>將現有的 <code>.properties</code> 設定檔遷移到結構更清晰的 <code>.yml</code> 格式。</li><li>學習使用 Profiles 為「開發」與「生產」環境建立各自獨立的設定。</li></ol><h2 id="步驟一：從-properties-到-yml"><a href="#步驟一：從-properties-到-yml" class="headerlink" title="步驟一：從 .properties 到 .yml"></a>步驟一：從 <code>.properties</code> 到 <code>.yml</code></h2><p>YAML (YAML Ain’t Markup Language) 是一種以資料為中心的標記語言，相較於傳統的 <code>.properties</code> 格式，它具有更強的結構化與可讀性。</p><p><strong>為何選擇 YML？</strong></p><ul><li><strong>階層結構</strong>：YML 使用縮排來表示階層關係，完美對應了 Java 物件的結構，可讀性極高。</li><li><strong>簡潔</strong>：無需重複撰寫像 <code>spring.datasource</code> 這樣的前綴。</li></ul><p><strong>開始轉換</strong>：</p><ol><li>在 <code>src/main/resources</code> 目錄下，將 <code>application.properties</code> 檔案<strong>重新命名</strong>為 <code>application.yml</code>。</li><li>將其內容轉換為 YML 格式。</li></ol><p>**轉換前 (<code>.properties</code>)**：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.h2.console.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.h2.console.path</span>=<span class="string">/h2-console</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:h2:mem:testdb</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">validate</span></span><br><span class="line"><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">logging.level.com.example.demoapp</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><p>**轉換後 (<code>.yml</code>)**：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">h2:</span></span><br><span class="line">    <span class="attr">console:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/h2-console</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:h2:mem:testdb</span></span><br><span class="line">    <span class="attr">driverClassName:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;&quot;</span> <span class="comment"># 空字串建議加上引號</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">validate</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.example.demoapp:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：YML 對縮排極其敏感，請務必使用<strong>空格</strong>（而非 Tab）進行縮排。</p><h2 id="步驟二：多環境管理的核心：Profiles"><a href="#步驟二：多環境管理的核心：Profiles" class="headerlink" title="步驟二：多環境管理的核心：Profiles"></a>步驟二：多環境管理的核心：Profiles</h2><p><strong>Profile</strong> 可以被理解為一個「<strong>設定檔的標籤</strong>」。您可以為不同的環境建立帶有不同標籤的設定檔，然後在啟動應用程式時，告訴 Spring Boot 要啟用哪一個標籤（Profile），Spring Boot 就會去載入對應的設定。</p><p>最常見的 Profiles 包括 <code>dev</code>（開發）、<code>test</code>（測試）和 <code>prod</code>（生產）。</p><p>Spring Boot 中使用 Profiles 的標準做法是建立 <code>application-&#123;profile&#125;.yml</code> 格式的檔案。例如：</p><ul><li><code>application-dev.yml</code>：開發環境專用的設定檔。</li><li><code>application-prod.yml</code>：生產環境專用的設定檔。</li></ul><p><strong>載入順序</strong>：<br>Spring Boot 會先載入通用的 <code>application.yml</code>，然後再載入被啟用的 Profile 對應的檔案（例如 <code>application-dev.yml</code>）。如果兩個檔案中有相同的設定項，<strong>Profile-Specific 檔案中的值會覆寫通用檔案中的值</strong>。</p><h2 id="步驟三：建立-Profile-Specific-設定檔"><a href="#步驟三：建立-Profile-Specific-設定檔" class="headerlink" title="步驟三：建立 Profile-Specific 設定檔"></a>步驟三：建立 Profile-Specific 設定檔</h2><p>讓我們來實際操作，將設定檔拆分為「通用」、「開發專用」和「生產專用」三部分。</p><ol><li><p><strong>整理 <code>application.yml</code> (通用設定)</strong><br>保留所有環境都會共用的設定。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 通用的應用程式設定可以放在這裡</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">validate</span> <span class="comment"># 所有環境都進行驗證</span></span><br><span class="line"><span class="comment"># ... 其他通用設定 ...</span></span><br></pre></td></tr></table></figure></li><li><p><strong>建立 <code>application-dev.yml</code> (開發環境)</strong><br>在 <code>src/main/resources</code> 下建立新檔案 <code>application-dev.yml</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 開發環境專用設定</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">h2:</span></span><br><span class="line">    <span class="attr">console:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 開發時啟用 H2 Console</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:h2:mem:testdb</span> <span class="comment"># 開發時使用記憶體資料庫</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span> <span class="comment"># 開發時顯示執行的 SQL</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.example.demoapp:</span> <span class="string">DEBUG</span> <span class="comment"># 開發時使用 DEBUG 日誌級別</span></span><br></pre></td></tr></table></figure></li><li><p><strong>建立 <code>application-prod.yml</code> (生產環境)</strong><br>在 <code>src/main/resources</code> 下建立新檔案 <code>application-prod.yml</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生產環境專用設定</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 生產環境通常監聽 80 或 443 port</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 生產環境通常連接到真實的資料庫，例如 PostgreSQL</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:postgresql://prod-db-host:5432/prod_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">prod_user</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;PROD_DB_PASSWORD&#125;</span> <span class="comment"># 最佳實踐：從環境變數讀取密碼</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.example.demoapp:</span> <span class="string">INFO</span> <span class="comment"># 生產環境使用 INFO 日誌級別</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在生產環境中，將密碼等敏感資訊透過環境變數 (<code>$&#123;...&#125;</code>) 傳入，是一種更安全的做法。</p></li></ol><h2 id="步驟四：啟用與切換-Profiles"><a href="#步驟四：啟用與切換-Profiles" class="headerlink" title="步驟四：啟用與切換 Profiles"></a>步驟四：啟用與切換 Profiles</h2><p>那麼，如何告訴 Spring Boot 要使用哪個 Profile 呢？有以下幾種常用方式：</p><ol><li><p><strong>在 <code>application.yml</code> 中指定 (常用於開發)</strong><br>這是最直接的方式，通常用於設定開發時的預設 Profile。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 application.yml 中</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 將 dev 設為預設啟用的 Profile</span></span><br></pre></td></tr></table></figure></li><li><p><strong>透過命令列參數 (常用於部署)</strong><br>在執行 JAR 檔時，透過命令列參數來指定 Profile。<strong>這個方式的優先級高於在 <code>application.yml</code> 中的設定</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar your-app.jar --spring.profiles.active=prod</span><br></pre></td></tr></table></figure></li><li><p><strong>透過環境變數 (適用於容器化部署)</strong><br>在 Docker 或 Kubernetes 等環境中，使用環境變數來設定 Profile 非常普遍。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> SPRING_PROFILES_ACTIVE=prod</span><br><span class="line">java -jar your-app.jar</span><br></pre></td></tr></table></figure></li></ol><p><strong>測試</strong>：在 <code>application.yml</code> 中設定 <code>spring.profiles.active: dev</code>，然後啟動應用。您會發現伺服器在 <code>8080</code> 埠啟動，且 H2 Console 是可訪問的。這證明了 <code>application-dev.yml</code> 已被成功載入。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們掌握了專業的組態管理技能。</p><ul><li>我們學會了使用結構更清晰、可讀性更高的 <strong>YML</strong> 格式來取代 <code>.properties</code>。</li><li>我們深入理解了 <strong>Spring Profiles</strong> 的概念，並學會了如何建立 <code>application-&#123;profile&#125;.yml</code> 來隔離不同環境的設定。</li><li>我們知道了如何在開發與部署時，透過不同方式<strong>啟用與切換</strong>所需的 Profile。</li></ul><p>這是將應用程式從本機開發環境推向真實生產伺服器的關鍵一步。</p><p>我們已經學會了如何管理不同環境的組態。在下一篇文章中，我們將探討一個讓組態管理更安全、更優雅的最佳實踐——<strong>型別安全的組態屬性</strong>，學習如何將 YML 中的設定值直接映射到一個 Java 物件中。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 16 - 資料庫遷移工具 Flyway 入門</title>
      <link href="/2025/08/12/java-spring-boot-16/"/>
      <url>/2025/08/12/java-spring-boot-16/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：為何-ddl-auto-不適用於生產環境？"><a href="#前言：為何-ddl-auto-不適用於生產環境？" class="headerlink" title="前言：為何 ddl-auto 不適用於生產環境？"></a>前言：為何 <code>ddl-auto</code> 不適用於生產環境？</h2><p>到目前為止，我們一直依賴 <code>spring.jpa.hibernate.ddl-auto=update</code> 這個設定來讓 Hibernate 自動幫我們建立或更新資料庫的表格結構。這在開發初期非常方便，但若將其用於生產環境，則是一場災難。原因如下：</p><ul><li><strong>不可預測性</strong>：您無法精準控制 Hibernate 產生的 SQL，它像一個「黑盒子」，可能會在您不預期的情況下做出變更。</li><li><strong>資料遺失風險</strong>：在某些複雜的變更情境下，<code>update</code> 策略可能會選擇「刪除重建」表格，這將導致所有生產資料遺失。</li><li><strong>缺乏版本歷史</strong>：您沒有任何紀錄來追蹤資料庫結構是如何一步步演變至今的。</li><li><strong>團隊協作困難</strong>：當多位開發者同時對資料庫結構進行修改時，<code>ddl-auto</code> 會讓情況變得一團混亂。</li></ul><p>為了解決這些問題，專業的開發實踐是採用<strong>資料庫遷移 (Database Migration)</strong> 工具。<strong>Flyway</strong> 是其中最受歡迎的工具之一，它將資料庫的結構變更視為程式碼，透過一系列版本化的 SQL 腳本來進行管理，確保每一次變更都是可追蹤、可重複且安全的。</p><p>本篇文章將帶您整合 Flyway，並學習如何用它來接管我們的資料庫結構管理。</p><h2 id="步驟一：整合-Flyway"><a href="#步驟一：整合-Flyway" class="headerlink" title="步驟一：整合 Flyway"></a>步驟一：整合 Flyway</h2><ol><li><p><strong>加入 Maven 相依性</strong><br>打開專案的 <code>pom.xml</code> 檔案，加入 Flyway 的核心依賴：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.flywaydb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flyway-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot 擁有對 Flyway 的絕佳自動設定支援。只要這個依賴存在，Spring Boot 就會在應用程式啟動時自動啟用 Flyway。</p></li><li><p><strong>停用 Hibernate 的 DDL-Auto 功能</strong><br><strong>這是至關重要的一步</strong>。既然我們要將資料庫結構的管理權交給 Flyway，就必須關閉 Hibernate 的自動化功能。</p><p>打開 <code>src/main/resources/application.properties</code>，修改以下設定：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將 ddl-auto 從 &quot;update&quot; 改為 &quot;validate&quot; 或 &quot;none&quot;</span></span><br><span class="line"><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">validate</span></span><br></pre></td></tr></table></figure><ul><li><code>validate</code>：是一個很好的安全防護。Hibernate 會在啟動時檢查您的 Entity 定義是否與資料庫的實際結構相符，如果不符，應用程式將啟動失敗，提醒您有不一致的情況。</li><li><code>none</code>：完全關閉 Hibernate 的 DDL 功能，這是生產環境中最安全的設定。</li></ul></li></ol><h2 id="步驟二：建立您的第一支遷移腳本"><a href="#步驟二：建立您的第一支遷移腳本" class="headerlink" title="步驟二：建立您的第一支遷移腳本"></a>步驟二：建立您的第一支遷移腳本</h2><p>Flyway 透過執行一系列帶有版本號的 SQL 腳本來工作。</p><ol><li><p><strong>建立腳本目錄</strong><br>根據預設，Flyway 會在 <code>src/main/resources/db/migration</code> 這個路徑下尋找 SQL 腳本。請手動建立這個目錄結構。</p></li><li><p><strong>遵循命名慣例</strong><br>Flyway 的腳本命名有著嚴格的規則：<code>V&lt;版本號&gt;__&lt;描述&gt;.sql</code></p><ul><li><code>V</code>：大寫字母 V。</li><li><code>&lt;版本號&gt;</code>：例如 <code>1</code>, <code>1.1</code>, <code>202508121700</code>。版本號之間可以用 <code>.</code> 或 <code>_</code> 分隔。Flyway 會依照版本號從小到大依序執行。</li><li><code>__</code>：兩個底線，作為版本號與描述之間的分隔符。</li><li><code>&lt;描述&gt;</code>：用英文和底線來描述這個腳本的作用。</li><li><code>.sql</code>：副檔名。</li></ul></li><li><p><strong>撰寫第一版綱要 (Schema)</strong><br>現在，我們需要手動撰寫之前由 Hibernate 自動產生的 <code>CREATE TABLE</code> 語句。<br>在 <code>src/main/resources/db/migration</code> 目錄下，建立一個新檔案，命名為 <code>V1__Create_users_and_posts_tables.sql</code>，並貼上以下內容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">BIGINT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> posts (</span><br><span class="line">    id <span class="type">BIGINT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    content <span class="type">CLOB</span>,</span><br><span class="line">    user_id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (user_id) <span class="keyword">REFERENCES</span> users(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h2 id="步驟三：Flyway-的運作流程"><a href="#步驟三：Flyway-的運作流程" class="headerlink" title="步驟三：Flyway 的運作流程"></a>步驟三：Flyway 的運作流程</h2><p>現在，啟動您的應用程式。在啟動過程中，Flyway 會執行以下操作：</p><ol><li>連接到您的資料庫。</li><li>在資料庫中尋找一張名為 <code>flyway_schema_history</code> 的元資料表格。如果不存在，就自動建立它。這張表格用於記錄所有已經被成功執行過的遷移腳本。</li><li>掃描 <code>db/migration</code> 目錄下的所有遷移腳本。</li><li>將找到的腳本與 <code>flyway_schema_history</code> 表中的紀錄進行比對。</li><li>執行所有尚未被記錄的、新的遷移腳本（依照版本號順序）。</li><li>每成功執行一個腳本，就在 <code>flyway_schema_history</code> 表中新增一筆紀錄。</li></ol><p><strong>驗證</strong>：啟動後，登入 H2 Console (<code>http://localhost:8080/h2-console</code>)。您會發現資料庫中現在有三張表格：<code>USERS</code>、<code>POSTS</code> 和 <code>FLYWAY_SCHEMA_HISTORY</code>。執行 <code>SELECT * FROM FLYWAY_SCHEMA_HISTORY;</code>，您會看到 <code>V1</code> 這筆腳本的執行紀錄。</p><h2 id="步驟四：新增一次變更"><a href="#步驟四：新增一次變更" class="headerlink" title="步驟四：新增一次變更"></a>步驟四：新增一次變更</h2><p>假設我們的需求變更，需要在 <code>users</code> 表格中新增一個 <code>created_at</code> 欄位來記錄建立時間。</p><p><strong>重要原則：絕對不要修改已經被執行過的遷移腳本！</strong> Flyway 會計算每個腳本的校驗和 (Checksum) 並儲存起來，若發現已執行的腳本被修改，啟動將會失敗。</p><p>所有新的變更，都必須透過<strong>新的、更高版本</strong>的腳本來實現。</p><ol><li><p><strong>建立新腳本</strong><br>在 <code>db/migration</code> 目錄下，建立一個新檔案 <code>V2__Add_created_at_to_users_table.sql</code>。</p></li><li><p><strong>撰寫變更語句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> created_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>重新啟動應用</strong><br>這次啟動時，Flyway 會發現 <code>V1</code> 已經執行過，因此會跳過它，然後執行新的 <code>V2</code> 腳本，並將 <code>V2</code> 的執行紀錄也寫入歷史表格中。</p></li></ol><p><strong>驗證</strong>：再次登入 H2 Console，您會發現 <code>users</code> 表格中成功新增了 <code>created_at</code> 欄位，且 <code>flyway_schema_history</code> 表格中現在有兩筆紀錄。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們學會了如何從 <code>ddl-auto</code> 的開發便利性，轉向使用 Flyway 進行專業、可靠的資料庫版本控制。</p><ul><li>我們理解了為何 <code>ddl-auto</code> 不適用於生產環境。</li><li>我們整合了 Flyway，並學會了其<strong>版本化的 SQL 腳本命名規則</strong>。</li><li>我們親身體驗了 Flyway 如何追蹤並依序執行遷移，確保資料庫結構的演進是<strong>可追溯且可重複</strong>的。</li></ul><p>使用資料庫遷移工具是現代軟體開發的標準實踐，它為團隊協作與持續整合&#x2F;持續部署 (CI&#x2F;CD) 流程奠定了穩固的基礎。</p><p>我們已經掌握了如何以專業的方式管理資料庫結構。接下來，我們將把焦點轉向應用程式的健壯性，學習如何使用 <strong>YML</strong> 格式來更清晰地管理不同環境的設定檔。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 15 - 交易管理 @Transactional</title>
      <link href="/2025/08/12/java-spring-boot-15/"/>
      <url>/2025/08/12/java-spring-boot-15/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：為何需要交易？"><a href="#前言：為何需要交易？" class="headerlink" title="前言：為何需要交易？"></a>前言：為何需要交易？</h2><p>想像一個銀行轉帳的場景：從 A 帳戶轉 1000 元到 B 帳戶。這個操作需要至少兩個步驟：</p><ol><li>從 A 帳戶扣除 1000 元。</li><li>在 B 帳戶增加 1000 元。</li></ol><p>如果系統在完成步驟 1 之後、執行步驟 2 之前突然當機，會發生什麼事？A 帳戶的錢被扣了，但 B 帳戶卻沒收到。資料庫的狀態變得不一致且錯誤，這在任何應用程式中都是一場災難。</p><p>為了解決這個問題，資料庫引入了「**交易 (Transaction)**」的概念。一個交易可以將一系列操作捆綁成一個不可分割的邏輯單元。這個單元內的所有操作，要麼全部成功執行，要麼就全部失敗回滾（Rollback）到最初的狀態，彷彿什麼都沒發生過一樣。</p><p>本篇文章將帶您了解交易的 ACID 原則，並學習如何透過 Spring 中一個簡單而強大的註解——<code>@Transactional</code>，來為我們的業務邏輯加上這層重要的資料保護網。</p><h2 id="什麼是交易-Transaction-與-ACID-原則？"><a href="#什麼是交易-Transaction-與-ACID-原則？" class="headerlink" title="什麼是交易 (Transaction) 與 ACID 原則？"></a>什麼是交易 (Transaction) 與 ACID 原則？</h2><p>一個可靠的交易系統，必須遵循四大特性，合稱為 <strong>ACID</strong> 原則：</p><ol><li><p>**原子性 (Atomicity)**：一個交易是最小的執行單位，不可再分割。交易中的所有操作要麼全部完成 (Commit)，要麼全部失敗 (Rollback)。前述的轉帳例子，就是原子性的最佳體現。</p></li><li><p>**一致性 (Consistency)**：交易必須使資料庫從一個一致的狀態，轉變到另一個一致的狀態。在交易開始之前和結束以後，資料庫的完整性約束沒有被破壞。</p></li><li><p>**隔離性 (Isolation)**：當多個交易併發執行時，一個交易的執行不應被其他交易干擾。每個交易都感覺不到系統中還有其他交易在併發地執行。</p></li><li><p>**持久性 (Durability)**：一旦交易被提交，那麼它對資料庫中所做的更改就是永久性的，即使後續系統發生故障也不會丟失。</p></li></ol><h2 id="Transactional-的魔力"><a href="#Transactional-的魔力" class="headerlink" title="@Transactional 的魔力"></a><code>@Transactional</code> 的魔力</h2><p>Spring 框架提供了「**宣告式交易管理 (Declarative Transaction Management)**」，讓我們可以透過一個簡單的註解 <code>@Transactional</code> 來管理交易，而無需編寫任何樣板程式碼。</p><p><strong>它是如何運作的？</strong><br>當您在一個 public 方法上加上 <code>@Transactional</code> 註解時，Spring 會在背後使用 <strong>AOP (Aspect-Oriented Programming)</strong> 技術為您的物件建立一個代理 (Proxy)。當這個方法被呼叫時：</p><ul><li><strong>代理物件</strong>會先開始一個新的交易。</li><li>接著，<strong>實際的業務方法</strong>被執行。</li><li>如果業務方法<strong>成功完成</strong>，沒有拋出任何例外，代理物件就會<strong>提交 (Commit)</strong> 這個交易。</li><li>如果業務方法在執行過程中<strong>拋出了任何未受檢例外 (Unchecked Exception)<strong>，例如 <code>RuntimeException</code>，代理物件就會</strong>回滾 (Rollback)</strong> 這個交易，撤銷所有已做的更改。</li></ul><p><strong>應該在哪裡使用？</strong><br><code>@Transactional</code> 註解通常被放置在<strong>業務邏輯層 (Service Layer)</strong> 的 <code>public</code> 方法上，因為 Service 層的方法通常封裝了一個完整的業務操作單元。</p><h2 id="在實踐中使用-Transactional"><a href="#在實踐中使用-Transactional" class="headerlink" title="在實踐中使用 @Transactional"></a>在實踐中使用 <code>@Transactional</code></h2><p>讓我們透過一個範例來親身體驗交易回滾的威力。我們將修改 <code>UserService</code>，模擬在建立使用者的過程中發生錯誤。</p><p>修改 <code>com.example.demoapp.service.UserService.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"><span class="comment">// ... 其他 import ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 將整個方法標示為一個交易</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(CreateUserRequest request)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(request.getUsername());</span><br><span class="line">        user.setEmail(request.getEmail());</span><br><span class="line">        user.setAge(request.getAge());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 儲存使用者到資料庫</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userRepository.save(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 模擬一個錯誤發生，以觸發交易回滾</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;error&quot;</span>.equals(request.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;故意拋出錯誤來測試交易回滾！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> savedUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他 Service 方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>測試交易回滾</strong>：</p><ol><li>啟動您的應用程式。</li><li><strong>測試成功情境</strong>：使用 Postman 等工具，發送 <code>POST</code> 請求到 <code>/users</code>，本文為 <code>&#123;&quot;username&quot;: &quot;alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;, &quot;age&quot;: 30&#125;</code>。請求成功，資料被存入資料庫。</li><li><strong>測試失敗情境</strong>：再次發送 <code>POST</code> 請求到 <code>/users</code>，但這次本文為 <code>&#123;&quot;username&quot;: &quot;error&quot;, &quot;email&quot;: &quot;error@example.com&quot;, &quot;age&quot;: 99&#125;</code>。</li><li><strong>觀察結果</strong>：您會看到伺服器回應了 HTTP 500 錯誤，並且在主控台中看到了我們拋出的 <code>RuntimeException</code>。現在，登入 H2 Console (<code>http://localhost:8080/h2-console</code>) 並查詢 <code>users</code> 表格，您會發現<strong>根本沒有 <code>error</code> 這個使用者被存進去</strong>。這證明了即使 <code>userRepository.save(user)</code> 已經執行，但因為後續發生錯誤，整個交易被成功回滾了！</li></ol><h2 id="Transactional-的重要屬性"><a href="#Transactional-的重要屬性" class="headerlink" title="@Transactional 的重要屬性"></a><code>@Transactional</code> 的重要屬性</h2><p><code>@Transactional</code> 註解還有一些常用的屬性，可以讓我們更細緻地控制交易行為。</p><ul><li><p><strong><code>readOnly = true</code></strong></p><ul><li>這是一個非常重要的<strong>效能優化</strong>屬性。當您將一個方法標示為 <code>readOnly = true</code> 時，等於是告訴 JPA 和資料庫：「這個操作只會讀取資料，不會做任何修改」。這可以讓資料庫省略一些不必要的鎖定和檢查。</li><li><strong>最佳實踐</strong>：所有查詢型的方法（如 <code>getAllUsers()</code>, <code>getUserById()</code>）都應該加上 <code>@Transactional(readOnly = true)</code>。</li></ul><!-- end list --><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>rollbackFor</code></strong></p><ul><li>預設情況下，<code>@Transactional</code> 只會對 <code>RuntimeException</code> 或 <code>Error</code> 這類<strong>未受檢例外</strong>進行回滾。對於**受檢例外 (Checked Exception)**（如 <code>IOException</code>），它預設是不會回滾的。</li><li>如果您希望在發生受檢例外時也觸發回滾，可以使用 <code>rollbackFor</code> 屬性來指定。</li><li><strong>範例</strong>：<code>@Transactional(rollbackFor = Exception.class)</code> 表示無論發生任何繼承自 <code>Exception</code> 的例外，都進行回滾。</li></ul></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們掌握了保障資料一致性的關鍵武器——交易。</p><ul><li>我們理解了交易的 <strong>ACID</strong> 四大基本原則。</li><li>我們學會了如何使用 Spring 強大而簡潔的 <strong><code>@Transactional</code></strong> 註解來宣告式地管理交易。</li><li>我們親眼見證了在發生錯誤時，<strong>交易回滾</strong>如何保護我們的資料不被破壞。</li><li>我們了解了如何使用 <code>readOnly</code> 屬性來優化查詢效能。</li></ul><p>我們已經掌握了資料庫的核心操作，從 CRUD、複雜查詢到交易管理。在下一篇文章中，我們將學習一個在實際專案中非常重要的工程實踐——**資料庫遷移 (Migration)**，透過 Flyway 工具來版本化地管理我們的資料庫結構變更。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 14 - Entity 關聯：一對多與多對一</title>
      <link href="/2025/08/12/java-spring-boot-14/"/>
      <url>/2025/08/12/java-spring-boot-14/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：從獨立到互聯"><a href="#前言：從獨立到互聯" class="headerlink" title="前言：從獨立到互聯"></a>前言：從獨立到互聯</h2><p>在之前的文章中，我們已經掌握了對單一資料表格的各種操作。然而，真實世界的應用程式資料模型，絕非一個個獨立的孤島，而是由各種相互關聯的資料所組成的複雜網路。例如，一個使用者可以發表多篇文章；一筆訂單可以包含多個商品項目。</p><p>要將這種「關聯」在物件導向的世界與關聯式資料庫中優雅地表達出來，正是 JPA 的核心價值所在。本篇文章將聚焦於最常見、最基礎的一種關聯類型：<strong>一對多(One-to-Many)</strong> 與 <strong>多對一(Many-to-One)</strong> 。</p><p>我們將以一個清晰的範例——「一個使用者可以發表多篇文章」——來貫穿全文，學習如何透過 JPA 註解，輕鬆地建立起實體之間的關聯。</p><h2 id="關聯性概念與外鍵"><a href="#關聯性概念與外鍵" class="headerlink" title="關聯性概念與外鍵"></a>關聯性概念與外鍵</h2><p>在我們開始撰寫程式碼之前，先快速回顧一下資料庫中的「外鍵 (Foreign Key)」概念。</p><p>為了表達「這篇文章是哪個使用者發表的」，我們會在 <code>posts</code> 這張表格中，新增一個名為 <code>user_id</code> 的欄位。這個欄位的值，將會對應到 <code>users</code> 表格中某筆紀錄的主鍵 (Primary Key)。這個 <code>user_id</code> 欄位，就是一個指向 <code>users</code> 表格的外鍵。</p><p>JPA 的關聯註解 (<code>@ManyToOne</code>, <code>@OneToMany</code> 等)，就是讓我們用物件導向的方式，來自動化管理這些外鍵關係的強大工具。</p><h2 id="步驟一：建立新的-Post-Entity"><a href="#步驟一：建立新的-Post-Entity" class="headerlink" title="步驟一：建立新的 Post Entity"></a>步驟一：建立新的 <code>Post</code> Entity</h2><p>首先，我們需要一個代表「文章」的實體。</p><p>在 <code>com.example.demoapp.entity</code> 套件下，建立一個新檔案 <code>Post.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.persistence.*;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;posts&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Post</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lob</span> <span class="comment">// 表示這是一個「大型物件」，適合儲存較長的文字內容</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 關聯對映將會加在這裡...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步驟二：建立「多對一」關聯-ManyToOne"><a href="#步驟二：建立「多對一」關聯-ManyToOne" class="headerlink" title="步驟二：建立「多對一」關聯 (@ManyToOne)"></a>步驟二：建立「多對一」關聯 (<code>@ManyToOne</code>)</h2><p>通常，我們會從持有「外鍵」的那一方開始建立關聯。在這個範例中，是 <code>Post</code> 這一方（因為 <code>posts</code> 表格需要 <code>user_id</code> 這個外鍵）。我們稱持有外鍵的這一方為**關聯的擁有方 (Owning Side)**。</p><p>修改 <code>Post.java</code>，在類別中加入以下程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in Post.java ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;posts&quot;)</span></span><br><span class="line"><span class="comment">// @ToString(exclude = &quot;user&quot;) // 在 toString() 中排除 user 屬性，避免無限遞迴</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(exclude = &quot;user&quot;)</span> <span class="comment">// 同理，在 equals/hashCode 中也排除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="comment">// ... id, title, content 屬性 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 「多」篇文章(Post)可以對應到「一」個使用者(User)</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span> <span class="comment">// 1.</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;user_id&quot;, nullable = false)</span> <span class="comment">// 2.</span></span><br><span class="line">    <span class="meta">@ToString</span>.Exclude <span class="comment">// 在 toString() 中排除 user 屬性，避免無限遞迴</span></span><br><span class="line">    <span class="keyword">private</span> User user; <span class="comment">// 3.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ol><li><code>@ManyToOne</code>：宣告這是一個「多對一」的關聯。多篇 <code>Post</code> 可以關聯到一個 <code>User</code>。<code>fetch = FetchType.LAZY</code> 是一種效能優化策略（懶加載），我們會在後續文章探討。</li><li><code>@JoinColumn</code>：<strong>這是定義外鍵的關鍵註解</strong>。<code>name = &quot;user_id&quot;</code> 告訴 JPA，請在 <code>posts</code> 表格中建立一個名為 <code>user_id</code> 的欄位作為外鍵。</li><li><code>private User user;</code>：在「多」的這一方，我們直接持有一個「一」那方的物件參考。</li></ol></li></ul><h2 id="步驟三：建立「一對多」關聯-OneToMany"><a href="#步驟三：建立「一對多」關聯-OneToMany" class="headerlink" title="步驟三：建立「一對多」關聯 (@OneToMany)"></a>步驟三：建立「一對多」關聯 (<code>@OneToMany</code>)</h2><p>接著，我們來建立反向的關聯，讓 <code>User</code> 實體也能知道它發表了哪些文章。這一邊我們稱為**關聯的被擁有方 (Inverse Side)**。</p><p>修改 <code>com.example.demoapp.entity.User.java</code>，加入以下程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in User.java ...</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ... id, username, email, age 屬性 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 「一」個使用者(User)可以有多篇(Many)文章(Post)</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL, orphanRemoval = true)</span> <span class="comment">// 1.</span></span><br><span class="line">    <span class="meta">@ToString</span>.Exclude <span class="comment">// 在 toString() 中排除 posts 屬性，避免無限遞迴</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Post&gt; posts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ol><li><code>@OneToMany</code>：宣告這是一個「一對多」的關聯。</li><li><code>mappedBy = &quot;user&quot;</code>：<strong>這是雙向關聯中最重要的屬性</strong>。它告訴 JPA：「這個關聯關係已經被 <code>Post</code> 類別中的 <code>user</code> 屬性所管理了（也就是由對方來維護外鍵），我這邊只是反向的參考而已」。<strong>設定了 <code>mappedBy</code> 的這一方，就是「被擁有方」</strong>，JPA 將不會為它建立額外的表格或欄位。</li><li><code>cascade = CascadeType.ALL</code>：設定<strong>級聯操作</strong>。這意味著對 <code>User</code> 的操作（如儲存、刪除）將會自動傳播到其關聯的 <code>Post</code> 上。例如，當我們儲存一個新的 <code>User</code> 和他關聯的 <code>Post</code> 時，只需儲存 <code>User</code> 物件即可；當我們刪除一個 <code>User</code> 時，他發表的所有 <code>Post</code> 也會被一併自動刪除。</li><li><code>orphanRemoval = true</code>：表示當一個 <code>Post</code> 從 <code>User</code> 的 <code>posts</code> 集合中被移除時，這個「被遺棄的」<code>Post</code> 應該從資料庫中被刪除。</li></ol></li></ul><h2 id="步驟四：在實踐中測試關聯"><a href="#步驟四：在實踐中測試關聯" class="headerlink" title="步驟四：在實踐中測試關聯"></a>步驟四：在實踐中測試關聯</h2><p>讓我們再次使用 <code>CommandLineRunner</code> 來驗證我們建立的雙向關聯。</p><p>修改 <code>DemoAppApplication.java</code> 中的 <code>CommandLineRunner</code> Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in DemoAppApplication.java&#x27;s CommandLineRunner ...</span></span><br><span class="line"><span class="comment">// 為了測試，我們先建立一個 PostRepository</span></span><br><span class="line"><span class="comment">// cd repository &amp;&amp; touch PostRepository.java</span></span><br><span class="line"><span class="comment">// 然後讓 Spring 注入 UserRepository 和 PostRepository</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">demo</span><span class="params">(UserRepository userRepository, PostRepository postRepository)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (args) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 1. 建立一個使用者</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;AuthorUser&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;author@example.com&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 建立幾篇文章</span></span><br><span class="line">        <span class="type">Post</span> <span class="variable">post1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>();</span><br><span class="line">        post1.setTitle(<span class="string">&quot;第一篇文章&quot;</span>);</span><br><span class="line">        post1.setContent(<span class="string">&quot;這是關於 JPA 的第一篇文章內容。&quot;</span>);</span><br><span class="line">        post1.setUser(user); <span class="comment">// **設定關聯**</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Post</span> <span class="variable">post2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>();</span><br><span class="line">        post2.setTitle(<span class="string">&quot;第二篇文章&quot;</span>);</span><br><span class="line">        post2.setContent(<span class="string">&quot;這是關於 Spring Boot 的第二篇文章內容。&quot;</span>);</span><br><span class="line">        post2.setUser(user); <span class="comment">// **設定關聯**</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 將文章加入到使用者的列表中 (維護雙向關係)</span></span><br><span class="line">        user.getPosts().add(post1);</span><br><span class="line">        user.getPosts().add(post2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 儲存使用者 (因為設定了 CascadeType.ALL, 關聯的 Post 會一併被儲存)</span></span><br><span class="line">        userRepository.save(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 查詢使用者及其所有文章 ---&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">foundUser</span> <span class="operator">=</span> userRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用者: &quot;</span> + foundUser.getUsername());</span><br><span class="line">        foundUser.getPosts().forEach(post -&gt; </span><br><span class="line">            System.out.println(<span class="string">&quot;  文章標題: &quot;</span> + post.getTitle())</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--- 查詢使用者及其所有文章 ---</span><br><span class="line">使用者: AuthorUser</span><br><span class="line">  文章標題: 第一篇文章</span><br><span class="line">  文章標題: 第二篇文章</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：在執行前，請先建立一個空的 <code>PostRepository</code> 介面，它繼承自 <code>JpaRepository&lt;Post, Long&gt;</code>，就像我們之前建立 <code>UserRepository</code> 一樣。</p></blockquote><p>重新啟動應用，您將在主控台中看到使用者和他的文章被成功查詢出來。此時登入 H2 Console (<code>http://localhost:8080/h2-console</code>)，您會發現多了一張 <code>POSTS</code> 表格，並且其 <code>USER_ID</code> 欄位正確地指向了 <code>USERS</code> 表格的對應紀錄。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們成功地為我們的應用程式建立了真實世界的資料模型。</p><ul><li>我們理解了<strong>外鍵</strong>是實現資料庫關聯的基礎。</li><li>我們學會了使用 <code>@ManyToOne</code> 和 <code>@JoinColumn</code> 來定義關聯的<strong>擁有方</strong>。</li><li>我們掌握了使用 <code>@OneToMany</code> 和 <code>mappedBy</code> 來定義關聯的<strong>被擁有方</strong>，從而建立雙向關聯。</li><li>我們了解了 <code>cascade</code> 級聯操作如何簡化我們的持久化程式碼。</li></ul><p>我們已經掌握了最常見的實體關聯。但在確保資料完整性方面，還有一個非常重要的主題——交易管理。在下一篇文章中，我們將深入探討 <strong><code>@Transactional</code></strong> 註解，學習如何確保一系列資料庫操作要麼全部成功，要麼全部失敗。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 13 - 使用 @Query 進行複雜查詢 (JPQL)</title>
      <link href="/2025/08/12/java-spring-boot-13/"/>
      <url>/2025/08/12/java-spring-boot-13/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：當查詢方法不夠用時"><a href="#前言：當查詢方法不夠用時" class="headerlink" title="前言：當查詢方法不夠用時"></a>前言：當查詢方法不夠用時</h2><p>在上一篇文章中，我們體驗了 Spring Data JPA 查詢方法 (Query Methods) 的魔力，僅僅透過方法命名就能實現多樣化的查詢。這個功能在多數情況下都非常出色，但當查詢邏輯變得非常複雜時，它也會遇到瓶頸：</p><ul><li><strong>方法名稱過於冗長</strong>：一個包含多個 <code>And</code>、<code>Or</code> 和其他條件的查詢，會導致方法名稱變得極其冗長且難以閱讀。</li><li><strong>功能限制</strong>：對於需要複雜 <code>JOIN</code>、子查詢 (Sub-queries) 或資料庫彙總函式 (<code>AVG</code>, <code>SUM</code> 等) 的操作，查詢方法便無能為力。</li></ul><p>為了解決這些問題，Spring Data JPA 提供了終極武器——<code>@Query</code> 註解。它允許我們在 Repository 方法上，直接撰寫查詢語句，從而給予我們完全的控制權與靈活性。</p><h2 id="什麼是-JPQL？"><a href="#什麼是-JPQL？" class="headerlink" title="什麼是 JPQL？"></a>什麼是 JPQL？</h2><p>在使用 <code>@Query</code> 之前，我們需要先認識 **JPQL (Java Persistence Query Language)**。</p><p>JPQL 是一種<strong>物件導向的查詢語言</strong>，語法上與 SQL 非常相似，但它有著本質的區別：</p><ul><li><strong>SQL</strong> 操作的是**資料庫的表格 (Table) 與欄位 (Column)**。</li><li><strong>JPQL</strong> 操作的是 **JPA 的實體 (Entity) 與其屬性 (Property)**。</li></ul><p><strong>比較範例：</strong></p><ul><li><strong>SQL</strong>: <code>SELECT * FROM users WHERE username = &#39;alice&#39;</code></li><li><strong>JPQL</strong>: <code>SELECT u FROM User u WHERE u.username = &#39;alice&#39;</code></li></ul><p>請注意，JPQL 查詢的是 <code>User</code> 這個 <strong>Java 類別</strong>，並使用 <code>u.username</code> 這個<strong>類別屬性</strong>，而不是底層的 <code>users</code> 表格與 <code>username</code> 欄位。這使得 JPQL 具有<strong>資料庫獨立性</strong>，同樣的 JPQL 查詢可以執行在不同的資料庫上。</p><h2 id="使用-Query-與具名參數-推薦"><a href="#使用-Query-與具名參數-推薦" class="headerlink" title="使用 @Query 與具名參數 (推薦)"></a>使用 <code>@Query</code> 與具名參數 (推薦)</h2><p>具名參數 (Named Parameters) 是使用 <code>@Query</code> 時最推薦的方式，因為它可讀性高且不易出錯。</p><p>讓我們打開 <code>com.example.demoapp.repository.UserRepository.java</code> 介面，並加入新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他 import ...</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Query;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.query.Param;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 保留之前的方法 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用具名參數 (:nameOfParam)，可讀性高，推薦使用</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.username = :name AND u.age &gt;= :age&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUsersByUsernameAndAge</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String username, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ul><li><code>@Query(...)</code>：我們在此註解中直接撰寫 JPQL 語句。</li><li><code>:name</code> 和 <code>:age</code>：這是 JPQL 中的<strong>具名參數佔位符</strong>。</li><li><code>@Param(&quot;name&quot;)</code>：這個註解將方法的參數 <code>String username</code>，與 JPQL 中名為 <code>:name</code> 的佔位符進行綁定。使用 <code>@Param</code> 的好處是，方法參數的順序不再重要，程式碼更易於維護。</li></ul></li></ul><h2 id="使用-Query-與位置參數"><a href="#使用-Query-與位置參數" class="headerlink" title="使用 @Query 與位置參數"></a>使用 <code>@Query</code> 與位置參數</h2><p>除了具名參數，<code>@Query</code> 也支援傳統的位置參數 (Positional Parameters)，其佔位符格式為 <code>?</code> 後面跟著參數的順序（從 1 開始）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in UserRepository.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用位置參數 (?1, ?2)，參數順序必須嚴格對應</span></span><br><span class="line"><span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.username = ?1 AND u.age &gt;= ?2&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersByUsernameAndAgePositional</span><span class="params">(String username, Integer age)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<code>?1</code> 會被綁定到方法的第一個參數 <code>username</code>，<code>?2</code> 則被綁定到第二個參數 <code>age</code>。雖然這種寫法比較簡潔，但當參數一多，就很容易因順序變動而出錯，因此<strong>優先推薦使用具名參數</strong>。</li></ul><h2 id="執行修改與刪除操作-Modifying"><a href="#執行修改與刪除操作-Modifying" class="headerlink" title="執行修改與刪除操作 (@Modifying)"></a>執行修改與刪除操作 (<code>@Modifying</code>)</h2><p><code>@Query</code> 預設用於執行查詢 (SELECT) 操作。如果您希望執行會修改資料庫狀態的操作（如 <code>UPDATE</code> 或 <code>DELETE</code>），您必須額外加上 <code>@Modifying</code> 註解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in UserRepository.java</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Modifying;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query(&quot;UPDATE User u SET u.email = :newEmail WHERE u.id = :id&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateUserEmailById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;newEmail&quot;)</span> String email)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ul><li><code>@Modifying</code>：告知 Spring Data JPA，這是一個<strong>修改型</strong>的查詢，而不是一個查詢型的查詢。</li><li><code>int</code> 返回值：對於修改型的查詢，方法可以返回 <code>int</code> 或 <code>void</code>。返回 <code>int</code> 時，其值代表此次操作影響的紀錄筆數。</li><li><strong>重要提示</strong>：所有修改型的操作，都應該在一個交易 (Transaction) 中執行。我們通常會在呼叫此方法的 <code>Service</code> 層方法上，加上 <code>@Transactional</code> 註解。</li></ul></li></ul><h2 id="撰寫原生-SQL-查詢"><a href="#撰寫原生-SQL-查詢" class="headerlink" title="撰寫原生 SQL 查詢"></a>撰寫原生 SQL 查詢</h2><p>雖然 JPQL 能應對絕大多數場景，但有時您可能需要使用特定資料庫才有的函式，或是處理一些用 JPQL 極其複雜的查詢。此時，您也可以透過 <code>@Query</code> 來執行原生 SQL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in UserRepository.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原生 SQL 查詢，需將 nativeQuery 設為 true</span></span><br><span class="line"><span class="meta">@Query(value = &quot;SELECT * FROM users WHERE username LIKE %:keyword%&quot;, nativeQuery = true)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByUsernameWithNativeSql</span><span class="params">(<span class="meta">@Param(&quot;keyword&quot;)</span> String keyword)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ul><li><code>nativeQuery = true</code>：這是啟用原生 SQL 查詢的開關。</li><li><strong>注意語法</strong>：在原生 SQL 中，您必須使用實際的<strong>表格名稱 (<code>users</code>)</strong> 和<strong>欄位名稱</strong>，而不是 JPQL 的實體名稱 (<code>User</code>) 和屬性名稱。</li></ul></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們學會了如何使用 <code>@Query</code> 註解來突破查詢方法的限制，從而獲得對資料庫查詢的完全控制。</p><ul><li>我們理解了 <strong>JPQL</strong> 是基於<strong>實體與屬性</strong>的物件導向查詢語言。</li><li>我們掌握了使用<strong>具名參數</strong>（推薦）與<strong>位置參數</strong>來傳遞查詢條件。</li><li>我們學會了如何透過 <code>@Modifying</code> 註解來執行 <code>UPDATE</code> 或 <code>DELETE</code> 操作。</li><li>我們知道了如何在必要時，切換到<strong>原生 SQL</strong> 來應對特殊需求。</li></ul><p>我們已經掌握了各種單一表格的查詢技巧。然而，真實世界的資料模型是相互關聯的。在下一篇文章中，我們將探討 JPA 的核心概念之一——<strong>Entity 關聯</strong>，學習如何使用 <code>@OneToMany</code> 和 <code>@ManyToOne</code> 等註解來建立不同表格之間的關係。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 12 - 進階查詢方法 (Query Methods)</title>
      <link href="/2025/08/11/java-spring-boot-12/"/>
      <url>/2025/08/11/java-spring-boot-12/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：當-CRUD-不再足夠"><a href="#前言：當-CRUD-不再足夠" class="headerlink" title="前言：當 CRUD 不再足夠"></a>前言：當 CRUD 不再足夠</h2><p>在上一篇文章中，我們學會了使用 <code>JpaRepository</code> 內建的 <code>findById()</code>, <code>findAll()</code> 等方法來完成基礎的 CRUD 操作。這些方法非常實用，但真實世界的應用場景遠比這複雜。我們常常需要根據特定的條件來查詢資料，例如：</p><ul><li>根據「使用者名稱」找到唯一的使用者。</li><li>找出所有年齡大於 30 歲的使用者。</li><li>查詢 email 包含特定關鍵字的使用者。</li></ul><p>難道現在我們就必須開始手寫 JPQL 或原生 SQL 語句了嗎？答案是：還不用！Spring Data JPA 提供了一個極其強大且優雅的解決方案——**查詢方法 (Query Methods)<strong>，也稱為</strong>衍生查詢 (Derived Queries)**。</p><p>本篇文章將帶您學習如何僅僅透過在 Repository 介面中，定義符合特定命名規則的方法，就能讓 Spring Data JPA 為我們「自動」產生並執行對應的 SQL 查詢。</p><h2 id="查詢方法的核心機制"><a href="#查詢方法的核心機制" class="headerlink" title="查詢方法的核心機制"></a>查詢方法的核心機制</h2><p>Spring Data JPA 的查詢方法機制，就像是和框架之間的一種「約定」。您只要遵循它的命名慣例，它就能理解您的意圖。</p><p>這個慣例的基本結構是：<code>find...By...</code>、<code>read...By...</code>、<code>get...By...</code>，後面跟著您要查詢的<strong>實體屬性名稱</strong>，並可以組合各種<strong>條件關鍵字</strong>。</p><p>例如，<code>findByUsername(String username)</code> 這個方法名稱會被 Spring Data JPA 解析如下：</p><ol><li><code>find...By</code>：這是觸發查詢的關鍵字。</li><li><code>Username</code>：框架會將其解讀為 <code>User</code> 實體中的 <code>username</code> 屬性。</li><li><code>(...)</code>：方法的參數會被用作查詢條件的值。</li></ol><p>最終，框架會為我們產生一條類似 <code>SELECT * FROM users WHERE username = ?</code> 的 SQL 查詢。</p><h2 id="單一條件查詢"><a href="#單一條件查詢" class="headerlink" title="單一條件查詢"></a>單一條件查詢</h2><p>這是最簡單的用法。讓我們打開 <code>com.example.demoapp.repository.UserRepository.java</code> 介面，並在其中加入新的方法定義：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根據 username 查詢使用者</span></span><br><span class="line">    <span class="comment">// Spring Data JPA 會自動產生 &quot;WHERE username = ?&quot; 的查詢</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根據 email 查詢使用者</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findByEmail</span><span class="params">(String email)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就這麼簡單！我們只需要定義方法簽章，Spring Data JPA 會在執行階段自動提供實作。回傳值使用 <code>Optional&lt;User&gt;</code> 是一種良好的實踐，可以避免處理 <code>null</code> 的問題。</p><h2 id="多重條件查詢"><a href="#多重條件查詢" class="headerlink" title="多重條件查詢"></a>多重條件查詢</h2><p>您可以透過 <code>And</code> 與 <code>Or</code> 關鍵字來組合多個查詢條件。</p><p>繼續在 <code>UserRepository.java</code> 中加入以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... in UserRepository.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根據 username AND age 查詢 (AND 條件)</span></span><br><span class="line"><span class="comment">// WHERE username = ? AND age = ?</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByUsernameAndAge</span><span class="params">(String username, <span class="type">int</span> age)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根據 username OR email 查詢 (OR 條件)</span></span><br><span class="line"><span class="comment">// WHERE username = ? OR email = ?</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByUsernameOrEmail</span><span class="params">(String username, String email)</span>;</span><br></pre></td></tr></table></figure><p><strong>重要提示</strong>：方法的參數順序，必須與方法名稱中屬性出現的順序保持一致。</p><h2 id="更多常用查詢關鍵字"><a href="#更多常用查詢關鍵字" class="headerlink" title="更多常用查詢關鍵字"></a>更多常用查詢關鍵字</h2><p>Spring Data JPA 支援豐富的關鍵字，讓您可以建構出多樣化的查詢。</p><table><thead><tr><th align="left">關鍵字</th><th align="left">範例方法</th><th align="left">產生的 SQL (示意)</th></tr></thead><tbody><tr><td align="left"><code>GreaterThan</code></td><td align="left"><code>findByAgeGreaterThan(int age)</code></td><td align="left"><code>WHERE age &gt; ?</code></td></tr><tr><td align="left"><code>LessThanEqual</code></td><td align="left"><code>findByAgeLessThanEqual(int age)</code></td><td align="left"><code>WHERE age &lt;= ?</code></td></tr><tr><td align="left"><code>Between</code></td><td align="left"><code>findByAgeBetween(int start, int end)</code></td><td align="left"><code>WHERE age BETWEEN ? AND ?</code></td></tr><tr><td align="left"><code>IsNull</code>, <code>NotNull</code></td><td align="left"><code>findByEmailIsNull()</code></td><td align="left"><code>WHERE email IS NULL</code></td></tr><tr><td align="left"><code>Like</code>, <code>Containing</code></td><td align="left"><code>findByUsernameContaining(String keyword)</code></td><td align="left"><code>WHERE username LIKE &#39;%...%&#39;</code></td></tr><tr><td align="left"><code>StartingWith</code></td><td align="left"><code>findByUsernameStartingWith(String prefix)</code></td><td align="left"><code>WHERE username LIKE &#39;...%&#39;</code></td></tr><tr><td align="left"><code>In</code>, <code>NotIn</code></td><td align="left"><code>findByAgeIn(Collection&lt;Integer&gt; ages)</code></td><td align="left"><code>WHERE age IN (...)</code></td></tr><tr><td align="left"><code>OrderBy...Desc</code></td><td align="left"><code>findByAgeGreaterThanOrderByUsernameDesc(int age)</code></td><td align="left"><code>WHERE age &gt; ? ORDER BY username DESC</code></td></tr><tr><td align="left"><code>First</code>, <code>Top3</code></td><td align="left"><code>findTop3ByOrderByAgeAsc()</code></td><td align="left"><code>SELECT ... ORDER BY age ASC LIMIT 3</code></td></tr></tbody></table><h2 id="實際測試與應用"><a href="#實際測試與應用" class="headerlink" title="實際測試與應用"></a>實際測試與應用</h2><p>要測試這些方法，我們可以修改 <code>UserService</code> 和 <code>UserController</code> 為每一個方法都建立對應的 API。但有一個更適合在開發階段快速驗證的方法：使用 <code>CommandLineRunner</code>。</p><p><code>CommandLineRunner</code> 是一個特殊的 Spring Boot 元件，它的 <code>run</code> 方法會在應用程式啟動完成後自動執行一次，非常適合用來初始化資料或執行測試腳本。</p><ol><li><p><strong>修改 <code>User</code> Entity</strong><br>為了方便建立測試資料，請先到 <code>entity/User.java</code> 中，加入 <code>@NoArgsConstructor</code> 與 <code>@AllArgsConstructor</code> 註解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in entity/User.java</span></span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">// 新增無參數建構子</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">// 新增包含所有參數的建構子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在主應用程式中加入 <code>CommandLineRunner</code></strong><br>打開主程式 <code>DemoAppApplication.java</code>，並加入以下 <code>@Bean</code> 定義：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoAppApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoAppApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommandLineRunner <span class="title function_">demo</span><span class="params">(UserRepository repository)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (args) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 建立一些測試資料</span></span><br><span class="line">            System.out.println(<span class="string">&quot;--- 儲存測試資料 ---&quot;</span>);</span><br><span class="line">            repository.save(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;alice@example.com&quot;</span>, <span class="number">30</span>));</span><br><span class="line">            repository.save(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;bob@example.com&quot;</span>, <span class="number">25</span>));</span><br><span class="line">            repository.save(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;Carol&quot;</span>, <span class="string">&quot;carol@example.com&quot;</span>, <span class="number">35</span>));</span><br><span class="line">            repository.save(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;david@example.com&quot;</span>, <span class="number">25</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 測試查詢方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;\n--- 尋找 username 為 Bob 的使用者 ---&quot;</span>);</span><br><span class="line">            repository.findByUsername(<span class="string">&quot;Bob&quot;</span>).ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;\n--- 尋找年齡大於 28 歲的使用者，並按使用者名稱降序排列 ---&quot;</span>);</span><br><span class="line">            repository.findByAgeGreaterThanOrderByUsernameDesc(<span class="number">28</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;\n--- 尋找年齡為 25 歲的使用者 ---&quot;</span>);</span><br><span class="line">            repository.findByUsernameAndAge(<span class="string">&quot;David&quot;</span>, <span class="number">25</span>).forEach(System.out::println);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>現在，重新啟動您的應用程式。您將在主控台中看到資料被存入，以及我們定義的查詢被執行後的結果。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們領略了 Spring Data JPA 查詢方法的強大與優雅。</p><ul><li>我們學會了如何遵循<strong>命名慣例</strong>，在 Repository 介面中定義方法來執行查詢。</li><li>我們掌握了使用 <code>And</code>, <code>Or</code>, <code>GreaterThan</code>, <code>Containing</code>, <code>OrderBy</code> 等關鍵字來建構複雜的查詢條件。</li><li>我們利用 <code>CommandLineRunner</code> 在應用程式啟動時方便地進行了測試。</li></ul><p>查詢方法能夠滿足絕大多數的查詢需求，並且提供了極佳的可讀性與類型安全。然而，當查詢邏輯變得極度複雜（例如包含複雜的 JOIN 或子查詢）時，方法名稱可能會變得過於冗長。</p><p>在下一篇文章中，我們將學習如何使用 <strong><code>@Query</code></strong> 註解，直接在 Repository 中撰寫 JPQL，從而完全掌控我們的資料庫查詢。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 11 - JpaRepository 與 CRUD 操作</title>
      <link href="/2025/08/11/java-spring-boot-11/"/>
      <url>/2025/08/11/java-spring-boot-11/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：告別手寫-SQL"><a href="#前言：告別手寫-SQL" class="headerlink" title="前言：告別手寫 SQL"></a>前言：告別手寫 SQL</h2><p>在上一篇文章中，我們成功地建立了一個 <code>User</code> 實體並在 H2 資料庫中產生了對應的 <code>users</code> 表格。現在，表格已經備妥，但我們該如何與它互動？難道我們需要像過去一樣，手動編寫繁瑣的 JDBC 連線程式碼和 SQL 語句來進行資料的增、刪、改、查嗎？</p><p>答案是：完全不需要！這正是 Spring Data JPA 最令人驚豔的地方。它提供了一個名為「<strong>Repository</strong>」的設計模式，讓我們能夠以操作 Java 集合般的方式來管理資料庫中的資料。</p><p>本篇文章將帶您建立一個 <code>JpaRepository</code> 介面，並探索如何僅僅透過呼叫其內建的方法，就優雅地完成所有基礎的 CRUD (Create, Read, Update, Delete) 操作，而無需撰寫任何一行 SQL 程式碼。</p><h2 id="步驟一：建立-Repository-介面"><a href="#步驟一：建立-Repository-介面" class="headerlink" title="步驟一：建立 Repository 介面"></a>步驟一：建立 Repository 介面</h2><p><strong>Repository</strong> 在軟體設計中扮演著「倉儲」的角色，它封裝了對資料來源的存取邏輯，讓我們的業務邏輯層無需關心底層的資料庫實現細節。</p><ol><li><p><strong>建立介面檔案</strong><br>在 <code>com.example.demoapp.repository</code> 這個套件下，建立一個**新的 Java 介面 (Interface)**，並命名為 <code>UserRepository.java</code>。</p></li><li><p><strong>繼承 JpaRepository</strong><br>讓這個新介面繼承 Spring Data JPA 提供的 <code>JpaRepository</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserRepository.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.demoapp.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 1. 標示這是一個 Repository Bean，交由 Spring 管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123; <span class="comment">// 2. 繼承 JpaRepository</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 裡面什麼都不用寫！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>程式碼詳解</strong>：<ol><li><code>@Repository</code>：我們使用這個註解將 <code>UserRepository</code> 標示為一個資料存取層的 Bean，交由 Spring IoC 容器管理。</li><li><code>extends JpaRepository&lt;User, Long&gt;</code>：<strong>這是所有魔法的來源</strong>。<ul><li><code>JpaRepository</code> 是一個泛型介面，我們需要提供兩個類型參數。</li><li>第一個 <code>User</code>：代表這個 Repository 所要管理的<strong>實體 (Entity) 類型</strong>。</li><li>第二個 <code>Long</code>：代表這個實體的主鍵 (<code>@Id</code>) 的<strong>資料類型</strong>。</li></ul></li><li><strong>空介面</strong>：我們不需要在介面中撰寫任何方法。僅僅是透過繼承 <code>JpaRepository</code>，<code>UserRepository</code> 就已經立刻擁有了一整套現成的 CRUD 方法，例如 <code>save()</code>, <code>findById()</code>, <code>findAll()</code>, <code>deleteById()</code> 等。Spring Data JPA 會在應用程式啟動時，自動為我們提供這個介面的實作。</li></ol></li></ul><h2 id="步驟二：在-Service-層中使用-Repository"><a href="#步驟二：在-Service-層中使用-Repository" class="headerlink" title="步驟二：在 Service 層中使用 Repository"></a>步驟二：在 Service 層中使用 Repository</h2><p>現在，讓我們將這個強大的 <code>UserRepository</code> 注入到我們的 <code>UserService</code> 中，並用它來取代之前模擬的日誌輸出。</p><p>修改 <code>com.example.demoapp.service.UserService.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.dto.CreateUserRequest;</span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C: Create</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(CreateUserRequest request)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(request.getUsername());</span><br><span class="line">        user.setEmail(request.getEmail());</span><br><span class="line">        user.setAge(request.getAge());</span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R: Read</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// U: Update</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUser</span><span class="params">(Long id, CreateUserRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// findById 回傳的是 Optional，.orElseThrow() 表示如果找不到就拋出例外</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">userToUpdate</span> <span class="operator">=</span> userRepository.findById(id)</span><br><span class="line">                .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;User not found with id: &quot;</span> + id));</span><br><span class="line"></span><br><span class="line">        userToUpdate.setUsername(request.getUsername());</span><br><span class="line">        userToUpdate.setEmail(request.getEmail());</span><br><span class="line">        userToUpdate.setAge(request.getAge());</span><br><span class="line">        <span class="keyword">return</span> userRepository.save(userToUpdate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// D: Delete</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        userRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：我們為使用者新增了完整的 CRUD 業務邏輯，並全部是透過呼叫 <code>userRepository</code> 的內建方法來完成。注意 <code>findById</code> 會回傳一個 <code>Optional&lt;User&gt;</code>，這是 Java 8 的特性，用於優雅地處理可能為 <code>null</code> 的情況。</li></ul><h2 id="步驟三：在-Controller-中暴露-CRUD-API"><a href="#步驟三：在-Controller-中暴露-CRUD-API" class="headerlink" title="步驟三：在 Controller 中暴露 CRUD API"></a>步驟三：在 Controller 中暴露 CRUD API</h2><p>最後，我們需要修改 <code>UserController</code>，讓外部可以透過 API 來觸發這些 CRUD 操作。</p><p>修改 <code>com.example.demoapp.controller.UserController.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他 import ...</span></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略 userService 的注入 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 保留 @PostMapping(&quot;/users&quot;) 的 createUser 方法 ...</span></span><br><span class="line">    <span class="comment">// 但我們可以優化它，讓它回傳新建的 User 物件</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> CreateUserRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.createUser(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserById(id)</span><br><span class="line">                .map(ResponseEntity::ok) <span class="comment">// 如果找得到，回傳 200 OK 與 User 物件</span></span><br><span class="line">                .orElse(ResponseEntity.notFound().build()); <span class="comment">// 如果找不到，回傳 404 Not Found</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getAllUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@RequestBody</span> CreateUserRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.updateUser(id, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        userService.deleteUser(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build(); <span class="comment">// 回傳 204 No Content 表示成功刪除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步驟四：實際測試-CRUD"><a href="#步驟四：實際測試-CRUD" class="headerlink" title="步驟四：實際測試 CRUD"></a>步驟四：實際測試 CRUD</h2><p>現在，啟動您的應用程式，並使用 API 測試軟體（如 Postman）來驗證我們的成果：</p><ol><li><strong>新增使用者</strong>：發送 <code>POST</code> 請求到 <code>http://localhost:8080/users</code>，本文為 <code>&#123;&quot;username&quot;: &quot;testuser&quot;, &quot;email&quot;: &quot;test@example.com&quot;, &quot;age&quot;: 25&#125;</code>。</li><li><strong>查詢所有使用者</strong>：發送 <code>GET</code> 請求到 <code>http://localhost:8080/users</code>，您應能看到剛才建立的使用者。</li><li><strong>查詢特定使用者</strong>：發送 <code>GET</code> 請求到 <code>http://localhost:8080/users/1</code> (假設 ID 為 1)。</li><li><strong>更新使用者</strong>：發送 <code>PUT</code> 請求到 <code>http://localhost:8080/users/1</code>，本文為 <code>&#123;&quot;username&quot;: &quot;updateduser&quot;, &quot;email&quot;: &quot;updated@example.com&quot;, &quot;age&quot;: 30&#125;</code>。</li><li><strong>刪除使用者</strong>：發送 <code>DELETE</code> 請求到 <code>http://localhost:8080/users/1</code>。</li><li><strong>驗證刪除</strong>：再次發送 <code>GET</code> 請求到 <code>http://localhost:8080/users</code>，列表應為空。</li></ol><p>在任何步驟，您都可以登入 <strong>H2 Console</strong> (<code>http://localhost:8080/h2-console</code>) 來即時查看資料庫中的變化。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們見證了 Spring Data JPA 的驚人威力。</p><ul><li>我們僅僅透過<strong>定義一個介面</strong>並**繼承 <code>JpaRepository</code>**，就獲得了一整套功能完備的資料庫操作方法。</li><li>我們學會了如何在 Service 層中呼叫這些內建方法，來實現完整的 CRUD 功能。</li><li>我們完全<strong>沒有手寫任何一行 SQL 語句</strong>，就完成了所有資料庫的互動。</li></ul><p>這種高度的抽象化讓開發者可以更專注於業務邏輯本身，而不是陷入繁瑣的資料存取程式碼中。</p><p>內建的 CRUD 方法非常方便，但真實世界的查詢需求遠不止於此。我們可能需要根據使用者名稱、Email 或其他多個條件來查詢。在下一篇文章中，我們將學習 Spring Data JPA 更強大的功能——如何<strong>透過定義方法名稱來自動產生各種複雜的查詢</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 10 - 整合 H2 資料庫與 JPA Entity</title>
      <link href="/2025/08/11/java-spring-boot-10/"/>
      <url>/2025/08/11/java-spring-boot-10/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：讓資料被永久保存"><a href="#前言：讓資料被永久保存" class="headerlink" title="前言：讓資料被永久保存"></a>前言：讓資料被永久保存</h2><p>到目前為止，我們的應用程式已經具備了 API、日誌和文件，但它有一個致命的缺陷：所有資料都只存在於記憶體中。一旦應用程式重新啟動，我們之前透過 API 建立的所有使用者資訊都會消失。為了解決這個問題，我們需要引入<strong>資料持久化 (Data Persistence)</strong> 的概念，也就是將資料儲存到資料庫中。</p><p>本篇文章將帶您進入 Spring Boot 的資料庫整合世界。我們將介紹幾個關鍵技術：</p><ul><li>**JPA (Java Persistence API)**：一套 Java 官方制定的 ORM (物件關聯對映) 標準規範，它定義了如何將 Java 物件對映到關聯式資料庫的表格中。</li><li><strong>Hibernate</strong>：JPA 規範底下最流行、功能最強大的<strong>實現框架</strong>。Spring Boot 預設使用 Hibernate 作為其 JPA 的實現。</li><li><strong>Spring Data JPA</strong>：Spring 提供的一個模組，它在 JPA 的基礎上再次進行封裝，極大地簡化了資料庫存取層的開發。</li><li><strong>H2 Database</strong>：一個用 Java 編寫的輕量級<strong>記憶體資料庫</strong>。它非常適合在開發和測試階段使用，因為它無需安裝、設定簡單，並且會隨著應用程式的啟動而執行。</li></ul><p>我們的目標是：整合這些技術，並建立我們的第一個**實體 (Entity)**——一個能對應到資料庫表格的 Java 類別。</p><h2 id="步驟一：加入必要的-Maven-相依性"><a href="#步驟一：加入必要的-Maven-相依性" class="headerlink" title="步驟一：加入必要的 Maven 相依性"></a>步驟一：加入必要的 Maven 相依性</h2><p>首先，我們需要告訴 Maven 我們的專案需要 JPA 和 H2 資料庫的功能。</p><p>打開專案根目錄下的 <code>pom.xml</code> 檔案，在 <code>&lt;dependencies&gt;</code> 區塊中，加入以下兩段依賴：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>spring-boot-starter-data-jpa</code>：這個起步依賴會為我們引入所有需要的 JPA API、Spring Data JPA 函式庫以及預設的 Hibernate 實現。</li><li><code>h2</code>：這個依賴引入了 H2 資料庫的驅動程式與引擎。Spring Boot 非常智慧，當它在 classpath 上偵測到 H2 時，會自動為我們設定一個記憶體資料庫的連線。</li></ul><h2 id="步驟二：設定-H2-資料庫連線"><a href="#步驟二：設定-H2-資料庫連線" class="headerlink" title="步驟二：設定 H2 資料庫連線"></a>步驟二：設定 H2 資料庫連線</h2><p>雖然 Spring Boot 會自動設定，但明確地寫出設定並啟用 H2 的網頁主控台，對於開發與學習非常有幫助。</p><p>打開 <code>src/main/resources/application.properties</code> 檔案，並加入以下設定：<br>(若您使用 <code>application.yml</code>，請轉換為對應的 YML 格式)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># H2 Database Console Settings</span></span><br><span class="line"><span class="comment"># 啟用 H2 的網頁版主控台</span></span><br><span class="line"><span class="attr">spring.h2.console.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 設定 H2 主控台的訪問路徑</span></span><br><span class="line"><span class="attr">spring.h2.console.path</span>=<span class="string">/h2-console</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># DataSource Settings (資料來源設定)</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:h2:mem:testdb</span></span><br><span class="line"><span class="attr">spring.datasource.driverClassName</span>=<span class="string">org.h2.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># JPA/Hibernate Settings</span></span><br><span class="line"><span class="comment"># 告訴 Hibernate 我們使用的是 H2 資料庫的方言 (Dialect)</span></span><br><span class="line"><span class="attr">spring.jpa.database-platform</span>=<span class="string">org.hibernate.dialect.H2Dialect</span></span><br><span class="line"><span class="comment"># 這是最重要的設定之一：讓 Hibernate 在啟動時自動更新資料庫綱要 (Schema)</span></span><br><span class="line"><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span></span><br><span class="line"><span class="comment"># 在主控台顯示 Hibernate 執行的 SQL 語句，方便除錯</span></span><br><span class="line"><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><ul><li>**<code>spring.jpa.hibernate.ddl-auto=update</code>**：這個設定告訴 Hibernate，在應用程式啟動時，自動檢查您的 Entity 類別與資料庫表格的差異，並試圖更新表格結構（例如新增欄位）。在開發階段這非常方便。</li></ul><h2 id="步驟三：建立您的第一個-Entity"><a href="#步驟三：建立您的第一個-Entity" class="headerlink" title="步驟三：建立您的第一個 Entity"></a>步驟三：建立您的第一個 Entity</h2><p><strong>實體 (Entity)</strong> 是一個特殊的 Java 類別 (POJO)，它被 JPA 標示，用於映射資料庫中的一張表格。類別的每一個實例，就對應著表格中的一筆紀錄。</p><ol><li><p>在 <code>com.example.demoapp</code> 下建立新套件 <code>entity</code>。</p></li><li><p>在 <code>entity</code> 套件中，建立新檔案 <code>User.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.persistence.*;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span> <span class="comment">// 1. 告訴 JPA，這是一個需要被持久化的實體類別</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span> <span class="comment">// 2. 指定對應的資料庫表格名稱為 &quot;users&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">// 3. 標示這個屬性是表格的主鍵 (Primary Key)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">// 4. 設定主鍵的生成策略為「自動遞增」</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;username&quot;, nullable = false, unique = true, length = 50)</span> <span class="comment">// 5. 映射到表格的欄位</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;email&quot;, nullable = false, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age; <span class="comment">// 6. 若無 @Column，預設會使用屬性名稱 &quot;age&quot; 作為欄位名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li><strong>註解詳解</strong>：<ul><li><code>@Entity</code>: 最核心的註解，宣告這是一個 JPA 實體。</li><li><code>@Table</code>: 指定這個實體對應到資料庫中的哪一張表格。</li><li><code>@Id</code>: 指定哪個屬性是這張表格的主鍵。</li><li><code>@GeneratedValue</code>: 定義主鍵值的生成方式。<code>IDENTITY</code> 策略表示將生成工作交給資料庫的自動遞增機制來處理。</li><li><code>@Column</code>: 將屬性對應到表格的特定欄位，並可以定義其屬性，如名稱 (<code>name</code>)、是否允許為空 (<code>nullable</code>)、是否唯一 (<code>unique</code>)、長度 (<code>length</code>) 等。</li></ul></li></ul><h2 id="步驟四：驗證成果：H2-Console"><a href="#步驟四：驗證成果：H2-Console" class="headerlink" title="步驟四：驗證成果：H2 Console"></a>步驟四：驗證成果：H2 Console</h2><p>現在，讓我們來驗證我們的設定是否成功。</p><ol><li><strong>啟動應用程式</strong>。</li><li><strong>觀察主控台日誌</strong>：由於我們設定了 <code>spring.jpa.show-sql=true</code>，您應該能在啟動日誌中找到由 Hibernate 自動產生的 <code>create table users ...</code> SQL 語句。這證明了 JPA 已經成功讀取您的 <code>User</code> 實體並建立了對應的表格。</li><li><strong>訪問 H2 Console</strong>：打開瀏覽器，訪問 <code>http://localhost:8080/h2-console</code>。</li><li><strong>登入資料庫</strong>：<ul><li>確認 <code>JDBC URL</code> 欄位的值是 <code>jdbc:h2:mem:testdb</code>，這必須與您在 <code>application.properties</code> 中設定的完全一致。</li><li>使用者名稱為 <code>sa</code>，密碼留空。</li><li>點擊 <strong>Connect</strong>。</li></ul></li><li><strong>檢視表格</strong>：登入後，您會在左側的導覽列中看到我們剛剛建立的 <code>USERS</code> 表格。您可以點開它查看欄位，或是在右側的 SQL 輸入框中執行 <code>SELECT * FROM USERS;</code> 來確認表格確實存在。</li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們成功地將資料庫整合進了我們的專案，並跨出了資料持久化的第一步。</p><ul><li>我們加入了 <code>Spring Data JPA</code> 和 <code>H2</code> 的相依性。</li><li>我們設定了資料庫連線，並啟用了方便的 H2 Console。</li><li>我們學會了如何使用 <code>@Entity</code> 及相關註解，將一個 Java 類別映射到資料庫的表格中。</li></ul><p>我們的應用程式現在有了一張 <code>users</code> 表格，但我們要如何對它進行操作呢？在下一篇文章中，我們將學習 Spring Data JPA 的核心元件——**<code>JpaRepository</code>**，並體驗如何在不寫一行 SQL 的情況下，輕鬆實現對資料庫的增、刪、改、查 (CRUD) 操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 09 - 整合 OpenAPI (Swagger) 產生 API 文件</title>
      <link href="/2025/08/11/java-spring-boot-09/"/>
      <url>/2025/08/11/java-spring-boot-09/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：告別手寫-API-文件"><a href="#前言：告別手寫-API-文件" class="headerlink" title="前言：告別手寫 API 文件"></a>前言：告別手寫 API 文件</h2><p>在團隊協作或前後端分離的開發模式中，一份清晰、準確且即時更新的 API 文件至關重要。然而，手動維護 API 文件是一件極其繁瑣且容易出錯的工作，常常導致文件與實際程式碼不一致，造成溝通上的巨大成本。</p><p>為了解決這個痛點，業界的主流做法是「由程式碼自動產生文件」。Spring Boot 生態系中，最受歡迎的解決方案就是整合 OpenAPI (前身為 Swagger)。</p><p>本篇文章將帶您學習如何將 <code>springdoc-openapi</code> 這個強大的函式庫整合進我們的專案中。它能夠在應用程式啟動時，自動掃描您的 Controller，產生一份符合 OpenAPI 3 標準的 API 規格，並透過內建的 Swagger UI 提供一個美觀、可互動的文件頁面。</p><h2 id="OpenAPI-與-Swagger-的關係"><a href="#OpenAPI-與-Swagger-的關係" class="headerlink" title="OpenAPI 與 Swagger 的關係"></a>OpenAPI 與 Swagger 的關係</h2><p>初學者常常對這兩個名詞感到困惑，讓我們先快速釐清它們的關係：</p><ol><li><p><strong>OpenAPI Specification (OAS)<strong>：它是一個</strong>行業標準、一種規格</strong>。它定義了一套與程式語言無關的規則，用來描述 RESTful API 的結構（如端點、參數、回應等），通常以 <code>JSON</code> 或 <code>YAML</code> 格式呈現。</p></li><li><p><strong>Swagger</strong>：它是一套圍繞著 OpenAPI 規格的<strong>工具集</strong>。其中最知名的工具就是 <strong>Swagger UI</strong>，它能夠讀取一份 OpenAPI 規格檔案，並將其渲染成一個漂亮的網頁，讓開發者可以直觀地瀏覽、理解甚至直接在頁面上測試 API。</p></li><li><p><strong><code>springdoc-openapi</code><strong>：這是我們將要使用的</strong>函式庫</strong>。它的核心任務就是<strong>自動產生</strong>那份符合 OpenAPI 3 標準的規格檔案。</p></li></ol><p>簡單來說：<code>springdoc-openapi</code> 讀取您的 Spring Boot 程式碼 -&gt; 產生 OpenAPI 規格 -&gt; Swagger UI 讀取規格並呈現給您。</p><h2 id="整合-springdoc-openapi"><a href="#整合-springdoc-openapi" class="headerlink" title="整合 springdoc-openapi"></a>整合 <code>springdoc-openapi</code></h2><p>將 OpenAPI 整合到 Spring Boot 專案中，過程出乎意料地簡單。</p><ol><li><p><strong>加入 Maven 相依性</strong><br>打開專案根目錄下的 <code>pom.xml</code> 檔案，在 <code>&lt;dependencies&gt;</code> 區塊中，加入以下這段依賴：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：您可以到 <a href="https://search.maven.org/artifact/org.springdoc/springdoc-openapi-starter-webmvc-ui">Maven 中央倉庫</a> 查詢最新的 <code>version</code>。</p></blockquote><p>這個 <code>springdoc-openapi-starter-webmvc-ui</code> 相依性已經包含了產生規格所需的核心函式庫，以及 Swagger UI 的所有網頁資源。</p></li><li><p><strong>大功告成！</strong><br>是的，你沒看錯。對於基本的文件產生，您<strong>不需要撰寫任何額外的 Java 程式碼</strong>。</p></li></ol><h2 id="啟動並探索-API-文件"><a href="#啟動並探索-API-文件" class="headerlink" title="啟動並探索 API 文件"></a>啟動並探索 API 文件</h2><ol><li><p><strong>啟動應用程式</strong><br>像往常一樣，啟動您的 Spring Boot 應用程式。</p></li><li><p><strong>訪問 Swagger UI</strong><br>打開您的網頁瀏覽器，訪問以下這個新的網址：<br><code>http://localhost:8080/swagger-ui.html</code></p><p>您將會看到一個專業的 API 文件頁面。<code>springdoc</code> 已經自動偵測到了我們之前建立的 <code>HelloController</code> 和 <code>UserController</code>，並將它們的 API 端點都列了出來。</p></li><li><p><strong>互動與測試</strong></p><ul><li>點開任何一個 API（例如 <code>POST /users</code>），您可以看到詳細的參數資訊、請求本文的範例格式等。</li><li>點擊右上角的 <strong>“Try it out”</strong> 按鈕，Swagger UI 會提供一個可輸入的介面，讓您直接在頁面上填寫參數、發送請求並查看真實的回應。這是一個極其強大的內建測試工具。</li></ul></li></ol><h2 id="使用註解豐富您的-API-文件"><a href="#使用註解豐富您的-API-文件" class="headerlink" title="使用註解豐富您的 API 文件"></a>使用註解豐富您的 API 文件</h2><p>自動產生的文件雖然方便，但缺乏詳細的文字描述。我們可以透過加入特定的註解，讓文件內容更加豐富易讀。</p><p>讓我們來修改 <code>UserController.java</code>，為它加上更詳細的說明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.dto.CreateUserRequest;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.Operation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.tags.Tag;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;使用者 API&quot;, description = &quot;提供使用者相關的 CRUD 操作&quot;)</span> <span class="comment">// 1. 為 Controller 加上標籤</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 userService 的注入 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;建立新使用者&quot;, description = &quot;根據傳入的使用者資訊建立一個新的使用者&quot;)</span> <span class="comment">// 2. 為方法加上操作說明</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> CreateUserRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 省略業務邏輯 ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;使用者 &quot;</span> + request.getUsername() + <span class="string">&quot; 建立成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：<ol><li><code>@Tag</code>：在類別上使用，可以將這個 Controller 下的所有 API 歸類到一個指定的標籤（Tag）下，並加上描述。</li><li><code>@Operation</code>：在方法上使用，可以為這個特定的 API 端點提供簡短的 <code>summary</code> 和更詳細的 <code>description</code>。</li></ol></li></ul><p>現在，重新啟動您的應用程式並刷新 Swagger UI 頁面，您會發現文件的標題和描述都已經更新，變得更加清晰易懂。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們學會了如何透過一個簡單的 Maven 相依性，就為我們的專案整合了強大的自動化 API 文件功能。</p><ul><li>我們釐清了 OpenAPI、Swagger 與 <code>springdoc-openapi</code> 之間的關係。</li><li>我們僅用一步就產生了基礎的互動式 API 文件。</li><li>我們學會了使用 <code>@Tag</code> 和 <code>@Operation</code> 等註解來豐富文件內容，使其更具可讀性。</li></ul><p>維持 API 文件的同步與準確性是專業後端開發的重要一環。掌握這項技能，將能大幅提升您與團隊成員（特別是前端工程師）的協作效率。</p><p>我們已經為應用程式加上了專業的日誌與 API 文件。接下來，我們將正式進入後端開發的核心——<strong>資料庫操作</strong>。在下一篇文章中，我們將學習如何整合 JPA，並將我們的 Java 物件映射到資料庫表格中，讓資料能夠被永久保存。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 08 - 整合 Logback 進行日誌管理</title>
      <link href="/2025/08/11/java-spring-boot-08/"/>
      <url>/2025/08/11/java-spring-boot-08/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：讓日誌為我們所用"><a href="#前言：讓日誌為我們所用" class="headerlink" title="前言：讓日誌為我們所用"></a>前言：讓日誌為我們所用</h2><p>在上一篇文章中，我們學會了使用 Lombok 的 <code>@Slf4j</code> 註解，輕鬆地在程式碼中加入了日誌記錄。當我們執行應用時，這些日誌訊息會直接顯示在主控台 (Console) 上。然而，在真實的專案開發與維護中，這遠遠不夠。我們需要回答以下問題：</p><ul><li>如何控制日誌的<strong>輸出格式</strong>，讓資訊更清晰？</li><li>如何設定日誌的**輸出級別 (Level)**，例如在開發時顯示詳細資訊，在生產環境只記錄錯誤？</li><li>如何將日誌<strong>輸出到檔案</strong>中，以便長期保存與事後分析？</li></ul><p>本篇文章將帶您深入 Spring Boot 預設的日誌框架——<strong>Logback</strong>，學習如何透過設定檔來精準地控制日誌的每一個環節，讓日誌從簡單的螢幕輸出，變成強大且可靠的診斷工具。</p><h2 id="SLF4J-與-Logback：門面與實現的關係"><a href="#SLF4J-與-Logback：門面與實現的關係" class="headerlink" title="SLF4J 與 Logback：門面與實現的關係"></a>SLF4J 與 Logback：門面與實現的關係</h2><p>在開始設定之前，理解 SLF4J 和 Logback 之間的關係至關重要。</p><ol><li><p><strong>SLF4J (Simple Logging Facade for Java)<strong>：它是一個「</strong>日誌門面 (Facade)<strong>」或稱為「</strong>日誌 API</strong>」。我們的應用程式程式碼（包括由 <code>@Slf4j</code> 產生的程式碼）只會和 SLF4J 的標準介面互動。這樣做的好處是，我們的程式碼與任何特定的日誌函式庫實現解耦，未來可以輕易地替換底層的日誌框架。</p></li><li><p><strong>Logback</strong>：它是一個「**日誌實現 (Implementation)**」。它是真正負責處理日誌格式化、篩選和輸出的引擎。Logback 是 Log4j 專案的繼任者，擁有更快的效能和更豐富的功能。</p></li></ol><p><strong>Spring Boot 的選擇</strong>：<code>spring-boot-starter-logging</code>（它被 <code>spring-boot-starter-web</code> 等多數 Starter 預設包含）已經為我們整合了 <strong>SLF4J + Logback</strong> 的組合。這就是為什麼我們一開箱就能使用日誌功能的原因。</p><h2 id="Spring-Boot-的預設日誌設定"><a href="#Spring-Boot-的預設日誌設定" class="headerlink" title="Spring Boot 的預設日誌設定"></a>Spring Boot 的預設日誌設定</h2><p>在沒有任何客製化設定檔的情況下，Spring Boot 提供了一套預設的日誌行為：</p><ul><li><strong>輸出位置</strong>：僅輸出到主控台。</li><li><strong>預設級別</strong>：<code>INFO</code>。這意味著只有 <code>INFO</code>, <code>WARN</code>, <code>ERROR</code> 級別的日誌會被顯示，而 <code>DEBUG</code> 和 <code>TRACE</code> 級別的日誌會被忽略。</li><li><strong>預設格式</strong>：包含了時間、級別、程序 ID、執行緒名稱、Logger 名稱和日誌訊息。</li></ul><p>對於簡單的級別調整，我們可以透過 <code>application.properties</code> 或 <code>application.yml</code> 來快速設定：</p><p><strong><code>application.yml</code> 範例：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># 設定根日誌級別為 WARN</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">WARN</span></span><br><span class="line">    <span class="comment"># 將我們自己應用程式的套件級別設為 DEBUG，以便開發時查看更詳細的日誌</span></span><br><span class="line">    <span class="attr">com.example.demoapp:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><p>然而，若要進行更複雜的設定，例如定義輸出格式或輸出到檔案，我們就需要建立專屬的設定檔。</p><h2 id="使用-logback-spring-xml-進行進階設定"><a href="#使用-logback-spring-xml-進行進階設定" class="headerlink" title="使用 logback-spring.xml 進行進階設定"></a>使用 <code>logback-spring.xml</code> 進行進階設定</h2><p>Spring Boot 會自動偵測並載入位於 <code>src/main/resources</code> 目錄下的 <code>logback-spring.xml</code> 檔案，作為 Logback 的進階設定。</p><ol><li><p><strong>建立設定檔</strong><br>在 <code>src/main/resources</code> 目錄下，建立一個新檔案，並命名為 <code>logback-spring.xml</code>。</p></li><li><p><strong>貼上並理解設定內容</strong><br>以下是一個功能完整且適用於生產環境的設定範本，它同時將日誌輸出到主控台和滾動的日誌檔案中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;logs&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%15.15thread] %-5level %-40.40logger&#123;39&#125; : %msg%n&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/demo-app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/demo-app-%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.example.demoapp&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><!-- end list --><ul><li><strong>設定檔詳解</strong>：<ul><li>**<code>Appender</code>**：定義了一個日誌的輸出目的地。<code>CONSOLE</code> 指向主控台，<code>FILE</code> 指向滾動檔案。</li><li>**<code>Encoder</code> 與 <code>Pattern</code>**：定義了日誌的輸出格式。<code>%d</code> 是日期，<code>%thread</code> 是執行緒名，<code>%-5level</code> 是日誌級別，<code>%logger</code> 是 Logger 名稱，<code>%msg</code> 是日誌訊息，<code>%n</code> 是換行符。</li><li>**<code>RollingPolicy</code>**：這是檔案輸出的核心策略。<code>TimeBasedRollingPolicy</code> 表示根據時間來滾動日誌，範例中設定為每天產生一個新的日誌歸檔檔案，並最多保留 30 天。</li><li>**<code>root</code>**：根 Logger，是所有 Logger 的祖先。這裡設定預設級別為 <code>INFO</code>，並將日誌同時輸出到 <code>CONSOLE</code> 和 <code>FILE</code>。</li><li>**<code>logger</code>**：針對特定套件設定更詳細的日誌級別。範例中，我們為自己的應用程式套件 <code>com.example.demoapp</code> 設定了 <code>DEBUG</code> 級別，以便在開發時看到更詳細的資訊。</li></ul></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們完成了從「會用日誌」到「會管理日誌」的進階。</p><ul><li>我們理解了 SLF4J 作為「門面」與 Logback 作為「實現」的合作關係。</li><li>我們學會了使用 <code>application.yml</code> 進行快速的日誌級別設定。</li><li>我們掌握了如何建立一個功能強大的 <code>logback-spring.xml</code>，來客製化日誌的輸出格式、級別，並實現了將日誌輸出到主控台與滾動檔案兩種目的地。</li></ul><p>為應用程式加上專業的日誌管理，是確保其在開發與生產環境中都易於追蹤與維護的基石。接下來，我們將正式進入後端開發的核心——<strong>資料庫操作</strong>。在下一篇文章中，我們將學習如何整合 JPA，並將我們的 Java 物件映射到資料庫表格中。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 07 - Lombok 深度應用</title>
      <link href="/2025/08/11/java-spring-boot-07/"/>
      <url>/2025/08/11/java-spring-boot-07/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：超越-Data-的精細控制"><a href="#前言：超越-Data-的精細控制" class="headerlink" title="前言：超越 @Data 的精細控制"></a>前言：超越 <code>@Data</code> 的精細控制</h2><p>在之前的文章中，我們已經在 DTO (資料傳輸物件) 中體驗了 <code>@Data</code> 註解的便利性，它能為我們自動產生大量的樣板程式碼 (boilerplate code)。然而，<code>@Data</code> 是一個功能強大的「組合包」，有時它的功能過於廣泛，並不完全符合我們的需求。</p><p>例如，我們可能只希望物件的屬性是可讀的（有 getter），但不可寫的（沒有 setter），以確保物件的不可變性。或者，我們想要一個更優雅、更具可讀性的方式來建立物件，而不是使用冗長的建構子。</p><p>本篇文章將帶您深入探索 Lombok 提供的更多樣化且功能專一的註解，學習如何根據不同的場景，精準地選擇最合適的工具，撰寫出更專業、更具意圖且極致簡潔的程式碼。</p><h2 id="Data-的問題與更精細的選擇"><a href="#Data-的問題與更精細的選擇" class="headerlink" title="@Data 的問題與更精細的選擇"></a><code>@Data</code> 的問題與更精細的選擇</h2><p><code>@Data</code> 註解實際上是以下幾個註解的集合體：</p><ul><li><code>@Getter</code></li><li><code>@Setter</code></li><li><code>@ToString</code></li><li><code>@EqualsAndHashCode</code></li><li><code>@RequiredArgsConstructor</code></li></ul><p>這帶來的主要問題是**可變性 (Mutability)**。<code>@Data</code> 會為所有非 final 的屬性產生公開的 <code>setter</code> 方法，這意味著物件在建立後，其狀態可以被輕易地改變，這在某些情境下可能會引發非預期的錯誤。因此，一個好的實踐是根據需求，單獨使用這些更精細的註解。</p><h2 id="核心註解詳解"><a href="#核心註解詳解" class="headerlink" title="核心註解詳解"></a>核心註解詳解</h2><h3 id="Getter-與-Setter"><a href="#Getter-與-Setter" class="headerlink" title="@Getter 與 @Setter"></a><code>@Getter</code> 與 <code>@Setter</code></h3><p>這是最基礎的兩個註解，分別用於產生所有屬性的 <code>getter</code> 和 <code>setter</code> 方法。您可以將它們用在類別層級，也可以用在單一屬性層級。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span> <span class="comment">// 為所有屬性產生 getter</span></span><br><span class="line"><span class="meta">@Setter</span> <span class="comment">// 為所有屬性產生 setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a><code>@ToString</code></h3><p>自動覆寫 <code>toString()</code> 方法，預設會印出所有屬性。一個非常有用的功能是排除敏感性資料。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ToString</span>.Exclude <span class="comment">// 在 toString() 的輸出中排除此欄位</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建構子相關註解"><a href="#建構子相關註解" class="headerlink" title="建構子相關註解"></a>建構子相關註解</h3><ul><li><code>@NoArgsConstructor</code>：產生一個無參數的建構子。</li><li><code>@AllArgsConstructor</code>：產生一個包含所有屬性的建構子。</li><li><code>@RequiredArgsConstructor</code>：<strong>這是與依賴注入結合的神器</strong>。它會為所有被宣告為 <code>final</code> 或被 <code>@NonNull</code> 標註的屬性，產生一個對應的建構子。</li></ul><p>在上一篇文章中，我們在 <code>UserService</code> 中手動編寫了建構子來進行依賴注入。現在，我們可以用 Lombok 來讓它消失！</p><p>修改 <code>com.example.demoapp.service.UserService.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor; <span class="comment">// 引入 Lombok 註解</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span> <span class="comment">// &lt;&lt;-- 就是這一行！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因為 userRepository 是 final 的，Lombok 會為它產生建構子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我們不再需要手動編寫以下這段建構子了！</span></span><br><span class="line">    <span class="comment">// public UserService(UserRepository userRepository) &#123;</span></span><br><span class="line">    <span class="comment">//     this.userRepository = userRepository;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        userRepository.save(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>現在，程式碼變得更加乾淨，並且完美地實現了建構子注入。</p><h2 id="使用-Builder-實現優雅的物件建構"><a href="#使用-Builder-實現優雅的物件建構" class="headerlink" title="使用 @Builder 實現優雅的物件建構"></a>使用 <code>@Builder</code> 實現優雅的物件建構</h2><p>當一個物件有多個屬性，尤其是其中很多是可選的時候，使用建構子來建立物件會變得非常痛苦（需要建立多個重載的建構子，或者傳入很多 <code>null</code>）。<strong>建造者模式 (Builder Pattern)</strong> 是解決這個問題的最佳方案，而 Lombok 讓實現這個模式變得不費吹灰之力。</p><ol><li><p>在 <code>dto</code> 套件下建立 <code>UpdateUserRequest.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span> <span class="comment">// &lt;&lt;-- 啟用 Builder 模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateUserRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>如何使用 Builder</strong>：<br>現在，您可以用一種鏈式呼叫、可讀性極高的方式來建立物件，並且可以只設定您需要的屬性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在某個測試或服務方法中...</span></span><br><span class="line"><span class="type">UpdateUserRequest</span> <span class="variable">request</span> <span class="operator">=</span> UpdateUserRequest.builder()</span><br><span class="line">    .nickname(<span class="string">&quot;Super Alice&quot;</span>)</span><br><span class="line">    .age(<span class="number">31</span>)</span><br><span class="line">    .build(); <span class="comment">// 最後呼叫 build() 來產生最終物件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// address 屬性因為沒有設定，所以其值會是 null</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="使用-Slf4j-進行日誌記錄"><a href="#使用-Slf4j-進行日誌記錄" class="headerlink" title="使用 @Slf4j 進行日誌記錄"></a>使用 <code>@Slf4j</code> 進行日誌記錄</h2><p>在 Java 中，我們通常需要在每個類別的開頭宣告一個 <code>Logger</code> 物件，這段程式碼既重複又冗長。</p><p><strong>傳統寫法</strong>：<br><code>private static final Logger log = LoggerFactory.getLogger(MyClass.class);</code></p><p>Lombok 同樣為此提供了完美的解決方案。</p><ul><li><code>@Slf4j</code>：為您的類別自動產生一個名為 <code>log</code> 的 <code>Logger</code> 物件，該物件基於 SLF4J API。</li></ul><p>讓我們再次修改 <code>UserService.java</code>，為它加上日誌功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j; <span class="comment">// 引入 Slf4j</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span> <span class="comment">// &lt;&lt;-- 加入日誌註解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 現在可以直接使用 &quot;log&quot; 物件了</span></span><br><span class="line">        log.info(<span class="string">&quot;準備註冊新使用者: &#123;&#125;&quot;</span>, username);</span><br><span class="line">        userRepository.save(username);</span><br><span class="line">        log.info(<span class="string">&quot;使用者 &#123;&#125; 已成功註冊。&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當您執行 <code>register</code> 方法時，將會在主控台中看到我們定義的 <code>info</code> 級別的日誌輸出。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們一起探索了 Lombok 除了 <code>@Data</code> 以外的眾多強大註解：</p><ul><li>我們學會了使用 <code>@Getter</code>, <code>@Setter</code>, <code>@ToString</code> 進行精細的控制。</li><li>我們掌握了使用 <code>@RequiredArgsConstructor</code> 來極大簡化依賴注入的程式碼。</li><li>我們體驗了 <code>@Builder</code> 帶來的優雅物件建構方式。</li><li>我們利用 <code>@Slf4j</code> 消除了日誌記錄的樣板程式碼。</li></ul><p>Lombok 不僅僅是為了減少程式碼量，更是為了撰寫出意圖更明確、更易於維護、更具專業水準的 Java 程式碼。</p><p>我們已經掌握了撰寫精簡、高效程式碼的技巧。在下一篇文章中，我們將為我們的應用程式加入專業的<strong>日誌管理</strong>功能，學習如何使用 Logback 來控制日誌的輸出格式與級別，這是在正式開發中不可或缺的一環。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 06 - IoC 與 DI 詳解</title>
      <link href="/2025/08/11/java-spring-boot-06/"/>
      <url>/2025/08/11/java-spring-boot-06/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：誰創造了我們的物件？"><a href="#前言：誰創造了我們的物件？" class="headerlink" title="前言：誰創造了我們的物件？"></a>前言：誰創造了我們的物件？</h2><p>在之前的文章中，我們建立了 <code>UserController</code>，並在其中處理 HTTP 請求。但您可能曾想過一個問題：我們從未在任何地方寫下 <code>UserController userController = new UserController();</code> 這樣的程式碼，那這個 <code>UserController</code> 的物件究竟是從何而來的？又是誰將它實例化 (instantiate) 的呢？</p><p>答案就在於 Spring 框架最核心的兩個設計原則：<strong>控制反轉 (Inversion of Control, IoC)</strong> 與**依賴注入 (Dependency Injection, DI)**。理解這兩個概念，是您從「會用」Spring Boot 邁向「精通」Spring Boot 的分水嶺。</p><h2 id="傳統的物件依賴"><a href="#傳統的物件依賴" class="headerlink" title="傳統的物件依賴"></a>傳統的物件依賴</h2><p>為了理解 IoC，我們先來看看傳統的程式設計方式。假設我們的 <code>UserController</code> 需要一個 <code>UserService</code> 來處理業務邏輯，傳統的寫法會是這樣：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 傳統寫法，不使用 Spring</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// Controller &quot;主動&quot; 去建立它所依賴的 UserService 物件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        userService.register(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這種寫法有幾個明顯的缺點：</p><ul><li>**高耦合 (High Coupling)**：<code>UserController</code> 與 <code>UserService</code> 的具體實作緊緊地綁在一起。如果未來 <code>UserService</code> 的建構子改變了，所有使用到它的地方都必須跟著修改。</li><li>**難以測試 (Hard to Test)**：在進行單元測試時，我們無法輕易地將 <code>userService</code> 替換成一個假的 (Mock) 物件，導致測試變得困難。</li></ul><h2 id="控制反轉-IoC-Inversion-of-Control"><a href="#控制反轉-IoC-Inversion-of-Control" class="headerlink" title="控制反轉 (IoC - Inversion of Control)"></a>控制反轉 (IoC - Inversion of Control)</h2><p>IoC 的概念徹底顛覆了傳統的做法。它的核心思想是：<strong>將建立與管理物件的「控制權」，從我們的應用程式程式碼中，「反轉」給一個外部的容器</strong>。</p><p>這個概念也被稱為「好萊塢原則」——“Don’t call us, we’ll call you.” (別打電話給我們，我們會打給你的)。</p><p>在 Spring 的世界裡：</p><ul><li>我們不再使用 <code>new</code> 關鍵字主動建立物件。</li><li>我們只需要向 Spring 的「<strong>IoC 容器</strong>」宣告我們需要哪些物件。</li><li>IoC 容器會負責在適當的時機建立這些物件，並管理它們的整個生命週期。</li><li>這些被 IoC 容器所管理的物件，我們稱之為 **”Beans”**。</li></ul><h2 id="如何將物件交給-Spring-管理？"><a href="#如何將物件交給-Spring-管理？" class="headerlink" title="如何將物件交給 Spring 管理？"></a>如何將物件交給 Spring 管理？</h2><p>那麼，我們要如何告訴 Spring 哪些類別需要被它管理成 Beans 呢？答案就是透過「**註解 (Annotation)**」。</p><p>Spring 提供了一組「**刻板印象註解 (Stereotype Annotations)**」來標示不同職責的元件：</p><ul><li><code>@Component</code>：最通用的註解，表示一個類別是 Spring 管理的元件。</li><li><code>@Service</code>：通常用於標示<strong>業務邏輯層 (Service Layer)</strong> 的元件。</li><li><code>@Repository</code>：通常用於標示<strong>資料存取層 (Data Access Layer)</strong> 的元件，負責與資料庫互動。</li><li><code>@Controller</code> &#x2F; <code>@RestController</code>：用於標示**表現層 (Presentation Layer)**，負責處理 HTTP 請求（我們已經使用過）。</li></ul><p>這些註解在功能上幾乎相同，但使用更具體的註解能讓程式碼的語義更清晰，也便於框架進行特定的處理。</p><h2 id="依賴注入-DI-Dependency-Injection"><a href="#依賴注入-DI-Dependency-Injection" class="headerlink" title="依賴注入 (DI - Dependency Injection)"></a>依賴注入 (DI - Dependency Injection)</h2><p>如果說 IoC 是一種設計思想（<strong>What</strong>），那麼 DI 就是實現這種思想的具體模式（<strong>How</strong>）。</p><p><strong>依賴注入</strong>，指的是 IoC 容器在建立一個 Bean 的時候，自動地將這個 Bean 所「依賴」的其他 Beans，「注入」到它內部的過程。</p><h3 id="建構子注入-Constructor-Injection-官方推薦的最佳實踐"><a href="#建構子注入-Constructor-Injection-官方推薦的最佳實踐" class="headerlink" title="建構子注入 (Constructor Injection) - 官方推薦的最佳實踐"></a>建構子注入 (Constructor Injection) - 官方推薦的最佳實踐</h3><p>現在，讓我們透過一個完整的範例來實踐 DI。我們將建立一個三層結構：<code>Controller</code> -&gt; <code>Service</code> -&gt; <code>Repository</code>。</p><ol><li><p><strong>建立 Repository</strong><br>在 <code>com.example.demoapp</code> 下建立新套件 <code>repository</code>，並新增 <code>UserRepository.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.repository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 這裡模擬將使用者存到資料庫</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Saving user &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; to database.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>建立 Service 並注入 Repository</strong><br>在 <code>com.example.demoapp</code> 下建立新套件 <code>service</code>，並新增 <code>UserService.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 final 確保依賴不會被改變</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 透過建構子注入 UserRepository</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        userRepository.save(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>程式碼詳解</strong>：我們在 <code>UserService</code> 的建構子中宣告需要一個 <code>UserRepository</code>。當 Spring 容器要建立 <code>UserService</code> 這個 Bean 時，它會自動去容器中尋找一個 <code>UserRepository</code> 的 Bean，並透過建構子傳遞進來。</li></ul></li><li><p><strong>在 Controller 中注入 Service</strong><br>最後，修改我們的 <code>UserController.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他 import ...</span></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 透過建構子注入 UserService</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> CreateUserRequest request)</span> &#123;</span><br><span class="line">        userService.register(request.getUsername());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;使用者 &quot;</span> + request.getUsername() + <span class="string">&quot; 建立成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>為何推薦建構子注入？</strong></p><ul><li><strong>依賴清晰</strong>：所有必要的依賴都清楚地列在建構子中，一目了然。</li><li>**不可變性 (Immutability)**：可以將依賴宣告為 <code>final</code>，確保物件在建立後其依賴不會被意外更改，增加了程式的穩定性。</li><li><strong>保證依賴就緒</strong>：物件在被完整建立之前，其所有依賴都必須已經準備好，避免了在後續操作中出現 <code>NullPointerException</code> 的風險。</li><li><strong>易於測試</strong>：在單元測試中，您可以輕易地手動 <code>new</code> 一個實例，並傳入假的 (Mock) 依賴物件。</li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們一起揭開了 Spring 框架運作的神秘面紗。</p><ul><li>**IoC (控制反轉)**：我們將物件的生殺大權交給了 Spring IoC 容器。</li><li><strong>Beans</strong>：被 Spring 容器管理的物件，我們透過 <code>@Service</code>, <code>@Repository</code> 等註解來宣告它們。</li><li>**DI (依賴注入)**：容器自動為我們的 Bean 裝配其所需的依賴。</li><li><strong>建構子注入</strong>：是 Spring 官方推薦、最安全且最清晰的依賴注入方式。</li></ul><p>我們已經理解了 Spring 如何管理物件與其依賴關係。在下一篇文章中，我們將回歸實用技巧，深入探討 <strong>Lombok</strong> 的更多強大功能，學習如何讓我們的程式碼變得更加精簡。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 05 - 處理請求本文 (Body) 與 DTO</title>
      <link href="/2025/08/11/java-spring-boot-05/"/>
      <url>/2025/08/11/java-spring-boot-05/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：接收結構化的資料"><a href="#前言：接收結構化的資料" class="headerlink" title="前言：接收結構化的資料"></a>前言：接收結構化的資料</h2><p>在上一篇文章中，我們學會了如何透過 <code>@RequestParam</code> 和 <code>@PathVariable</code> 從 URL 中獲取簡單的參數。然而，當需要建立或更新一個複雜的資源時（例如，註冊一個新使用者），客戶端通常會將包含多個欄位的結構化資料放在 HTTP 請求的「本文 (Request Body)」中，並以 JSON 格式傳送。</p><p>本篇文章將帶您掌握處理這種情境的核心技能。我們將學習如何使用 <code>@PostMapping</code> 來處理建立資源的請求，並透過 <code>@RequestBody</code> 將傳入的 JSON 資料自動轉換為 Java 物件。同時，我們將引入一個極其重要的設計模式——**資料傳輸物件 (Data Transfer Object, DTO)**。</p><h2 id="什麼是請求本文-Request-Body-？"><a href="#什麼是請求本文-Request-Body-？" class="headerlink" title="什麼是請求本文 (Request Body)？"></a>什麼是請求本文 (Request Body)？</h2><p>對於 <code>POST</code> 或 <code>PUT</code> 這類意在「新增」或「修改」資料的 HTTP 方法，其要傳遞的資料內容並非放在 URL 上，而是放在請求的「本文 (Body)」或稱為「酬載 (Payload)」中。在現代的 RESTful API 設計中，這個本文的內容最常見的格式就是 JSON。</p><p>例如，一個用於建立新使用者的請求本文，其 JSON 格式可能如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="建立資料傳輸物件-DTO"><a href="#建立資料傳輸物件-DTO" class="headerlink" title="建立資料傳輸物件 (DTO)"></a>建立資料傳輸物件 (DTO)</h2><p>在接收請求本文的資料之前，我們需要先在 Java 中定義一個對應的「容器」來承裝這些資料。這個容器就是 DTO。</p><p><strong>為何要使用 DTO？</strong><br>使用 DTO 是一個非常重要的開發實踐，它帶來了幾個好處：</p><ol><li><strong>關注點分離</strong>：將 API 層的資料結構與內部領域模型（例如資料庫的 Entity）分離開來。API 的樣貌不應被資料庫的結構所綁架。</li><li><strong>資料驗證</strong>：可以針對 API 的輸入，在 DTO 上定義特定的驗證規則。</li><li><strong>安全性</strong>：可以精確控制要接收哪些欄位，避免惡意使用者傳入非預期的欄位來試圖修改內部資料。</li></ol><p>現在，讓我們來建立一個與上述 JSON 結構對應的 DTO。</p><ol><li><p>在 <code>com.example.demoapp</code> 套件下，建立一個新的子套件 <code>dto</code>。</p></li><li><p>在 <code>dto</code> 套件中，建立一個新檔案 <code>CreateUserRequest.java</code>，並貼上以下內容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">// Lombok: 自動產生 getter, setter, toString, equals, hashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateUserRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個 <code>CreateUserRequest</code> 類別的屬性，與我們預期接收的 JSON 欄位完全一致。</p></li></ol><h2 id="使用-PostMapping-與-RequestBody-接收資料"><a href="#使用-PostMapping-與-RequestBody-接收資料" class="headerlink" title="使用 @PostMapping 與 @RequestBody 接收資料"></a>使用 <code>@PostMapping</code> 與 <code>@RequestBody</code> 接收資料</h2><p>現在，萬事俱備，我們可以建立一個新的 Controller 來處理使用者建立的請求。</p><ol><li><p>在 <code>com.example.demoapp</code> 套件下，建立一個新檔案 <code>UserController.java</code>。</p></li><li><p>貼上以下程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demoapp.dto.CreateUserRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span> <span class="comment">// 1. 為 Controller 設定一個基礎路徑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 映射 HTTP POST 請求到這個方法</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> CreateUserRequest request)</span> &#123; <span class="comment">// 3. 接收請求本文並轉換為 DTO 物件</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的使用者名稱: &quot;</span> + request.getUsername());</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的 Email: &quot;</span> + request.getEmail());</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的年齡: &quot;</span> + request.getAge());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;使用者 &quot;</span> + request.getUsername() + <span class="string">&quot; 建立成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>程式碼詳解</strong>：<ol><li><code>@RequestMapping(&quot;/users&quot;)</code>：在類別層級使用此註解，可以為這個 Controller 內的所有 API 設定一個共同的基礎路徑。</li><li><code>@PostMapping</code>：此註解將 HTTP <code>POST</code> 方法的請求映射到 <code>createUser</code> 方法。因為類別已有 <code>@RequestMapping(&quot;/users&quot;)</code>，所以此方法的完整路徑是 <code>POST /users</code>。</li><li><code>@RequestBody CreateUserRequest request</code>：<strong>這是本篇的關鍵</strong>。<code>@RequestBody</code> 註解告訴 Spring Boot，請讀取整個 HTTP 請求的本文，並使用內建的 Jackson 函式庫，將其 JSON 內容自動地反序列化 (deserialize) 成一個 <code>CreateUserRequest</code> 的 Java 物件。</li></ol></li></ul><h2 id="如何測試-POST-請求"><a href="#如何測試-POST-請求" class="headerlink" title="如何測試 POST 請求"></a>如何測試 <code>POST</code> 請求</h2><p>與可以直接在瀏覽器網址列測試的 <code>GET</code> 請求不同，<code>POST</code> 請求需要使用專門的工具來發送。</p><ul><li><p><strong>方法一：使用 <code>curl</code> 命令列工具</strong><br>打開您的終端機，執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8080/users \</span><br><span class="line">-H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">-d <span class="string">&#x27;&#123;&quot;username&quot;: &quot;alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;, &quot;age&quot;: 30&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>您應該會收到 <code>使用者 alice 建立成功！</code> 的回應。</p></li><li><p><strong>方法二：使用 API 測試軟體</strong><br>對於初學者，使用圖形化介面的 API 測試軟體會更直觀，例如 <strong>Postman</strong>, <strong>Insomnia</strong>，或是 VSCode 的 <strong>Thunder Client</strong> 插件。<br>操作步驟大致如下：</p><ol><li>選擇請求方法為 <code>POST</code>。</li><li>輸入 URL：<code>http://localhost:8080/users</code>。</li><li>切換到 “Body” 頁籤，選擇類型為 “raw”，格式為 “JSON”。</li><li>將您的 JSON 內容貼入輸入框中。</li><li>點擊「傳送 (Send)」。</li></ol></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們學會了如何處理更貼近真實世界應用場景的 API 輸入。</p><ul><li>我們理解了為何需要使用 DTO (資料傳輸物件) 來作為 API 的資料載體。</li><li>我們掌握了如何使用 <code>@PostMapping</code> 和 <code>@RequestBody</code> 來接收並自動轉換請求本文中的 JSON 資料。</li><li>我們知道了如何使用 <code>curl</code> 或 API 測試軟體來驗證 <code>POST</code> 請求。</li></ul><p>我們現在已經掌握了 Spring Boot Web 開發的基礎。然而，這些 Controller 和 DTO 物件都是由誰來實例化和管理的呢？在下一篇文章中，我們將深入 Spring 的靈魂——<strong>IoC 與 DI</strong>，徹底理解 Spring 框架運作的核心機制。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 04 - 處理請求參數</title>
      <link href="/2025/08/11/java-spring-boot-04/"/>
      <url>/2025/08/11/java-spring-boot-04/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：讓-API-動起來"><a href="#前言：讓-API-動起來" class="headerlink" title="前言：讓 API 動起來"></a>前言：讓 API 動起來</h2><p>在上一篇文章中，我們成功建立了第一個 RESTful API，但它只能回傳固定的資料。一個真正實用的 API 必須能夠接收來自客戶端的輸入，並根據這些輸入回傳動態的結果。</p><p>本篇文章將聚焦於兩種在 Spring Boot 中最常用於從 URL 接收參數的方法。我們將學習如何使用 <code>@RequestParam</code> 來處理 URL 中的查詢參數（Query Parameters），以及如何使用 <code>@PathVariable</code> 來獲取路徑本身包含的變數（Path Variables）。掌握這兩者，是讓您的 API 從「靜態」走向「動態」的關鍵一步。</p><h2 id="使用-RequestParam-接收查詢參數"><a href="#使用-RequestParam-接收查詢參數" class="headerlink" title="使用 @RequestParam 接收查詢參數"></a>使用 <code>@RequestParam</code> 接收查詢參數</h2><p>查詢參數（Query Parameters）是附加在 URL 末尾，用於過濾或傳遞額外資訊的鍵值對。它們以一個 <code>?</code> 開始，並用 <code>&amp;</code> 分隔多個參數。</p><p><strong>例如</strong>：<code>http://localhost:8080/api/users?page=1&amp;size=10</code></p><h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><p>讓我們修改 <code>HelloController.java</code>，新增一個方法來接收名為 <code>name</code> 的查詢參數。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="comment">// ... 其他 import ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="comment">// ... 保留之前的方法 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 範例 URL: /user?name=David</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserByName</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>程式碼詳解</strong>：<code>@RequestParam String name</code> 這段程式碼告訴 Spring Boot，請在 HTTP 請求中尋找一個名為 <code>name</code> 的查詢參數，並將其值賦予方法的 <code>name</code> 變數。</p></li><li><p><strong>測試</strong>：</p><ol><li>啟動或重新啟動您的 Spring Boot 應用。</li><li>在瀏覽器訪問 <code>http://localhost:8080/user?name=David</code>，您將看到 <code>Hello, David!</code>。</li><li>嘗試不提供參數，訪問 <code>http://localhost:8080/user</code>。您會收到一個 HTTP 400 (Bad Request) 錯誤，因為 Spring Boot 預設認為 <code>@RequestParam</code> 是<strong>必須提供</strong>的。</li></ol></li></ul><h3 id="2-進階屬性"><a href="#2-進階屬性" class="headerlink" title="2. 進階屬性"></a>2. 進階屬性</h3><p><code>@RequestParam</code> 提供了一些有用的屬性，讓參數處理更有彈性。</p><ul><li><p><strong><code>required = false</code>：設為非必要參數</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user-optional&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserOptional</span><span class="params">(<span class="meta">@RequestParam(required = false)</span> String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Guest!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>現在，如果您訪問 <code>/user-optional</code> 而不帶任何參數，程式將不再報錯，而是會回傳 <code>Hello, Guest!</code>。</p></li><li><p><strong><code>defaultValue</code>：提供預設值</strong><br>這是一種更簡潔的方式來處理非必要參數。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user-default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserDefault</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;Guest&quot;)</span> String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供 <code>defaultValue</code> 會隱含地將 <code>required</code> 設為 <code>false</code>。訪問 <code>/user-default</code> 會得到 <code>Hello, Guest!</code>。</p></li></ul><h2 id="使用-PathVariable-獲取路徑變數"><a href="#使用-PathVariable-獲取路徑變數" class="headerlink" title="使用 @PathVariable 獲取路徑變數"></a>使用 <code>@PathVariable</code> 獲取路徑變數</h2><p>路徑變數（Path Variables）是 URL 路徑的一部分，通常用於標識一個特定的資源，例如一個使用者的 ID。</p><p><strong>例如</strong>：<code>http://localhost:8080/api/users/123</code>，其中的 <code>123</code> 就是一個路徑變數。</p><h3 id="1-基本用法-1"><a href="#1-基本用法-1" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><p>讓我們再次修改 <code>HelloController.java</code>，新增一個透過 ID 獲取商品資訊的模擬 API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他 import ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="comment">// ... 保留之前的方法 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 範例 URL: /products/101</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/products/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fetching product with ID: &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>程式碼詳解</strong>：</p><ul><li><code>@GetMapping(&quot;/products/&#123;id&#125;&quot;)</code>：這裡的 <code>&#123;id&#125;</code> 是一個路徑變數的佔位符。</li><li><code>@PathVariable Long id</code>：此註解會從路徑的 <code>&#123;id&#125;</code> 佔位符中提取值，並將其賦予方法的 <code>id</code> 變數。Spring Boot 會自動嘗試將傳入的字串（如 “101”）轉換為您指定的類型（如 <code>Long</code>）。</li></ul></li><li><p><strong>測試</strong>：</p><ol><li>啟動應用。</li><li>在瀏覽器訪問 <code>http://localhost:8080/products/101</code>，您將看到 <code>Fetching product with ID: 101</code>。</li></ol></li></ul><h3 id="2-多個路徑變數"><a href="#2-多個路徑變數" class="headerlink" title="2. 多個路徑變數"></a>2. 多個路徑變數</h3><p>您也可以在一個路徑中定義多個路徑變數。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 範例 URL: /orders/2025/details/08</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/orders/&#123;year&#125;/details/&#123;month&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getOrderDetails</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> year, <span class="meta">@PathVariable</span> String month)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;Fetching orders for Year: %d, Month: %s&quot;</span>, year, month);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RequestParam-vs-PathVariable：如何選擇？"><a href="#RequestParam-vs-PathVariable：如何選擇？" class="headerlink" title="@RequestParam vs. @PathVariable：如何選擇？"></a><code>@RequestParam</code> vs. <code>@PathVariable</code>：如何選擇？</h2><p>這是一個常見的困惑點。您可以根據以下簡單的原則來選擇：</p><ul><li><p><strong><code>@PathVariable</code> (路徑變數)<strong>：用於</strong>識別一個特定的資源</strong>。它是 URL 的一部分，是定位資源所必需的。</p><ul><li><strong>語義</strong>：這個東西是「什麼」。</li><li><strong>範例</strong>：<code>/users/123</code> (獲取 ID 為 123 的使用者)、<code>/articles/spring-boot-guide</code> (獲取標題為 spring-boot-guide 的文章)。</li></ul></li><li><p><strong><code>@RequestParam</code> (查詢參數)<strong>：用於對資源集合進行</strong>排序、篩選或分頁</strong>。它們是可選的，用於改變資料的呈現方式。</p><ul><li><strong>語義</strong>：我想「如何」看到這些東西。</li><li><strong>範例</strong>：<code>/users?role=admin</code> (篩選出所有管理員角色的使用者)、<code>/articles?sort=publishedDate,desc</code> (將文章按發布日期降序排序)。</li></ul></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們學會了如何讓 API 接收來自 URL 的輸入，使其變得更加動態與實用。</p><ul><li>我們使用 <code>@RequestParam</code> 來獲取 URL <code>?</code> 後的查詢參數，並學習了如何設定其為非必要及提供預設值。<br>*我們使用 <code>@PathVariable</code> 來獲取嵌入在 URL 路徑中的變數，通常用於指定資源的唯一識別符。</li></ul><p>我們已經掌握了如何從 URL 接收簡單的資料。但在更複雜的情境下，客戶端通常會透過請求的本文 (Request Body) 發送大量的結構化資料（例如 JSON）。在下一篇文章中，我們將學習如何處理這種情況，並介紹 DTO 模式的重要性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 03 - 第一個 RESTful API</title>
      <link href="/2025/08/11/java-spring-boot-03/"/>
      <url>/2025/08/11/java-spring-boot-03/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：從理論到實踐"><a href="#前言：從理論到實踐" class="headerlink" title="前言：從理論到實踐"></a>前言：從理論到實踐</h2><p>歡迎來到「Spring Series 基礎」的第三篇文章。在上一篇中，我們深入了解了 Spring Boot 專案的內部結構與自動化配置的原理。現在，是時候將這些理論知識付諸實踐，親手打造出一個可以實際運作的網頁端點 (Endpoint) 了。</p><p>本篇文章的目標非常明確：我們將建立一個最簡單的 RESTful API。當使用者透過瀏覽器訪問指定的網址時，我們的應用程式將會回傳一段 “Hello, World!“ 訊息。過程中，您將會學習到 Spring Boot 中最重要的兩個註解：<code>@RestController</code> 與 <code>@GetMapping</code>，並完成從撰寫、執行到測試的完整開發循環。</p><h2 id="什麼是-RESTful-API？"><a href="#什麼是-RESTful-API？" class="headerlink" title="什麼是 RESTful API？"></a>什麼是 RESTful API？</h2><p>在開始之前，讓我們先快速了解一下 RESTful API 是什麼。</p><p>REST (Representational State Transfer) 是一種軟體架構風格，而不是一個標準。一個符合 REST 風格的網路服務，我們稱之為 RESTful API。它的核心理念是將網路上的所有事物都視為「資源」，並透過標準的 HTTP 方法 (GET, POST, PUT, DELETE 等) 來對這些資源進行操作。它通常使用 JSON 或 XML 作為資料交換的格式。</p><p>簡單來說，它是一種讓不同系統（例如前端瀏覽器與後端伺服器）之間能夠以一種標準化、無狀態的方式進行溝通的橋樑。</p><h2 id="建立您的第一個-Controller"><a href="#建立您的第一個-Controller" class="headerlink" title="建立您的第一個 Controller"></a>建立您的第一個 Controller</h2><p>在 Spring MVC 的世界裡，「Controller」是負責接收來自客戶端的 HTTP 請求，並決定如何回應的關鍵元件。</p><ol><li><p><strong>建立 Controller 檔案</strong><br>在您的 VSCode 專案中，找到 <code>src/main/java/com/example/demoapp</code> 這個套件。在該套件上按右鍵，選擇「新增檔案」，並將檔案命名為 <code>HelloController.java</code>。</p><blockquote><p><strong>重要提示</strong>：請務必將 Controller 類別建立在與主應用程式 <code>DemoAppApplication.java</code> 相同的套件或其子套件下。這是因為 <code>@SpringBootApplication</code> 註解預設只會掃描其所在的套件及子套件，以尋找並註冊像 Controller 這樣的元件。</p></blockquote></li><li><p><strong>撰寫 Controller 程式碼</strong><br>打開 <code>HelloController.java</code> 並貼上以下程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 標示這個類別為一個 RESTful Controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 將 HTTP GET 請求的 &quot;/hello&quot; 路徑映射到這個方法</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 方法回傳一個簡單的字串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>程式碼詳解</strong></p><ul><li><code>@RestController</code>：這是一個方便的複合註解。它告訴 Spring 兩件事：第一，這個類別是一個 Controller (<code>@Controller</code>)，負責處理網頁請求；第二，這個類別中所有方法的回傳值都應該直接寫入 HTTP 回應的本文 (Body) 中 (<code>@ResponseBody</code>)，而不是被解析為頁面跳轉的路徑。這對於開發只回傳資料的 RESTful API 來說是完美的選擇。</li><li><code>@GetMapping(&quot;/hello&quot;)</code>：這個註解將 HTTP 的 <code>GET</code> 請求與指定的路徑 <code>/hello</code> 綁定到 <code>sayHello()</code> 這個方法上。當有請求發送到 <code>http://&lt;您的伺服器&gt;/hello</code> 時，Spring 就會知道要執行這個方法。</li><li><code>public String sayHello()</code>：這是一個普通的 Java 方法，它回傳的字串 <code>&quot;Hello, Spring Boot!&quot;</code> 將會成為 HTTP 回應的內容。</li></ul></li></ol><h2 id="啟動並測試您的-API"><a href="#啟動並測試您的-API" class="headerlink" title="啟動並測試您的 API"></a>啟動並測試您的 API</h2><ol><li><p><strong>啟動應用程式</strong></p><ul><li><strong>方法一 (推薦)<strong>：在 VSCode 左側的「Spring Boot Dashboard」中，找到 <code>demo-app</code> 專案，點擊旁邊的</strong>播放 (Start)</strong> 按鈕。</li><li><strong>方法二</strong>：在 VSCode 的整合式終端機中，輸入指令 <code>mvn spring-boot:run</code>。</li></ul></li><li><p><strong>觀察主控台</strong><br>切換到「偵錯主控台」或「終端機」面板，等待日誌輸出，直到您看見類似 <code>Tomcat started on port(s): 8080 (http)</code> 的訊息，這代表內嵌的 Tomcat 伺服器已經成功啟動並在監聽 8080 埠。</p></li><li><p><strong>在瀏覽器中測試</strong><br>打開您的網頁瀏覽器 (如 Chrome, Firefox)，在網址列輸入 <code>http://localhost:8080/hello</code> 並按下 Enter。</p><p>您應該會在頁面上看到我們撰寫的回應訊息：<code>Hello, Spring Boot!</code></p></li></ol><h2 id="更進一步：回傳-JSON-物件"><a href="#更進一步：回傳-JSON-物件" class="headerlink" title="更進一步：回傳 JSON 物件"></a>更進一步：回傳 JSON 物件</h2><p>在真實世界的 API 中，我們通常回傳的是結構化的 JSON 資料，而不僅僅是純文字。<code>@RestController</code> 的強大之處在於它能自動將 Java 物件轉換為 JSON。</p><ol><li><p><strong>修改 Controller</strong><br>讓我們在 <code>HelloController.java</code> 中新增一個方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增一個回傳 JSON 的方法</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/greeting&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; response = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        response.put(<span class="string">&quot;id&quot;</span>, <span class="number">1L</span>);</span><br><span class="line">        response.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;This is a JSON response!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>重新啟動並測試</strong></p><ul><li>如果您在建立專案時已加入 <code>spring-boot-devtools</code> 相依性，當您儲存檔案時，應用程式會自動重新啟動。如果沒有，請手動停止並再次啟動應用。</li><li>這次，在瀏覽器中訪問 <code>http://localhost:8080/greeting</code>。</li></ul><p>您將會看到瀏覽器顯示了一段標準的 JSON 格式字串，這證明了 Spring Boot 已自動將我們的 <code>Map</code> 物件轉換為 JSON。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;This is a JSON response!&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>恭喜您！您已經成功地建立、執行並測試了您的第一個 RESTful API。在本篇文章中，我們學會了如何：</p><ul><li>使用 <code>@RestController</code> 來定義一個 API 控制器。</li><li>使用 <code>@GetMapping</code> 來映射 HTTP GET 請求。</li><li>從 API 回傳純文字與 JSON 物件。</li></ul><p>現在我們已經知道如何建立一個基本的 API 端點，但真實世界的 API 需要接收來自客戶端的輸入。在下一篇文章中，我們將學習如何處理各種請求參數，讓我們的 API 更具互動性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 02 - 專案結構與核心概念</title>
      <link href="/2025/08/08/java-spring-boot-02/"/>
      <url>/2025/08/08/java-spring-boot-02/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：探索自動化配置的起點"><a href="#前言：探索自動化配置的起點" class="headerlink" title="前言：探索自動化配置的起點"></a>前言：探索自動化配置的起點</h2><p>歡迎來到「Spring Series 基礎」的第二篇文章。在我們動手撰寫第一行 API 程式碼之前，花時間理解 Spring Boot 為我們自動產生的專案結構是至關重要的。俗話說「知其然，知其所以然」，了解這些自動化配置背後的原理，將幫助您在未來的開發中更加得心應手，並在遇到問題時能更快地找到癥結點。</p><p>本篇文章將扮演一趟「專案導覽」，帶您逐一檢視由 Spring Initializr 產生的各個檔案與資料夾，並深入剖析 <code>pom.xml</code> 與 <code>@SpringBootApplication</code> 這兩大核心，為您的 Spring Boot 之旅打下最堅實的基礎。</p><h2 id="專案結構概覽"><a href="#專案結構概覽" class="headerlink" title="專案結構概覽"></a>專案結構概覽</h2><p>當您使用 VSCode 的插件建立完專案後，會看到一個標準的 Maven 專案結構，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">demo-app/</span><br><span class="line">├── .mvn/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main/</span><br><span class="line">│   │   ├── java/</span><br><span class="line">│   │   │   └── com/example/demoapp/</span><br><span class="line">│   │   │       └── DemoAppApplication.java  # 應用程式主入口</span><br><span class="line">│   │   └── resources/</span><br><span class="line">│   │       └── application.properties       # 主要設定檔</span><br><span class="line">│   └── test/</span><br><span class="line">│       └── java/</span><br><span class="line">│           └── com/example/demoapp/</span><br><span class="line">│               └── DemoAppApplicationTests.java # 測試程式主入口</span><br><span class="line">├── .gitignore</span><br><span class="line">├── mvnw</span><br><span class="line">├── mvnw.cmd</span><br><span class="line">└── pom.xml                                  # Maven 專案核心設定檔</span><br></pre></td></tr></table></figure><ul><li><code>src/main/java</code>：存放您所有 Java 原始碼的核心目錄。</li><li><code>src/main/resources</code>：存放所有非程式碼資源，如設定檔 (<code>application.properties</code>)、靜態網頁資源 (HTML&#x2F;CSS) 等。</li><li><code>src/test/java</code>：存放所有測試用的 Java 原始碼。</li><li><code>pom.xml</code>：<strong>專案的心臟</strong>。它定義了專案的所有資訊、相依性 (dependencies) 和建置方式。</li><li><code>mvnw</code> &#x2F; <code>mvnw.cmd</code>：Maven Wrapper 腳本。它讓其他開發者在沒有全域安裝 Maven 的情況下，也能使用與您完全相同的 Maven 版本來建置專案，確保了環境的一致性。</li></ul><h2 id="剖析-pom-xml-專案的建置藍圖"><a href="#剖析-pom-xml-專案的建置藍圖" class="headerlink" title="剖析 pom.xml - 專案的建置藍圖"></a>剖析 <code>pom.xml</code> - 專案的建置藍圖</h2><p><code>pom.xml</code> (Project Object Model) 告訴 Maven 如何建置您的專案。對於一個 Spring Boot 專案，其中有幾個關鍵部分：</p><h3 id="1-繼承-spring-boot-starter-parent"><a href="#1-繼承-spring-boot-starter-parent" class="headerlink" title="1. 繼承 spring-boot-starter-parent"></a>1. 繼承 <code>spring-boot-starter-parent</code></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>這段設定讓您的專案繼承自一個特殊的父專案。這個「超級 POM」預先定義了大量有用的預設設定，例如：Java 編譯版本、各種相依性函式庫的版本號、以及 Maven 插件的組態。這意味著您無需再為數十個函式庫手動指定版本，大幅簡化了版本管理的複雜性。</p><h3 id="2-相依性-Dependencies-與-Starters"><a href="#2-相依性-Dependencies-與-Starters" class="headerlink" title="2. 相依性 (Dependencies) 與 Starters"></a>2. 相依性 (Dependencies) 與 Starters</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>這是 <code>pom.xml</code> 中最活躍的部分。Spring Boot 的核心理念之一就是 **”Starters” (起步依賴)**。</p><p>一個 Starter 就像一個「懶人包」，它本身可能沒有太多程式碼，但它會幫您把一整組開發特定功能時常用到的函式庫一次性地全部打包進來。</p><ul><li><code>spring-boot-starter-web</code>：只要加入這一個相依性，它就會自動引入 Spring MVC 框架、一個內嵌的 Tomcat 伺服器、以及處理 JSON 的 Jackson 函式庫等，所有建立 Web 應用所需的一切都已備妥。</li><li><code>spring-boot-starter-test</code>：這個懶人包則包含了 JUnit 5、Mockito、AssertJ 等主流的 Java 測試框架。</li></ul><h3 id="3-建置插件-Build-Plugin"><a href="#3-建置插件-Build-Plugin" class="headerlink" title="3. 建置插件 (Build Plugin)"></a>3. 建置插件 (Build Plugin)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>這個插件是將您的應用程式打包成一個可執行檔案的關鍵。當您執行 <code>mvn package</code> 命令時，它會產生一個「胖 JAR (fat JAR)」，這個 JAR 檔案不僅包含了您自己撰寫的程式碼，還將內嵌的 Tomcat 伺服器以及所有相依的函式庫全部打包進去。這使得部署 Spring Boot 應用變得極其簡單，您只需要一行指令 <code>java -jar your-app.jar</code> 即可啟動整個應用程式。</p><h2 id="揭密-SpringBootApplication-三位一體的核心註解"><a href="#揭密-SpringBootApplication-三位一體的核心註解" class="headerlink" title="揭密 @SpringBootApplication - 三位一體的核心註解"></a>揭密 <code>@SpringBootApplication</code> - 三位一體的核心註解</h2><p>現在，讓我們看看唯一的 Java 檔案 <code>DemoAppApplication.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoAppApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoAppApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段程式碼雖然簡短，但 <code>@SpringBootApplication</code> 這個註解背後卻蘊含了 Spring Boot 的三大核心機制。它實際上是一個組合了以下三個註解的「複合註解」：</p><ol><li><p><strong><code>@SpringBootConfiguration</code></strong>: 這個註解本質上就是 Spring 的 <code>@Configuration</code>。它將當前的類別標示為一個組態類別，允許您在其中定義 Beans。</p></li><li><p><strong><code>@EnableAutoConfiguration</code></strong>: <strong>這是 Spring Boot 的魔法核心</strong>。這個註解會觸發 Spring Boot 的「自動設定」機制。它會根據您專案 <code>pom.xml</code> 中引入的相依性，來「猜測」您想要如何設定您的應用程式。例如，當它偵測到 <code>spring-boot-starter-web</code> 時，它就知道您想建立一個 Web 應用，因此會自動幫您設定好 DispatcherServlet 與內嵌的 Tomcat 伺服器。</p></li><li><p><strong><code>@ComponentScan</code></strong>: 這個註解會啟用 Spring 的「元件掃描」機制。它會自動掃描與主應用程式 (<code>DemoAppApplication</code>) <strong>相同套件及其子套件</strong>下的所有類別，若發現有被 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等註解標示的類別，就會自動將其實例化並納入 Spring 的 IoC 容器中進行管理。這也是為什麼我們之後建立的 Controller 和 Service 都會放在 <code>com.example.demoapp</code> 這個套件或其子套件下的原因。</p></li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在本篇文章中，我們一起探索了由 Spring Initializr 所建立的專案骨架。我們理解了 <code>pom.xml</code> 如何透過 <code>starter-parent</code> 與 <code>starters</code> 來簡化相依性管理，以及 <code>spring-boot-maven-plugin</code> 如何打包出可執行的 JAR 檔。最重要的是，我們揭開了 <code>@SpringBootApplication</code> 背後自動設定與元件掃描的神秘面紗。</p><hr><p>有了這些扎實的基礎，我們已經準備好動手撰寫第一支 API。在下一篇文章中，我們將學習如何使用 <code>@RestController</code> 來建立一個真正的 Web 端點，正式踏出開發的第一步。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 01 - 學習路徑總覽：從入門到專家之路</title>
      <link href="/2025/08/08/java-spring-boot-01/"/>
      <url>/2025/08/08/java-spring-boot-01/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：開啟您的-Spring-Boot-旅程"><a href="#前言：開啟您的-Spring-Boot-旅程" class="headerlink" title="前言：開啟您的 Spring Boot 旅程"></a>前言：開啟您的 Spring Boot 旅程</h2><p>歡迎來到「Spring Series 基礎」系列！</p><p>本系列是為有志於深入學習 Spring Boot 的開發者所設計的一套完整、有系統的學習路徑。在現今的 Java 後端開發領域，Spring Boot 已成為建立微服務與 Web 應用程式的首選框架。它透過「約定優於配置」的理念，大幅簡化了專案的初始設定與開發過程。</p><p>這篇文章作為系列的第一篇，其核心任務是為您提供一張清晰的「學習地圖」。我們將這趟旅程劃分為五個主要階段，涵蓋了從環境設定、Web 核心、資料庫整合、應用測試、安全性，一直到最終部署的 29 個核心主題。透過這個結構化的路徑，您將能避免零散學習的困擾，扎實地建立起全面的知識體系。</p><p>在正式啟程前，請務必確認您已完成我們在先前文章中介紹的 VSCode、JDK 與 Maven 基礎環境設定。</p><p>現在，就讓我們一同展開這段充實而富有挑戰的旅程吧！</p><h2 id="「Spring-Series-基礎」完整學習地圖"><a href="#「Spring-Series-基礎」完整學習地圖" class="headerlink" title="「Spring Series 基礎」完整學習地圖"></a>「Spring Series 基礎」完整學習地圖</h2><hr><h2 id="第一階段：基礎入門與-Web-核心-共-8-篇"><a href="#第一階段：基礎入門與-Web-核心-共-8-篇" class="headerlink" title="第一階段：基礎入門與 Web 核心 (共 8 篇)"></a><strong>第一階段：基礎入門與 Web 核心 (共 8 篇)</strong></h2><p>此階段將帶您掌握 Spring Boot 專案的基礎結構與核心 Web 開發技能。</p><ul><li><strong><code>02. 專案結構與核心概念</code></strong>: 剖析專案的起步依賴 (Starters) 與 <code>@SpringBootApplication</code> 註解背後的秘密。</li><li><strong><code>03. 第一個 RESTful API</code></strong>: 學習 <code>@RestController</code> 與 <code>@GetMapping</code>，建立您的第一個 API 端點。</li><li><strong><code>04. 處理請求參數</code></strong>: 專注於 API 的輸入，詳解 <code>@RequestParam</code> 與 <code>@PathVariable</code>。</li><li><strong><code>05. 處理請求本文 (Body) 與 DTO</code></strong>: 學習 <code>@PostMapping</code> 與 <code>@RequestBody</code>，並介紹使用資料傳輸物件 (DTO) 的重要性。</li><li><strong><code>06. IoC 與 DI 詳解</code></strong>: 深入 Spring 的靈魂——控制反轉 (IoC) 與依賴注入 (DI) 的核心思想。</li><li><strong><code>07. Lombok 深度應用</code></strong>: 學習如何使用 Lombok 讓您的 Java 程式碼更加簡潔優雅。</li><li><strong><code>08. 整合 Logback 進行日誌管理</code></strong>: 學習設定 Logback，為您的應用程式加入專業的日誌記錄功能。</li><li><strong><code>09. 整合 OpenAPI (Swagger) 產生 API 文件</code></strong>: 學習自動產生互動式 API 文件，提升團隊協作效率。</li></ul><hr><h2 id="第二階段：資料庫整合與應用-共-7-篇"><a href="#第二階段：資料庫整合與應用-共-7-篇" class="headerlink" title="第二階段：資料庫整合與應用 (共 7 篇)"></a><strong>第二階段：資料庫整合與應用 (共 7 篇)</strong></h2><p>此階段將專注於應用程式的資料庫存取層，從基礎 CRUD 到交易管理。</p><ul><li><strong><code>10. 整合 H2 資料庫與 JPA Entity</code></strong>: 使用 H2 記憶體資料庫快速開始，並學習如何將 Java 物件映射到資料庫表格。</li><li><strong><code>11. JpaRepository 與 CRUD 操作</code></strong>: 體驗 Spring Data JPA 的強大之處，無需撰寫 SQL 即可完成資料庫操作。</li><li><strong><code>12. 進階查詢方法 (Query Methods)</code></strong>: 學習透過定義方法名稱，讓 Spring Data JPA 自動產生對應的 SQL 查詢。</li><li><strong><code>13. 使用 @Query 進行複雜查詢 (JPQL)</code></strong>: 當方法名稱不足以表達複雜查詢時，學習使用 <code>@Query</code> 註解並撰寫 JPQL。</li><li><strong><code>14. Entity 關聯：一對多與多對一</code></strong>: 學習如何使用 <code>@OneToMany</code> 與 <code>@ManyToOne</code> 建立實體間的關聯。</li><li><strong><code>15. 交易管理 @Transactional</code></strong>: 詳解 <code>@Transactional</code> 註解對於確保資料一致性的重要性。</li><li><strong><code>16. 資料庫遷移工具 Flyway 入門</code></strong>: 介紹管理資料庫綱要 (Schema) 變更的生產級工具 Flyway。</li></ul><hr><h2 id="第三階段：應用程式健壯性與測試-共-5-篇"><a href="#第三階段：應用程式健壯性與測試-共-5-篇" class="headerlink" title="第三階段：應用程式健壯性與測試 (共 5 篇)"></a><strong>第三階段：應用程式健壯性與測試 (共 5 篇)</strong></h2><p>此階段將提升您應用程式的品質與可靠性。</p><ul><li><strong><code>17. YML 組態檔與多環境管理 (Profiles)</code></strong>: 學習使用 <code>application.yml</code>，並透過 Profiles 管理不同環境的組態。</li><li><strong><code>18. 型別安全的組態屬性 (@ConfigurationProperties)</code></strong>: 學習將 YML 設定檔映射到 Java 物件，提供更安全的組態管理方式。</li><li><strong><code>19. 全域例外處理 (@ControllerAdvice)</code></strong>: 建立統一的例外處理機制，讓 API 回應的錯誤訊息更標準化。</li><li><strong><code>20. 單元測試：Mockito 與 Service 層測試</code></strong>: 使用 Mockito 來模擬依賴，專注於測試單一 Service 的業務邏輯。</li><li><strong><code>21. 整合測試：MockMvc 與 Controller 層測試</code></strong>: 使用 MockMvc 來模擬 HTTP 請求，對 Controller 層的 API 進行完整的整合測試。</li></ul><hr><h2 id="第四階段：安全性專題-共-3-篇"><a href="#第四階段：安全性專題-共-3-篇" class="headerlink" title="第四階段：安全性專題 (共 3 篇)"></a><strong>第四階段：安全性專題 (共 3 篇)</strong></h2><p>此階段將聚焦於保護您的應用程式，是現代 Web 開發不可或缺的一環。</p><ul><li><strong><code>22. Spring Security 基礎與 Filter Chain</code></strong>: 踏入 Spring Security 的世界，了解其運作原理，並設定第一個安全過濾鏈。</li><li><strong><code>23. 基於資料庫的使用者驗證</code></strong>: 實作 <code>UserDetailsService</code>，讓 Spring Security 從您的資料庫中讀取使用者資訊。</li><li><strong><code>24. 整合 JWT 實現無狀態驗證</code></strong>: 學習使用 JSON Web Token (JWT) 來保護您的 RESTful API。</li></ul><hr><h2 id="第五階段：生產力、部署與總結-共-6-篇"><a href="#第五階段：生產力、部署與總結-共-6-篇" class="headerlink" title="第五階段：生產力、部署與總結 (共 6 篇)"></a><strong>第五階段：生產力、部署與總結 (共 6 篇)</strong></h2><p>此階段將帶領您學習更多實用功能，並完成從程式碼到可部署產物的最後一哩路。</p><ul><li><strong><code>25. AOP 切面導向程式設計</code></strong>: 學習 AOP 的概念，並實作一個日誌切面 (Logging Aspect) 來統一記錄請求資訊。</li><li><strong><code>26. 非同步 (@Async) 與排程 (@Scheduled) 任務</code></strong>: 學習如何將耗時任務非同步化，以及如何建立定時執行的排程工作。</li><li><strong><code>27. 使用 Spring Mail 寄送電子郵件</code></strong>: 整合 Spring Mail，為您的應用加入郵件寄送功能。</li><li><strong><code>28. 檔案上傳與下載</code></strong>: 實作常見的檔案處理功能，建立能夠接收與提供檔案下載的 API。</li><li><strong><code>29. 使用 Buildpacks 建置 Docker 映像檔</code></strong>: 學習使用 Maven 命令，輕鬆地將您的應用打包成 Docker 容器。</li><li><strong><code>30. 部署至雲端平台 (初步探討)</code></strong>: 作為系列的總結，探討將應用程式部署到主流雲端平台的基本思路。</li></ul><hr><p>請跟隨我們的腳步，從下一篇文章「<code>Spring Boot 02 - 專案結構與核心概念</code>」開始，一起動手實作，逐步揭開 Spring Boot 強大而優雅的面紗。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
          <category> Spring Boot 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 插件：建立 Spring Boot 專案 (含 Lombok)</title>
      <link href="/2025/08/08/ide-plugin-01/"/>
      <url>/2025/08/08/ide-plugin-01/</url>
      
        <content type="html"><![CDATA[<p>Visual Studio Code 透過其豐富的插件生態系，可以搖身一變成為一個功能強大的 Java 與 Spring Boot 開發環境。本篇文章將引導您安裝必要的 VSCode 插件，並從零開始建立、執行與偵錯一個整合了 Lombok 以提升開發效率的 Spring Boot 專案。</p><h2 id="步驟一：前置準備"><a href="#步驟一：前置準備" class="headerlink" title="步驟一：前置準備"></a>步驟一：前置準備</h2><p>在開始之前，請確保您的開發環境已經具備以下條件。若尚未完成，請參考對應的教學文章進行設定。</p><ol><li><strong>安裝並設定好 JDK</strong>：<ul><li>請參考：<strong>「教學：BellSoft Liberica JDK 下載、安裝與設定」</strong></li></ul></li><li><strong>安裝並設定好 Maven</strong>：<ul><li>請參考：<strong>「教學：Apache Maven 下載、安裝與設定使用說明」</strong></li></ul></li></ol><h2 id="步驟二：安裝必要的-VSCode-插件"><a href="#步驟二：安裝必要的-VSCode-插件" class="headerlink" title="步驟二：安裝必要的 VSCode 插件"></a>步驟二：安裝必要的 VSCode 插件</h2><p>為了獲得完整的 Java、Spring Boot 及 Lombok 開發體驗，我們需要安裝幾個核心的擴充功能。</p><ol><li>開啟 VSCode。</li><li>點擊左側活動列的「延伸模組」圖示。</li><li>在搜尋框中，分別搜尋並安裝以下三個插件：</li></ol><h3 id="1-Extension-Pack-for-Java"><a href="#1-Extension-Pack-for-Java" class="headerlink" title="1. Extension Pack for Java"></a>1. Extension Pack for Java</h3><p>這是一個由 Microsoft 提供的 Java 開發必備插件合集，它包含了語言支援、偵錯器、測試框架與 Maven 整合等核心功能。</p><p>![安裝 Extension Pack for Java]</p><h3 id="2-Spring-Boot-Extension-Pack"><a href="#2-Spring-Boot-Extension-Pack" class="headerlink" title="2. Spring Boot Extension Pack"></a>2. Spring Boot Extension Pack</h3><p>這個插件包專為 Spring Boot 開發而設計，提供了包含 Spring Initializr 專案產生器、應用程式儀表板等便利工具。</p><p>![安裝 Spring Boot Extension Pack]</p><h3 id="3-Lombok-Annotations-Support-for-VS-Code"><a href="#3-Lombok-Annotations-Support-for-VS-Code" class="headerlink" title="3. Lombok Annotations Support for VS Code"></a>3. Lombok Annotations Support for VS Code</h3><p><strong>這是使用 Lombok 時必備的插件</strong>。雖然專案在編譯時可以透過 Maven 正確處理 Lombok，但若沒有此插件，VSCode 編輯器本身將無法理解 <code>@Data</code>, <code>@Getter</code>, <code>@Setter</code> 等 Lombok 註解。您會看到編輯器提示找不到方法 (例如 <code>getName()</code>) 的錯誤，且程式碼自動完成、定義跳轉等功能也將對這些由 Lombok 產生的方法失效。此插件能解決這些問題，讓開發體驗保持流暢。</p><p>![安裝 Lombok Annotations Support for VS Code]</p><p>安裝完成後，強烈建議重新啟動 VSCode，確保所有插件都已正確載入。</p><h2 id="步驟三：建立一個新的-Spring-Boot-專案"><a href="#步驟三：建立一個新的-Spring-Boot-專案" class="headerlink" title="步驟三：建立一個新的 Spring Boot 專案"></a>步驟三：建立一個新的 Spring Boot 專案</h2><p>安裝好插件後，我們就可以使用 Spring Initializr 來快速產生專案骨架。</p><ol><li>開啟<strong>命令選擇區</strong> (<code>F1</code> 或 <code>Ctrl+Shift+P</code>)。</li><li>輸入並選擇 <code>Spring Initializr: Create a Maven Project...</code>。</li><li>接下來，VSCode 會引導您完成一系列的設定：<ul><li><strong>Select Spring Boot version</strong>：選擇一個穩定的 Spring Boot 版本。</li><li><strong>Specify project language</strong>：選擇 <code>Java</code>。</li><li><strong>Input Group Id</strong>：例如：<code>com.example</code>。</li><li><strong>Input Artifact Id</strong>：例如：<code>demo-app</code>。</li><li><strong>Specify packaging type</strong>：選擇 <code>Jar</code>。</li><li><strong>Specify Java version</strong>：選擇您已安裝的 JDK 版本。</li><li><strong>Search for dependencies</strong>：選擇您的專案需要用到的「起步依賴 (Starters)」。請務必選擇以下幾項：<ul><li><code>Spring Web</code>: 用於建構 RESTful API。</li><li><code>Spring Boot DevTools</code>: 提供開發時的便利功能，如自動重啟。</li><li><code>Lombok</code>: <strong>這就是我們稍早安裝 Lombok 插件的原因</strong>。它能大幅簡化 Java 的樣板程式碼。<br>選擇完畢後，按下 <code>Enter</code> 鍵確認。</li></ul></li></ul></li><li>最後，選擇一個您想存放專案的資料夾，VSCode 就會開始產生專案並自動開啟它。</li></ol><h2 id="步驟四：執行與測試專案"><a href="#步驟四：執行與測試專案" class="headerlink" title="步驟四：執行與測試專案"></a>步驟四：執行與測試專案</h2><p>專案建立後，讓我們透過一個使用了 Lombok 的範例來實際感受它的便利性。</p><h3 id="1-建立一個使用-Lombok-的資料傳輸物件-DTO"><a href="#1-建立一個使用-Lombok-的資料傳輸物件-DTO" class="headerlink" title="1. 建立一個使用 Lombok 的資料傳輸物件 (DTO)"></a>1. 建立一個使用 Lombok 的資料傳輸物件 (DTO)</h3><p>在 <code>com.example.demoapp</code> 套件下，建立一個新檔案 <code>Message.java</code>。使用 <code>@Data</code> 註解，Lombok 會在背景自動為我們產生 <code>getter</code>, <code>setter</code>, <code>toString</code>, <code>equals</code> 和 <code>hashCode</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">// Lombok 會自動產生 Getters, Setters, toString, ...等方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String content;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalDateTime timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-建立一個-REST-Controller"><a href="#2-建立一個-REST-Controller" class="headerlink" title="2. 建立一個 REST Controller"></a>2. 建立一個 REST Controller</h3><p>接著，在同一個套件下建立 <code>HelloController.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demoapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 直接使用 Lombok 產生的建構函式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Greetings from Spring Boot and Lombok!&quot;</span>, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：即使 <code>Message</code> 類別中沒有手動撰寫任何 <code>getter</code> 方法，但在這裡回傳 <code>Message</code> 物件時，Spring 的 Jackson 函式庫依然能正確地呼叫到由 Lombok 產生的 <code>getter</code> 方法，並將其序列化為 JSON 格式。</p><h3 id="3-執行應用"><a href="#3-執行應用" class="headerlink" title="3. 執行應用"></a>3. 執行應用</h3><ul><li>在左側的 <strong>Spring Boot Dashboard</strong> 中，找到您的 <code>demo-app</code>。</li><li>點擊旁邊的<strong>播放按鈕 (Start)</strong> 來啟動應用程式。</li><li>當下方的「偵錯主控台」顯示 <code>Tomcat started on port(s): 8080</code> 時，表示服務已成功啟動。</li></ul><h3 id="4-測試-API"><a href="#4-測試-API" class="headerlink" title="4. 測試 API"></a>4. 測試 API</h3><p>打開瀏覽器訪問 <code>http://localhost:8080/hello</code>。您應該會看到一段 JSON 回應，類似：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Greetings from Spring Boot and Lombok!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-08-08T14:05:20.123456&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="步驟五：偵錯應用程式"><a href="#步驟五：偵錯應用程式" class="headerlink" title="步驟五：偵錯應用程式"></a>步驟五：偵錯應用程式</h2><ol><li><strong>設定中斷點</strong>：回到 <code>HelloController.java</code>，在 <code>return new Message(...)</code> 這一行的行號左側點擊，建立一個中斷點 (紅點)。</li><li><strong>以偵錯模式啟動</strong>：在 Spring Boot Dashboard 中，點擊應用旁邊的**偵錯按鈕 (Debug)**。</li><li><strong>觸發中斷點</strong>：再次用瀏覽器訪問 <code>http://localhost:8080/hello</code>。</li><li>VSCode 會在您設定的中斷點上暫停。此時，您可以利用偵錯工具來檢查程式狀態。關於偵錯工具的詳細使用，請參考：<strong>「VSCode 06 - 執行與偵錯 (Debugging)」</strong>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
          <category> VSCode </category>
          
          <category> Plugin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> VSCode </tag>
            
            <tag> Extension </tag>
            
            <tag> Plugin </tag>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> 整合開發環境 </tag>
            
            <tag> 插件 </tag>
            
            <tag> 外掛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Env 02 - Apache Maven 下載、安裝與設定</title>
      <link href="/2025/08/08/java-env-02/"/>
      <url>/2025/08/08/java-env-02/</url>
      
        <content type="html"><![CDATA[<h1 id="什麼是-Apache-Maven？"><a href="#什麼是-Apache-Maven？" class="headerlink" title="什麼是 Apache Maven？"></a>什麼是 Apache Maven？</h1><p>Apache Maven 是一個強大的專案管理工具，它基於專案物件模型 (Project Object Model, POM) 的概念，將專案的建置、報告和文件管理標準化。其核心功能包括：</p><ul><li>**相依性管理 (Dependency Management)**：自動下載專案所需的函式庫 (JAR 檔案)，您無需手動尋找與管理。</li><li>**標準化的建置生命週期 (Standard Build Lifecycle)**：提供一組清晰的命令 (如 <code>compile</code>, <code>test</code>, <code>package</code>) 來處理整個建置流程。</li><li><strong>專案資訊一致性</strong>：透過 <code>pom.xml</code> 檔案集中管理專案的所有設定。</li></ul><h2 id="步驟一：前置準備-確認-JDK-環境"><a href="#步驟一：前置準備-確認-JDK-環境" class="headerlink" title="步驟一：前置準備 - 確認 JDK 環境"></a>步驟一：前置準備 - 確認 JDK 環境</h2><p>Maven 本身是用 Java 編寫的，因此執行 Maven 必須要有 JDK (Java Development Kit) 環境。</p><p>在開始之前，請確保您已完成 JDK 的安裝與環境變數 <code>JAVA_HOME</code> 的設定。若尚未完成，請參考：<strong>「BellSoft Liberica JDK 下載安裝設定使用說明」</strong>。</p><h2 id="步驟二：下載-Maven"><a href="#步驟二：下載-Maven" class="headerlink" title="步驟二：下載 Maven"></a>步驟二：下載 Maven</h2><ol><li><strong>前往官網</strong>：開啟瀏覽器，前往 <a href="https://maven.apache.org/download.cgi">Apache Maven 官方網站下載頁面</a>。</li><li><strong>下載壓縮檔</strong>：在 “Files” 區塊中，找到最新的 Maven 版本。<ul><li><strong>Windows 使用者</strong>：下載 “Binary zip archive”，例如 <code>apache-maven-3.9.8-bin.zip</code>。</li><li><strong>macOS &#x2F; Linux 使用者</strong>：下載 “Binary tar.gz archive”，例如 <code>apache-maven-3.9.8-bin.tar.gz</code>。</li></ul></li></ol><h2 id="步驟三：安裝-Maven"><a href="#步驟三：安裝-Maven" class="headerlink" title="步驟三：安裝 Maven"></a>步驟三：安裝 Maven</h2><p>Maven 的安裝過程是手動解壓縮，沒有圖形化的安裝精靈。</p><ol><li><strong>建立安裝目錄</strong>：建議在一個固定的位置建立 Maven 的安裝目錄。<ul><li><strong>Windows</strong>: <code>C:\Program Files\Maven</code></li><li><strong>macOS &#x2F; Linux</strong>: <code>/usr/local/</code> 或 <code>~/</code></li></ul></li><li><strong>解壓縮檔案</strong>：將您下載的壓縮檔解壓縮到剛建立的目錄中。最終的路徑會類似 <code>C:\Program Files\Maven\apache-maven-3.9.8</code>。</li></ol><h2 id="步驟四：設定環境變數"><a href="#步驟四：設定環境變數" class="headerlink" title="步驟四：設定環境變數"></a>步驟四：設定環境變數</h2><p>此步驟是為了讓您的作業系統可以在任何路徑下找到 Maven 命令。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ol><li>依照前一篇 JDK 教學的方式，開啟「環境變數」設定視窗。</li><li>在「系統變數」區塊中，點擊「新增」。<ul><li><strong>變數名稱</strong>: <code>M2_HOME</code> (或 <code>MAVEN_HOME</code>)</li><li><strong>變數值</strong>: <code>C:\Program Files\Maven\apache-maven-3.9.8</code> (請根據您的實際解壓縮路徑修改)</li></ul></li><li>找到並編輯 <code>Path</code> 變數，點擊「新增」，然後輸入 <code>%M2_HOME%\bin</code>。</li><li>逐層點擊「確定」儲存設定。</li></ol><h3 id="macOS-amp-Linux"><a href="#macOS-amp-Linux" class="headerlink" title="macOS &amp; Linux"></a>macOS &amp; Linux</h3><p>編輯您 shell 的設定檔 (例如 <code>~/.zshrc</code> 或 <code>~/.bash_profile</code>)。</p><ol><li><strong>開啟設定檔</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open ~/.zshrc</span><br></pre></td></tr></table></figure></li><li><strong>加入以下內容</strong> (請根據您的實際解壓縮路徑修改)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Apache Maven</span></span><br><span class="line"><span class="built_in">export</span> M2_HOME=<span class="string">&quot;/usr/local/apache-maven-3.9.8&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$M2_HOME</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>讓設定生效</strong>：儲存檔案後，執行 <code>source ~/.zshrc</code> 或<strong>重新開啟一個新的終端機視窗</strong>。</li></ol><h2 id="步驟五：驗證安裝"><a href="#步驟五：驗證安裝" class="headerlink" title="步驟五：驗證安裝"></a>步驟五：驗證安裝</h2><p><strong>打開一個新的終端機視窗</strong>，並執行以下指令來驗證 Maven 是否安裝成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -version</span><br></pre></td></tr></table></figure><p>如果設定正確，您會看到類似以下的輸出，其中包含了 Maven 版本以及它所偵測到的 Java 版本與 <code>JAVA_HOME</code> 路徑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Apache Maven 3.9.8 (....)</span><br><span class="line">Maven home: C:\Program Files\Maven\apache-maven-3.9.8</span><br><span class="line">Java version: 21.0.2, vendor: BellSoft, runtime: C:\Program Files\BellSoft\LibericaJDK-21</span><br><span class="line">Default locale: zh_TW, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;windows 11&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot;</span><br></pre></td></tr></table></figure><h2 id="步驟六：建立並建置您的第一個-Maven-專案"><a href="#步驟六：建立並建置您的第一個-Maven-專案" class="headerlink" title="步驟六：建立並建置您的第一個 Maven 專案"></a>步驟六：建立並建置您的第一個 Maven 專案</h2><p>驗證成功後，讓我們來使用 Maven 建立一個標準的 Java 專案。</p><h3 id="1-建立專案"><a href="#1-建立專案" class="headerlink" title="1. 建立專案"></a>1. 建立專案</h3><p>在您的工作目錄下 (例如 <code>Desktop</code> 或 <code>Documents</code>)，打開終端機並執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>此指令會使用 <code>maven-archetype-quickstart</code> 範本，快速建立一個名為 <code>my-app</code> 的專案。</p><h3 id="2-專案結構"><a href="#2-專案結構" class="headerlink" title="2. 專案結構"></a>2. 專案結構</h3><p>指令完成後，您會看到一個名為 <code>my-app</code> 的資料夾，其結構如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">my-app/</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   └── java</span><br><span class="line">    │       └── com</span><br><span class="line">    │           └── mycompany</span><br><span class="line">    │               └── app</span><br><span class="line">    │                   └── App.java</span><br><span class="line">    └── test</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── mycompany</span><br><span class="line">                    └── app</span><br><span class="line">                        └── AppTest.java</span><br></pre></td></tr></table></figure><ul><li><code>pom.xml</code>: Maven 的核心設定檔，定義了專案資訊、相依性等。</li><li><code>src/main/java</code>: 存放主要程式碼的地方。</li><li><code>src/test/java</code>: 存放測試程式碼的地方。</li></ul><h3 id="3-主要建置命令"><a href="#3-主要建置命令" class="headerlink" title="3. 主要建置命令"></a>3. 主要建置命令</h3><p>進入專案資料夾 <code>cd my-app</code>，並執行以下常用的 Maven 命令：</p><ul><li><p>**編譯 (Compile)**：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure><p>此命令會編譯 <code>src/main/java</code> 下的所有 Java 檔案，並將產生的 <code>.class</code> 檔案放到 <code>target/classes</code> 目錄下。</p></li><li><p>**測試 (Test)**：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>此命令會先執行編譯，然後運行 <code>src/test/java</code> 下的所有測試案例。</p></li><li><p>**打包 (Package)**：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>這是最常用的命令之一。它會依序執行編譯、測試，然後將專案打包成一個 JAR 檔案，存放於 <code>target/</code> 目錄下 (例如 <code>my-app-1.0-SNAPSHOT.jar</code>)。</p></li><li><p>**清理 (Clean)**：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure><p>此命令會刪除 <code>target/</code> 目錄，清除所有先前建置的產物。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java環境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 01 JDK安裝教學</title>
      <link href="/2025/08/02/java-env-01/"/>
      <url>/2025/08/02/java-env-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Development-Kit"><a href="#Java-Development-Kit" class="headerlink" title="Java Development Kit"></a>Java Development Kit</h1><p>這篇文章將引導您如何下載、安裝並設定 BellSoft Liberica JDK，這是一個免費、經過 TCK 驗證且廣受好評的 OpenJDK 發行版。完成後，您的開發環境將準備就緒，可以開始編譯並執行 Java 程式。</p><h2 id="什麼是-BellSoft-Liberica-JDK？"><a href="#什麼是-BellSoft-Liberica-JDK？" class="headerlink" title="什麼是 BellSoft Liberica JDK？"></a>什麼是 BellSoft Liberica JDK？</h2><p>BellSoft Liberica JDK 是一個 100% 開源、由 BellSoft 公司維護的 OpenJDK 建置版本。它提供了對多種平台（包括桌面、伺服器與嵌入式系統）的廣泛支援，並提供長期支援 (LTS) 版本，是 Oracle JDK 的一個絕佳替代方案。</p><h2 id="步驟一：下載-Liberica-JDK"><a href="#步驟一：下載-Liberica-JDK" class="headerlink" title="步驟一：下載 Liberica JDK"></a>步驟一：下載 Liberica JDK</h2><ol><li><p><strong>前往官網</strong>：開啟瀏覽器，前往 <a href="https://bell-sw.com/pages/downloads/">BellSoft 官方網站下載頁面</a>。</p></li><li><p><strong>選擇版本</strong>：在下載頁面中，您需要根據您的需求進行選擇：</p><ul><li>**Version (版本)**：建議選擇最新的 LTS (長期支援) 版本，例如 <code>21 LTS</code> 或 <code>17 LTS</code>，以獲得最佳的穩定性與安全性。</li><li>**Operating System (作業系統)**：選擇您的作業系統，如 <code>Windows</code>, <code>macOS</code>, 或 <code>Linux</code>。</li><li>**Architecture (架構)**：通常是 <code>x86_64</code> (適用於 Intel&#x2F;AMD 64位元處理器) 或 <code>arm64</code> (適用於 Apple Silicon M 系列晶片或其它 ARM 架構設備)。</li><li>**Package Type (套件類型)**：<ul><li><strong>Windows</strong>: 建議選擇 <code>.msi</code> (安裝包)。</li><li><strong>macOS</strong>: 建議選擇 <code>.pkg</code> (安裝包) 或 <code>.dmg</code>。</li><li><strong>Linux</strong>: 建議選擇 <code>.deb</code> (Debian&#x2F;Ubuntu) 或 <code>.rpm</code> (Fedora&#x2F;CentOS)。<code>.tar.gz</code> 則是通用的手動安裝壓縮檔。</li></ul></li><li>**JDK Type (JDK 類型)**：<ul><li><strong>Standard</strong>: 標準的 JDK。</li><li><strong>Full</strong>: 包含了 JavaFX 的完整版本，如果您需要開發圖形化介面應用，請選此項。</li></ul></li></ul></li><li><p><strong>下載</strong>：完成選擇後，點擊下載按鈕。</p></li></ol><h2 id="步驟二：安裝-JDK"><a href="#步驟二：安裝-JDK" class="headerlink" title="步驟二：安裝 JDK"></a>步驟二：安裝 JDK</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>執行您下載的 <code>.msi</code> 安裝檔。在安裝過程中，請務必在自訂安裝選項中，勾選「<strong>Set JAVA_HOME variable</strong>」的選項。這會讓安裝程式自動幫您設定最重要的 <code>JAVA_HOME</code> 環境變數。</p><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>執行您下載的 <code>.pkg</code> 安裝檔，並依照安裝精靈的指示完成即可。macOS 會自動將 <code>java</code> 指令加入到系統路徑中。</p><h3 id="Linux-使用-tar-gz-手動安裝"><a href="#Linux-使用-tar-gz-手動安裝" class="headerlink" title="Linux (使用 .tar.gz 手動安裝)"></a>Linux (使用 .tar.gz 手動安裝)</h3><p>這是最通用的手動安裝方法。</p><ol><li><strong>解壓縮檔案</strong>：將下載的 <code>.tar.gz</code> 檔案移動到您想安裝的位置 (例如 <code>/usr/local/</code> 或 <code>/opt/</code>)，並解壓縮。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假設檔案在 Downloads 目錄下</span></span><br><span class="line">sudo <span class="built_in">mv</span> ~/Downloads/bellsoft-jdk21-linux-amd64.tar.gz /usr/local/</span><br><span class="line"><span class="built_in">cd</span> /usr/local/</span><br><span class="line">sudo tar -xvf bellsoft-jdk21-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li>接下來，您需要手動設定環境變數。</li></ol><h2 id="步驟三：設定環境變數"><a href="#步驟三：設定環境變數" class="headerlink" title="步驟三：設定環境變數"></a>步驟三：設定環境變數</h2><p>這是確保系統能找到 Java 開發工具的關鍵步驟。如果您在 Windows 上安裝時已勾選自動設定，則可跳過 Windows 的部分。</p><h3 id="Windows-手動設定"><a href="#Windows-手動設定" class="headerlink" title="Windows (手動設定)"></a>Windows (手動設定)</h3><ol><li>在「本機」上按右鍵，選擇「內容」&gt;「進階系統設定」&gt;「環境變數」。</li><li>在「系統變數」區塊中，點擊「新增」。<ul><li><strong>變數名稱</strong>: <code>JAVA_HOME</code></li><li><strong>變數值</strong>: <code>C:\Program Files\BellSoft\LibericaJDK-21</code> (請根據您的實際安裝路徑修改)</li></ul></li><li>找到並編輯 <code>Path</code> 變數，點擊「新增」，然後輸入 <code>%JAVA_HOME%\bin</code>。</li><li>逐層點擊「確定」儲存設定。</li></ol><h3 id="macOS-amp-Linux"><a href="#macOS-amp-Linux" class="headerlink" title="macOS &amp; Linux"></a>macOS &amp; Linux</h3><p>編輯您 shell 的設定檔。如果您使用 <code>zsh</code> (macOS 預設)，請編輯 <code>~/.zshrc</code>；如果使用 <code>bash</code>，請編輯 <code>~/.bash_profile</code> 或 <code>~/.bashrc</code>。</p><ol><li><strong>開啟設定檔</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zsh 使用者</span></span><br><span class="line">open ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># bash 使用者</span></span><br><span class="line">open ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><strong>加入以下內容</strong> (請根據您的實際安裝路徑修改)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Liberica JDK</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="string">&quot;/usr/local/jdk-21&quot;</span>  <span class="comment"># macOS 的路徑可能是 /Library/Java/JavaVirtualMachines/liberica-jdk-21.jdk/Contents/Home</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>讓設定生效</strong>：儲存檔案後，執行以下命令或<strong>重新開啟一個新的終端機視窗</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zsh 使用者</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># bash 使用者</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ol><h2 id="步驟四：驗證安裝"><a href="#步驟四：驗證安裝" class="headerlink" title="步驟四：驗證安裝"></a>步驟四：驗證安裝</h2><p><strong>打開一個新的終端機視窗</strong> (非常重要，這樣才能載入新的環境變數)，並執行以下指令。</p><ol><li><p><strong>檢查 Java 版本</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>您應該會看到類似以下的輸出，其中包含 “Liberica” 字樣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version &quot;21.0.2&quot; 2024-01-16</span><br><span class="line">OpenJDK Runtime Environment BellSoft-24.0.1 (build 21.0.2+14)</span><br><span class="line">OpenJDK 64-Bit Server VM BellSoft-24.0.1 (build 21.0.2+14, mixed mode, sharing)</span><br></pre></td></tr></table></figure></li><li><p><strong>檢查 Java 編譯器版本</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -version</span><br></pre></td></tr></table></figure></li><li><p><strong>檢查 JAVA_HOME 變數</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows</span></span><br><span class="line"><span class="built_in">echo</span> %JAVA_HOME%</span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS / Linux</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br></pre></td></tr></table></figure><p>此命令應輸出您剛剛設定的 JDK 安裝路徑。</p></li></ol><h2 id="開始使用"><a href="#開始使用" class="headerlink" title="開始使用"></a>開始使用</h2><p>恭喜！您的 Liberica JDK 環境已經設定完成。現在您可以開始編譯並執行您的第一個 Java 程式了。</p><ol><li>建立一個名為 <code>HelloWorld.java</code> 的檔案：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, Liberica JDK!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在終端機中，使用 <code>javac</code> 編譯它：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure></li><li>使用 <code>java</code> 執行編譯後的程式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure></li></ol><p>您將會在螢幕上看到 <code>Hello, Liberica JDK!</code> 的輸出。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java環境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 07 工作自動化 (Tasks)</title>
      <link href="/2025/07/30/vscode-07/"/>
      <url>/2025/07/30/vscode-07/</url>
      
        <content type="html"><![CDATA[<h1 id="工作自動化-Tasks"><a href="#工作自動化-Tasks" class="headerlink" title="工作自動化 (Tasks)"></a>工作自動化 (Tasks)</h1><p>在日常開發中，我們經常需要重複執行某些命令，例如：運行測試、檢查程式碼風格、啟動服務等。VSCode 的「工作 (Tasks)」功能允許您將這些命令配置起來，並透過簡單的快捷鍵或命令來執行，從而將這些重複性勞動自動化，確保一致性並節省寶貴時間。</p><h2 id="Task-的概念與用途"><a href="#Task-的概念與用途" class="headerlink" title="Task 的概念與用途"></a>Task 的概念與用途</h2><p>一個「Task」本質上是一個被 VSCode 記錄下來的預設命令列指令。它將外部工具或腳本與 VSCode 編輯器無縫整合。對於 Python 開發者而言，常見的用途包括：</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li><strong>執行測試</strong>：自動執行 <code>pytest</code> 或 <code>unittest</code> 來驗證程式碼的正確性。</li><li>**程式碼風格檢查 (Linting)**：使用 <code>pylint</code> 或 <code>flake8</code> 分析整個專案的程式碼品質。</li><li><strong>程式碼格式化</strong>：使用 <code>black</code> 或 <code>autopep8</code> 自動格式化專案檔案。</li><li><strong>啟動開發伺服器</strong>：執行 <code>flask run</code> 或 <code>python -m http.server</code> 來啟動一個本地服務。</li></ul><h2 id="設定-tasks-json"><a href="#設定-tasks-json" class="headerlink" title="設定 tasks.json"></a>設定 <code>tasks.json</code></h2><p>所有工作配置都儲存在專案的 <code>.vscode/tasks.json</code> 檔案中。</p><h3 id="建立-tasks-json-檔案："><a href="#建立-tasks-json-檔案：" class="headerlink" title="建立 tasks.json 檔案："></a>建立 <code>tasks.json</code> 檔案：</h3><pre><code>  * 開啟**命令選擇區** (`F1` 或 `Ctrl+Shift+P`)。  * 輸入 `Tasks: Configure Task` (工作: 設定工作)。  * 選擇「從範本建立 tasks.json 檔案 (Create tasks.json file from template)」。  * 在接下來的選單中，選擇「Others」，VSCode 會產生一個包含基本範例的 `tasks.json` 檔案。</code></pre><h3 id="Task-的基本結構："><a href="#Task-的基本結構：" class="headerlink" title="Task 的基本結構："></a>Task 的基本結構：</h3><pre><code>一個最簡單的 Task 看起來像這樣：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Say Hello&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo &#x27;Hello, World!&#x27;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>  * `&quot;label&quot;`: 工作的名稱，會顯示在命令選擇區中，方便您辨識。  * `&quot;type&quot;`: 工作的類型，`shell` 是最常用的，表示此命令將在系統的預設 shell (如 PowerShell, bash) 中執行。  * `&quot;command&quot;`: 實際要執行的命令。</code></pre><h2 id="實用範例"><a href="#實用範例" class="headerlink" title="實用範例"></a>實用範例</h2><p>讓我們來看幾個 Python 開發中非常實用的 Task 設定。</p><h3 id="範例-1：執行-Pytest-測試"><a href="#範例-1：執行-Pytest-測試" class="headerlink" title="範例 1：執行 Pytest 測試"></a>範例 1：執行 Pytest 測試</h3><p>假設您的專案使用 <code>pytest</code> 來進行測試。</p><ul><li><p><strong>前置條件</strong>：請先安裝 pytest (<code>pip install pytest</code>)。</p></li><li><p><strong><code>tasks.json</code> 設定</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Run Pytest&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pytest -v&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;presentation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;reveal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;panel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;new&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>&quot;group&quot;</code>: 將此工作歸類。<code>&quot;kind&quot;: &quot;test&quot;</code> 把它標記為一個測試工作，<code>&quot;isDefault&quot;: true</code> 讓它成為預設的測試工作。這樣您就可以直接透過「工作: 執行測試工作」命令來快速啟動它。</li><li><code>&quot;presentation&quot;</code>: 控制終端機面板的行為。<code>&quot;reveal&quot;: &quot;always&quot;</code> 確保每次執行都會顯示終端機。</li></ul></li><li><p><strong>如何執行</strong>：開啟命令選擇區，輸入 <code>Tasks: Run Task</code>，然後選擇 <code>Run Pytest</code>。</p></li></ul><h3 id="範例-2：使用-Pylint-檢查程式碼"><a href="#範例-2：使用-Pylint-檢查程式碼" class="headerlink" title="範例 2：使用 Pylint 檢查程式碼"></a>範例 2：使用 Pylint 檢查程式碼</h3><p><code>Pylint</code> 是一個強大的 Python 程式碼分析工具。透過 Task 整合它，可以讓 VSCode 直接捕獲並顯示問題。</p><ul><li><p><strong>前置條件</strong>：請先安裝 Pylint (<code>pip install pylint</code>)。</p></li><li><p><strong><code>tasks.json</code> 設定</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Lint with Pylint&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pylint src/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$pylint&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>&quot;command&quot;</code>: 假設您的 Python 程式碼都放在 <code>src/</code> 資料夾下。</li><li><code>&quot;problemMatcher&quot;</code>: 這是 Task 最強大的功能之一。它告訴 VSCode 如何解析 <code>pylint</code> 的輸出。<code>&quot;$pylint&quot;</code> 是一個內建的範本，使用後，VSCode 會自動讀取 Pylint 報告的錯誤和警告，並將它們顯示在編輯器的「問題 (Problems)」面板中，甚至在程式碼對應位置畫上波浪線，讓您一點擊就能跳轉到問題點。</li></ul></li></ul><h3 id="範例-3：啟動一個背景服務"><a href="#範例-3：啟動一個背景服務" class="headerlink" title="範例 3：啟動一個背景服務"></a>範例 3：啟動一個背景服務</h3><p>有時您需要一個長時間運行的背景服務，例如一個簡單的 Web 伺服器。</p><ul><li><p><strong><code>tasks.json</code> 設定</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Start Simple HTTP Server&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;python -m http.server 8000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isBackground&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>&quot;isBackground&quot;: true</code>: 告知 VSCode 這是一個不會自動終止的背景工作。VSCode 不會等待它執行完畢，並且您可以在它運行時繼續執行其他 Task。</li><li><code>&quot;problemMatcher&quot;: []</code>: 對於這種只會輸出狀態日誌的服務，我們通常會禁用問題匹配器，以避免 VSCode 誤判日誌內容為錯誤訊息。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
          <category> VSCode </category>
          
          <category> VSCode 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> VSCode </tag>
            
            <tag> 整合開發環境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 06 執行與偵錯</title>
      <link href="/2025/07/30/vscode-06/"/>
      <url>/2025/07/30/vscode-06/</url>
      
        <content type="html"><![CDATA[<h1 id="執行與偵錯"><a href="#執行與偵錯" class="headerlink" title="執行與偵錯"></a>執行與偵錯</h1><p>只用 <code>print()</code> 來檢查程式碼是許多初學者的直覺反應，但這種方式效率低落且無法應對複雜邏輯。VSCode 提供了功能完整且視覺化的偵錯工具，讓您能夠像偵探一樣，深入程式內部，觀察其一舉一動，從而快速定位並解決問題。</p><h2 id="偵錯的基本概念與介面"><a href="#偵錯的基本概念與介面" class="headerlink" title="偵錯的基本概念與介面"></a>偵錯的基本概念與介面</h2><p>首先，點擊左側活動列的「執行與偵錯」圖示 (帶有小蟲的播放按鈕) 進入偵錯面板。當偵錯工作階段啟動並暫停時，您會看到幾個關鍵的資訊窗格：</p><h3 id="變數-Variables-："><a href="#變數-Variables-：" class="headerlink" title="變數 (Variables)："></a>變數 (Variables)：</h3><p>顯示目前範圍內 (本機、全域) 所有變數的即時狀態。</p><h3 id="監看式-Watch-："><a href="#監看式-Watch-：" class="headerlink" title="監看式 (Watch)："></a>監看式 (Watch)：</h3><p>您可以手動新增想持續觀察的變數或運算式。</p><h3 id="呼叫堆疊-Call-Stack-："><a href="#呼叫堆疊-Call-Stack-：" class="headerlink" title="呼叫堆疊 (Call Stack)："></a>呼叫堆疊 (Call Stack)：</h3><p>顯示程式執行到目前位置所經過的函式呼叫順序，幫助您追蹤程式流程。</p><h3 id="偵錯主控台-Debug-Console-："><a href="#偵錯主控台-Debug-Console-：" class="headerlink" title="偵錯主控台 (Debug Console)："></a>偵錯主控台 (Debug Console)：</h3><p>一個互動式的命令列，您可以在程式暫停時，輸入運算式或執行命令來檢視當前狀態。</p><h3 id="偵錯工具列-Debug-Toolbar-："><a href="#偵錯工具列-Debug-Toolbar-：" class="headerlink" title="偵錯工具列 (Debug Toolbar)："></a>偵錯工具列 (Debug Toolbar)：</h3><p>一個浮動工具列，提供控制程式執行的所有命令。</p><table><thead><tr><th align="left">圖示</th><th align="left">命令</th><th align="left">快捷鍵</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">▶️</td><td align="left">繼續 (Continue)</td><td align="left"><code>F5</code></td><td align="left">讓程式繼續執行，直到下一個中斷點或程式結束。</td></tr><tr><td align="left">↪️</td><td align="left">不進入函式 (Step Over)</td><td align="left"><code>F10</code></td><td align="left">執行目前這一行，然後移至下一行。若此行為函式呼叫，不會進入函式內部。</td></tr><tr><td align="left">🔽</td><td align="left">進入函式 (Step Into)</td><td align="left"><code>F11</code></td><td align="left">如果此行為函式呼叫，則進入該函式內部，從函式的第一行開始執行。</td></tr><tr><td align="left">🔼</td><td align="left">跳出函式 (Step Out)</td><td align="left"><code>Shift+F11</code></td><td align="left">執行完目前所在的函式，然後回到呼叫此函式的地方。</td></tr><tr><td align="left">🔄</td><td align="left">重新啟動 (Restart)</td><td align="left"><code>Ctrl+Shift+F5</code></td><td align="left">重新開始一次新的偵錯工作階段。</td></tr><tr><td align="left">⏹️</td><td align="left">停止 (Stop)</td><td align="left"><code>Shift+F5</code></td><td align="left">終止偵錯。</td></tr></tbody></table><h2 id="啟動設定-launch-json"><a href="#啟動設定-launch-json" class="headerlink" title="啟動設定 (launch.json)"></a>啟動設定 (launch.json)</h2><p><code>launch.json</code> 檔案告訴 VSCode 如何設定並啟動一個偵錯工作階段。</p><h3 id="建立設定檔："><a href="#建立設定檔：" class="headerlink" title="建立設定檔："></a>建立設定檔：</h3><ul><li>在「執行與偵錯」面板中，點擊「建立 launch.json 檔案」的連結。</li><li>在彈出的選單中，選擇偵錯工具「Python Debugger」。</li><li>接著，選擇偵錯設定「Python File」。VSCode 會在您的專案根目錄下建立一個 <code>.vscode</code> 資料夾，並在其中產生 <code>launch.json</code> 檔案。</li></ul><h3 id="基本設定解析："><a href="#基本設定解析：" class="headerlink" title="基本設定解析："></a>基本設定解析：</h3><p>產生的預設設定通常如下，它表示「偵錯目前在編輯器中開啟的 Python 檔案」。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Python: Current File&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debugpy&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;console&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integratedTerminal&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>&quot;name&quot;</code>: 顯示在偵錯選單中的設定名稱。</li><li><code>&quot;type&quot;</code>: 指定要使用的偵錯器類型，此處為 <code>debugpy</code>。</li><li><code>&quot;request&quot;</code>: <code>launch</code> 表示由 VSCode 啟動一個新程序。</li><li><code>&quot;program&quot;</code>: 要執行的程式路徑。<code>$&#123;file&#125;</code> 是個特殊變數，代表「目前作用中的檔案」。</li></ul><h2 id="設定中斷點與偵錯流程"><a href="#設定中斷點與偵錯流程" class="headerlink" title="設定中斷點與偵錯流程"></a>設定中斷點與偵錯流程</h2><p>現在，讓我們實際偵錯一段有問題的程式碼。</p><h3 id="有問題的範例-main-py："><a href="#有問題的範例-main-py：" class="headerlink" title="有問題的範例 main.py："></a>有問題的範例 <code>main.py</code>：</h3><p>我們期望計算 1 到 5 的總和 (1+2+3+4+5 &#x3D; 15)，但程式卻給出了錯誤的答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_sum</span>(<span class="params">limit</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;計算從 1 到 limit 的數字總和&quot;&quot;&quot;</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 這裡有一個常見的 off-by-one 錯誤</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, limit):</span><br><span class="line">        total += i</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    result = calculate_sum(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 預期輸出: The sum is: 15</span></span><br><span class="line">    <span class="comment"># 實際輸出: The sum is: 10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;The sum is: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ol><li><p><strong>設定中斷點 (Breakpoint)</strong>：</p><ul><li>「中斷點」會讓程式在執行到該行時暫停下來。</li><li>在 <code>total += i</code> 這一行的行號左邊空白處點擊一下，會出現一個紅點，這就是中斷點。</li></ul></li><li><p><strong>啟動偵錯</strong>：</p><ul><li>確保 <code>main.py</code> 是您目前開啟的檔案。</li><li>按下 <code>F5</code> 鍵 (或點擊偵錯面板的綠色播放按鈕)。</li><li>程式會開始執行，並在紅點所在的那一行停下來，該行會被黃色背景標示。</li></ul></li><li><p><strong>檢查與追蹤</strong>：</p><ul><li><strong>檢查變數</strong>：此時，左側「變數」窗格會顯示 <code>limit</code> 是 <code>5</code>，<code>total</code> 是 <code>0</code>，<code>i</code> 是 <code>1</code>。您也可以直接在編輯器中將滑鼠懸停在變數上查看其值。</li><li><strong>單步執行</strong>：按下 <code>F10</code> (不進入函式) 執行 <code>total += i</code>。您會看到 <code>total</code> 的值變成了 <code>1</code>。</li><li><strong>繼續追蹤</strong>：重複按下 <code>F10</code>，觀察每一次迴圈後 <code>i</code> 和 <code>total</code> 的變化。當 <code>i</code> 的值變成 <code>4</code> 且執行完畢後，迴圈就結束了。</li><li><strong>發現問題</strong>：此時您會發現，<code>i</code> 從未達到 <code>5</code>，這就是 <code>range()</code> 函式終止值的特性所致。問題找到了！</li></ul></li><li><p><strong>停止與修正</strong>：</p><ul><li>按下 <code>Shift+F5</code> 停止偵錯。</li><li>將 <code>for i in range(1, limit):</code> 修改為 <code>for i in range(1, limit + 1):</code>。</li><li>再次按下 <code>F5</code> 執行偵錯，這次您會看到程式輸出了正確的結果 <code>15</code>。恭喜，您已完成一次完整的偵錯流程！ㄒ</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
          <category> VSCode </category>
          
          <category> VSCode 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> VSCode </tag>
            
            <tag> 整合開發環境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 05 原始碼控制 (Git 整合)</title>
      <link href="/2025/07/29/vscode-05/"/>
      <url>/2025/07/29/vscode-05/</url>
      
        <content type="html"><![CDATA[<h1 id="原始碼控制-Git-整合"><a href="#原始碼控制-Git-整合" class="headerlink" title="原始碼控制 (Git 整合)"></a>原始碼控制 (Git 整合)</h1><p>版本控制是現代軟體開發的基石，而 Git 是目前最流行的版本控制系統。VSCode 內建了極其強大的 Git 整合功能，讓您可以透過圖形化介面，直觀地完成絕大多數的日常版本控制操作，而無需頻繁地在終端機與編輯器之間切換。</p><blockquote><p>前置條件：<br>本篇教學假設您的電腦上已經成功安裝了 <a href="https://git-scm.com/downloads">Git</a>。</p></blockquote><h2 id="基本設定與初始化"><a href="#基本設定與初始化" class="headerlink" title="基本設定與初始化"></a>基本設定與初始化</h2><p>要開始使用，首先要讓 VSCode 知道您的專案是一個 Git 倉庫。</p><h3 id="初始化倉庫-Initialize-Repository-："><a href="#初始化倉庫-Initialize-Repository-：" class="headerlink" title="初始化倉庫 (Initialize Repository)："></a>初始化倉庫 (Initialize Repository)：</h3><ol><li>在 VSCode 中開啟您的專案資料夾。</li><li>點擊左側活動列的「原始碼控制」圖示 (一個分岔的圖案)。</li><li>如果專案尚未被 Git 管理，您會看到一個「初始化存放庫」的按鈕，點擊它。這個動作等同於在專案根目錄執行 <code>git init</code> 指令。</li></ol><h3 id="「原始碼控制」面板概覽："><a href="#「原始碼控制」面板概覽：" class="headerlink" title="「原始碼控制」面板概覽："></a>「原始碼控制」面板概覽：</h3><ul><li><p><strong>訊息框</strong>：位於最上方，用於輸入您的提交訊息 (Commit Message)。</p></li><li><p><strong>變更(Changes)</strong>：列出所有被修改過或新建立的檔案 (尚未被 Git 追蹤的檔案會標示為 <code>U</code>)。</p></li><li><p><strong>暫存的變更(Staged Changes)</strong>：列出已經被您加入到「暫存區」的檔案，這些檔案將會包含在下一次的提交中。</p></li></ul><h2 id="日常操作-Daily-Workflow"><a href="#日常操作-Daily-Workflow" class="headerlink" title="日常操作 (Daily Workflow)"></a>日常操作 (Daily Workflow)</h2><p>讓我們以一個 Python 檔案為例，走一遍最常見的「修改 -&gt; 暫存 -&gt; 提交」流程。</p><h3 id="做出變更："><a href="#做出變更：" class="headerlink" title="做出變更："></a>做出變更：</h3><ul><li>建立一個名為 <code>calculator.py</code> 的新檔案，並加入以下內容：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></li><li>儲存後，您會看到 <code>calculator.py</code> 出現在「變更」清單中。</li></ul><h3 id="暫存變更-Stage-Changes-："><a href="#暫存變更-Stage-Changes-：" class="headerlink" title="暫存變更 (Stage Changes)："></a>暫存變更 (Stage Changes)：</h3><ul><li>「暫存」是一個確認您希望將哪些變更納入下一次提交的動作。</li><li>將滑鼠移到 <code>calculator.py</code> 檔案旁，點擊 <code>+</code> 圖示。檔案便會從「變更」區移動到「暫存的變更」區。這個動作等同於 <code>git add calculator.py</code>。</li></ul><h3 id="提交變更-Commit-Changes-："><a href="#提交變更-Commit-Changes-：" class="headerlink" title="提交變更 (Commit Changes)："></a>提交變更 (Commit Changes)：</h3><ul><li>在訊息框中，輸入有意義的提交訊息，例如 <code>feat: Add initial calculator function</code>。</li><li>點擊上方的**打勾 (✓)**圖示，或按下 <code>Ctrl+Enter</code> (macOS 為 <code>Cmd+Enter</code>) 完成提交。這個動作等同於 <code>git commit -m &quot;Your Message&quot;</code>。</li></ul><h3 id="推送與拉取-Push-amp-Pull-："><a href="#推送與拉取-Push-amp-Pull-：" class="headerlink" title="推送與拉取 (Push &amp; Pull)："></a>推送與拉取 (Push &amp; Pull)：</h3><ul><li>提交後的變更還只存在您的本機。要將它們分享到遠端倉庫 (如 GitHub)，您需要「推送」。</li><li>點擊左下角狀態列的分支名稱旁的「同步變更」按鈕。此按鈕會先「拉取 (Pull)」遠端的變更，然後再「推送 (Push)」您本機的變更，確保兩邊同步。</li></ul><h2 id="分支管理-Branch-Management"><a href="#分支管理-Branch-Management" class="headerlink" title="分支管理 (Branch Management)"></a>分支管理 (Branch Management)</h2><p>分支是 Git 的核心功能之一，它讓您可以獨立於主線程 (例如 <code>main</code> 或 <code>master</code> 分支) 來開發新功能或修復錯誤。</p><h3 id="檢視與切換分支："><a href="#檢視與切換分支：" class="headerlink" title="檢視與切換分支："></a>檢視與切換分支：</h3><ul><li>點擊 VSCode 介面左下角的目前分支名稱 (例如 <code>main</code>)。</li><li>頂部會彈出一個選單，列出所有本機分支，點擊即可切換。</li></ul><h3 id="建立新分支："><a href="#建立新分支：" class="headerlink" title="建立新分支："></a>建立新分支：</h3><ul><li>同樣點擊左下角的分支名稱。</li><li>在彈出選單中選擇「+ 建立新分支…」。</li><li>輸入新分支的名稱，例如 <code>feature/subtract</code>，然後按下 <code>Enter</code>。VSCode 會自動為您建立並切換到這個新分支。</li></ul><h2 id="解決衝突-Resolving-Conflicts"><a href="#解決衝突-Resolving-Conflicts" class="headerlink" title="解決衝突 (Resolving Conflicts)"></a>解決衝突 (Resolving Conflicts)</h2><p>當您與團隊成員修改了同一個檔案的同一行程式碼時，合併分支就會產生「衝突」。VSCode 提供了優秀的視覺化工具來解決衝突。</p><ol><li><p><strong>製造一個衝突</strong>：</p><ul><li>假設在 <code>feature/subtract</code> 分支，您修改了 <code>calculator.py</code>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># calculator.py in feature/subtract branch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="comment"># Adds two numbers together</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></li><li>同時，另一位同事在 <code>main</code> 分支也修改了同一份檔案：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># calculator.py in main branch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="comment"># Function to add two numbers</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>合併與解決</strong>：</p><ul><li>當您試圖將 <code>main</code> 合併到 <code>feature/subtract</code> 時，VSCode 會偵測到衝突。</li><li>衝突的檔案會被標示出來，打開檔案，您會看到 VSCode 的**合併編輯器 (Merge Editor)**。</li><li>編輯器會清楚地標示出 <code>&lt;&lt;&lt;&lt;&lt; 目前的變更</code> (您分支上的) 和 <code>&gt;&gt;&gt;&gt;&gt; 傳入的變更</code> (要合併進來的分支上的)。</li><li>您可以點擊程式碼上方的按鈕：<ul><li><strong>接受目前的變更</strong></li><li><strong>接受傳入的變更</strong></li><li><strong>接受兩者</strong></li></ul></li><li>選擇您希望保留的程式碼版本，或手動編輯成最終想要的樣子。</li><li>解決所有衝突後，儲存檔案，並再次<strong>暫存</strong>與<strong>提交</strong>這個解決衝突的合併結果。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
          <category> VSCode </category>
          
          <category> VSCode 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> VSCode </tag>
            
            <tag> 整合開發環境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 04 整合式終端機</title>
      <link href="/2025/07/29/vscode-04/"/>
      <url>/2025/07/29/vscode-04/</url>
      
        <content type="html"><![CDATA[<h1 id="整合式終端機-Integrated-Terminal"><a href="#整合式終端機-Integrated-Terminal" class="headerlink" title="整合式終端機 (Integrated Terminal)"></a>整合式終端機 (Integrated Terminal)</h1><p>整合式終端機 (Integrated Terminal) 是 VSCode 的一項強大功能，它讓您能夠在編輯器介面中直接存取命令列，無需切換視窗。這意味著您可以一邊編寫程式碼，一邊執行 Git 指令、管理套件或運行腳本，從而打造一個無縫的開發工作流。</p><h2 id="開啟與管理"><a href="#開啟與管理" class="headerlink" title="開啟與管理"></a>開啟與管理</h2><p>管理終端機面板既快速又直觀。</p><ul><li><p><strong>開啟&#x2F;關閉</strong>：最快的方式是使用快捷鍵 <code>Ctrl + `</code> (此符號為反引號，通常在鍵盤的 <code>~</code> 鍵上)。您也可以從主選單的「檢視」 &gt; 「終端機」來開啟。</p></li><li><p><strong>建立多個終端機</strong>：</p><ul><li>點擊終端機面板右上角的 <code>+</code> 圖示，可以建立一個新的終端機分頁。</li><li>這對於需要同時執行多個任務的場景非常有用，例如：在一個終端機中運行 Web 伺服器，同時在另一個終端機中執行 Git 命令。</li></ul></li><li><p><strong>分割終端機</strong>：</p><ul><li>點擊 <code>+</code> 號旁邊的「分割終端機」圖示 (或按<code>Ctrl + Shift + 5</code>)，可以將目前的終端機畫面一分為二。</li><li>這讓您可以並排查看兩個終端機的輸出，便於監控不同的進程。</li></ul></li></ul><h2 id="常用指令與-Python-互動"><a href="#常用指令與-Python-互動" class="headerlink" title="常用指令與 Python 互動"></a>常用指令與 Python 互動</h2><p>終端機是與 Python 專案互動的核心。以下是在整合式終端機中常見的 Python 開發操作。</p><h3 id="執行-Python-腳本"><a href="#執行-Python-腳本" class="headerlink" title="執行 Python 腳本"></a>執行 Python 腳本</h3><ul><li>這是最基本的操作。假設您有一個名為 <code>app.py</code> 的檔案。</li><li>在終端機中，可以直接使用 <code>python</code> 命令來執行它。</li></ul><p>**範例 <code>app.py</code>**：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查是否有提供命令列參數</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    name = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span> from my script!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure></p><p><strong>在終端機中執行</strong>：<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本執行</span></span><br><span class="line">python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 帶有參數執行</span></span><br><span class="line">python app.py Gemini</span><br></pre></td></tr></table></figure></p><h3 id="管理-Python-虛擬環境"><a href="#管理-Python-虛擬環境" class="headerlink" title="管理 Python 虛擬環境"></a>管理 Python 虛擬環境</h3><p>在 Python 開發中，為每個專案建立獨立的虛擬環境是一個好習慣。</p><ol><li><p><strong>建立虛擬環境</strong> (通常命名為 <code>.venv</code>)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv .venv</span><br></pre></td></tr></table></figure></li><li><p><strong>啟動虛擬環境</strong>：<br>啟動後，您會看到終端機提示字元前方出現 <code>(.venv)</code> 的字樣，表示您已在虛擬環境中。</p><ul><li><strong>Windows (PowerShell)</strong>:<br>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\.venv\Scripts\activate</span><br></pre></td></tr></table></figure></li><li><strong>macOS &#x2F; Linux (bash&#x2F;zsh)</strong>:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .venv/bin/activate</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>安裝套件</strong>：<br>在已啟動的虛擬環境中，使用 <code>pip</code> 來安裝專案所需的套件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 確保虛擬環境已啟動</span></span><br><span class="line">pip install requests</span><br><span class="line">pip install flask</span><br></pre></td></tr></table></figure></li></ol><h2 id="終端機設定-自訂-Shell"><a href="#終端機設定-自訂-Shell" class="headerlink" title="終端機設定 (自訂 Shell)"></a>終端機設定 (自訂 Shell)</h2><p>VSCode 允許您選擇偏好的 Shell 作為整合式終端機的預設設定。</p><h3 id="為何要更改？"><a href="#為何要更改？" class="headerlink" title="為何要更改？"></a>為何要更改？</h3><ul><li><strong>Windows</strong>: 預設可能是 PowerShell 或傳統的命令提示字元 (cmd)。許多開發者會安裝 Git for Windows，並偏好使用其附帶的 <strong>Git Bash</strong>，因為它提供了更多類似 Linux 的指令與環境。</li><li><strong>macOS&#x2F;Linux</strong>: 預設可能是 <code>bash</code> 或 <code>zsh</code>。您可以根據個人習慣切換。</li></ul><h3 id="如何設定"><a href="#如何設定" class="headerlink" title="如何設定"></a>如何設定</h3><ol><li>開啟<strong>命令選擇區</strong> (<code>F1</code> 或 <code>Ctrl+Shift+P</code>)。</li><li>輸入並選擇 <code>Terminal: Select Default Profile</code> (終端機: 選取預設設定檔)。</li><li>VSCode 會列出所有偵測到的可用 Shell，例如：PowerShell, Command Prompt, Git Bash, zsh 等。</li><li>點擊您想要設為預設的選項即可。之後所有新開的終端機都會使用這個設定。</li></ol>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
          <category> VSCode </category>
          
          <category> VSCode 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> VSCode </tag>
            
            <tag> 整合開發環境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 03 檔案與工作區管理</title>
      <link href="/2025/07/29/vscode-03/"/>
      <url>/2025/07/29/vscode-03/</url>
      
        <content type="html"><![CDATA[<h1 id="檔案與工作區管理"><a href="#檔案與工作區管理" class="headerlink" title="檔案與工作區管理"></a>檔案與工作區管理</h1><p>高效的檔案與專案管理是順暢開發流程的基礎。VSCode 提供了直觀的檔案總管，並透過「工作區」的概念，讓您能輕鬆應對從單一專案到複雜的多專案場景。</p><h2 id="檔案與資料夾操作"><a href="#檔案與資料夾操作" class="headerlink" title="檔案與資料夾操作"></a>檔案與資料夾操作</h2><p>VSCode 左側的「檔案總管 (Explorer)」是您管理專案檔案的主要區域。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><strong>建立</strong>：將滑鼠移至檔案總管面板，會出現「新增檔案」與「新增資料夾」的圖示。</li><li><strong>重新命名&#x2F;刪除</strong>：在檔案或資料夾上按右鍵，即可找到對應選項。</li><li><strong>拖放</strong>：您可以直接從桌面或其他視窗將檔案或資料夾拖曳至 VSCode 的檔案總管中來加入它們。</li></ul><h3 id="快速開啟檔案"><a href="#快速開啟檔案" class="headerlink" title="快速開啟檔案"></a>快速開啟檔案</h3><ul><li>按下 <code>Ctrl+P</code> (macOS 為 <code>Cmd+P</code>)，會開啟一個檔案搜尋框。</li><li>直接輸入檔名，VSCode 會即時列出符合的檔案，按下 <code>Enter</code> 即可開啟。這通常比在檔案總管中層層尋找快得多。</li></ul><h2 id="工作區-Workspace-的概念"><a href="#工作區-Workspace-的概念" class="headerlink" title="工作區 (Workspace) 的概念"></a>工作區 (Workspace) 的概念</h2><p>在 VSCode 中，「工作區」不僅僅是您開啟的資料夾，它是一個更強大的概念，代表了您當前的開發環境。</p><h3 id="單一資料夾模式-Single-folder"><a href="#單一資料夾模式-Single-folder" class="headerlink" title="單一資料夾模式 (Single-folder)"></a>單一資料夾模式 (Single-folder)</h3><p>這是最常見的使用方式。當您透過「檔案」&gt;「開啟資料夾…」來開啟一個專案時，VSCode 就會為這個資料夾建立一個工作區環境。所有設定、偵錯配置與任務都會與這個資料夾關聯。</p><h3 id="多根工作區-Multi-root-Workspace"><a href="#多根工作區-Multi-root-Workspace" class="headerlink" title="多根工作區 (Multi-root Workspace)"></a>多根工作區 (Multi-root Workspace)</h3><p>當您的專案變得複雜，例如一個包含前端專案、後端 API 專案以及共用文件資料夾的大型專案時，多根工作區就顯得非常有用。它允許您在<strong>同一個 VSCode 視窗</strong>中，同時開啟並管理多個不相關或相關的資料夾。</p><ul><li><p><strong>建立</strong>：</p><ol><li>先開啟一個主要的資料夾。</li><li>點擊「檔案」&gt;「將資料夾新增至工作區…」。</li><li>選擇您想加入的第二個、第三個資料夾。</li><li>完成後，點擊「檔案」&gt;「將工作區另存為…」，將這個組合儲存成一個 <code>.code-workspace</code> 檔案。</li></ol></li><li><p><strong>優點</strong>：</p><ul><li><strong>集中管理</strong>：所有專案都在一個視窗內，方便切換與查看。</li><li><strong>共用終端機</strong>：可以在同一個終端機面板中，為不同的專案執行指令。</li><li><strong>全域搜尋</strong>：搜尋時可以一次涵蓋所有在工作區內的專案。</li></ul></li><li><p><strong>範例情境</strong>：一個 Python Web 專案，前端使用 React，後端使用 Django。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my-web-app.code-workspace</span><br><span class="line">├── frontend (React 專案資料夾)</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── package.json</span><br><span class="line">└── backend (Django 專案資料夾)</span><br><span class="line">    ├── myproject</span><br><span class="line">    └── manage.py</span><br></pre></td></tr></table></figure></li></ul><p>透過 <code>.code-workspace</code> 檔案打開後，<code>frontend</code> 和 <code>backend</code> 會同時出現在檔案總管中，各自獨立但又便於管理。</p><h2 id="設定檔：使用者-vs-工作區"><a href="#設定檔：使用者-vs-工作區" class="headerlink" title="設定檔：使用者 vs. 工作區"></a>設定檔：使用者 vs. 工作區</h2><p>VSCode 的設定非常有彈性，可以分為兩個層級，讓您能精準控制設定的套用範圍。</p><h3 id="使用者設定-User-Settings"><a href="#使用者設定-User-Settings" class="headerlink" title="使用者設定 (User Settings)"></a>使用者設定 (User Settings)</h3><ul><li><strong>作用範圍</strong>：全域，適用於您用 VSCode 開啟的所有專案。</li><li><strong>設定方式</strong>：點擊左下角齒輪圖示 &gt;「設定」，在「使用者」分頁下修改。</li><li><strong>適合的設定</strong>：通用的個人偏好，例如佈景主題、字體大小、<code>&quot;editor.autoSave&quot;: &quot;onFocusChange&quot;</code> (當焦點離開編輯器時自動儲存) 等。</li></ul><h3 id="工作區設定-Workspace-Settings"><a href="#工作區設定-Workspace-Settings" class="headerlink" title="工作區設定 (Workspace Settings)"></a>工作區設定 (Workspace Settings)</h3><ul><li><p><strong>作用範圍</strong>：僅對目前開啟的工作區有效。此設定會覆寫使用者設定。</p></li><li><p><strong>設定方式</strong>：點擊左下角齒輪圖示 &gt;「設定」，在「工作區」分頁下修改。設定會被儲存到目前資料夾下的 <code>.vscode/settings.json</code> 檔案中。</p></li><li><p><strong>適合的設定</strong>：特定專案的需求，例如專案的 Python 直譯器路徑、程式碼排版風格、或是專案特定的檔案排除規則。</p><p><strong>範例</strong>：您的個人偏好是使用 4 個空格進行縮排，但某個 Python 專案規定必須使用 2 個空格。</p><ol><li>**使用者設定 (<code>settings.json</code>)**：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.tabSize&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.insertSpaces&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li>**在該專案的 <code>.vscode/settings.json</code> 中設定 (工作區設定)**：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.tabSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p>當您開啟這個專案時，VSCode 會優先採用工作區的設定，使用 2 個空格縮排。當您開啟其他專案時，則會回復到使用者設定的 4 個空格。這個機制對於團隊協作與維持專案風格一致性至關重要。</p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
          <category> VSCode </category>
          
          <category> VSCode 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> VSCode </tag>
            
            <tag> 整合開發環境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 02 核心編輯技巧</title>
      <link href="/2025/07/29/vscode-02/"/>
      <url>/2025/07/29/vscode-02/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode-核心編輯技巧介紹"><a href="#VSCode-核心編輯技巧介紹" class="headerlink" title="VSCode 核心編輯技巧介紹"></a>VSCode 核心編輯技巧介紹</h1><p>熟悉了 VSCode 的基本介面後，下一步就是掌握能大幅提升編碼效率的核心編輯技巧。這些功能將幫助您寫得更快、改得更輕鬆。</p><h2 id="命令選擇區-Command-Palette"><a href="#命令選擇區-Command-Palette" class="headerlink" title="命令選擇區 (Command Palette)"></a>命令選擇區 (Command Palette)</h2><p>命令選擇區是 VSCode 的大腦中樞，您可以把它想像成一個萬用的功能搜尋框。與其在選單中層層尋找功能，不如直接在這裡輸入指令。</p><ul><li><strong>開啟方式</strong>：按下 <code>F1</code> 或 <code>Ctrl+Shift+P</code> (macOS 為 <code>Cmd+Shift+P</code>)。</li><li><strong>常用範例</strong>：<ul><li>輸入 <code>View: Toggle Terminal</code> 可以快速開關下方的終端機面板。</li><li>輸入 <code>Git: Commit</code> 可以直接執行 Git 的提交命令。</li><li>輸入 <code>&gt; </code> 開頭可以搜尋並執行所有命令，若刪除 <code>&gt; </code> 則可以搜尋專案中的檔案。</li></ul></li></ul><h2 id="多游標編輯-Multi-Cursor"><a href="#多游標編輯-Multi-Cursor" class="headerlink" title="多游標編輯 (Multi-Cursor)"></a>多游標編輯 (Multi-Cursor)</h2><p>多游標編輯讓您可以在檔案中的多個位置同時輸入與修改，對於批次修改變數或標籤非常有用。</p><h3 id="方法一：按住鍵盤-滑鼠左鍵"><a href="#方法一：按住鍵盤-滑鼠左鍵" class="headerlink" title="方法一：按住鍵盤+滑鼠左鍵"></a>方法一：按住鍵盤+滑鼠左鍵</h3><ul><li><p>按住 <code>Alt</code> (macOS 為 <code>Option</code>)，然後在您想要編輯的地方點擊滑鼠左鍵，即可增加新的游標。</p></li><li><p><strong>範例</strong>：假設您想將以下幾個變數都加上 <code>_config</code> 的後綴。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">host = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">port = <span class="number">8080</span></span><br><span class="line">user = <span class="string">&quot;adm&quot;</span></span><br><span class="line"><span class="comment"># 按住 Alt/Option 在每行結尾點擊，然後一次輸入 _config</span></span><br><span class="line"><span class="comment"># 修改後</span></span><br><span class="line">host_config = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">port_config = <span class="number">8080</span></span><br><span class="line">user_config = <span class="string">&quot;admin&quot;</span></span><br></pre></td></tr></table></figure><h3 id="方法二：選取下一個相同項目"><a href="#方法二：選取下一個相同項目" class="headerlink" title="方法二：選取下一個相同項目"></a>方法二：選取下一個相同項目</h3><ul><li><p>選取一個單字，然後重複按下 <code>Ctrl+D</code> (macOS 為 <code>Cmd+D</code>)，VSCode 會自動選取下一個與之相同的單字，並建立新的游標。</p></li><li><p><strong>範例</strong>：將函式中的參數 <code>data</code> 全部改名為 <code>raw_data</code>。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Processing data...&quot;</span>)</span><br><span class="line"><span class="comment"># 點選第一個 data，按兩次 Ctrl+D/Cmd+D，然後直接輸入新名稱 raw_data</span></span><br><span class="line"><span class="comment"># 修改後</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">raw_data</span>):</span><br><span class="line">    <span class="keyword">if</span> raw_data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Processing raw_data...&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="程式碼片段-Snippets"><a href="#程式碼片段-Snippets" class="headerlink" title="程式碼片段 (Snippets)"></a>程式碼片段 (Snippets)</h2><p>程式碼片段是預先定義好的程式碼模板。您只需輸入一小段觸發詞，按下 <code>Tab</code> 或 <code>Enter</code>，就能快速產生一段常用的程式碼結構。</p><h3 id="使用內建片段"><a href="#使用內建片段" class="headerlink" title="使用內建片段"></a>使用內建片段</h3><p>VSCode 已為多數語言內建了片段。以 Python 為例，在檔案中輸入 <code>def</code> 或 <code>for</code>，您會看到一個提示框，選擇對應的片段即可快速建立函式或迴圈。</p><p><strong>範例</strong>：輸入 <code>def</code> 並按下 <code>Tab</code>，會產生&#96;&#96;&#96;pythodef name(params)    pas&#96;&#96;此時游標會自動停在 <code>name</code> 的位置讓您輸入函式名稱。</p><h3 id="自訂程式碼片段"><a href="#自訂程式碼片段" class="headerlink" title="自訂程式碼片段"></a>自訂程式碼片段</h3><p>您可以為自己最常用的程式碼建立專屬片段。</p><ol><li>開啟 <strong>命令選擇區</strong> (<code>F1</code>)。</li><li>輸入 <code>Configure User Snippets</code>，並選擇 <code>python.json</code>。</li><li>貼上以下 JSON 內容並儲存：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Python Main Function&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ifmain&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;if __name__ == &#x27;__main__&#x27;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;    $1&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Creates the standard Python main execution block.&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li>現在，只要在 Python 檔案中輸入 <code>ifmain</code> 並按下 <code>Tab</code>，就會自動產生主函式區塊。</li></ol><h2 id="IntelliSense-智慧提示"><a href="#IntelliSense-智慧提示" class="headerlink" title="IntelliSense 智慧提示"></a>IntelliSense 智慧提示</h2><p>IntelliSense 是 VSCode 提供的智慧型程式碼完成功能，它包含了自動完成、參數資訊、快速預覽定義等。這項功能極度依賴您所安裝的語言延伸模組（例如 Python extension）。</p><ul><li><p><strong>功能</strong>：當您輸入程式碼時，IntelliSense 會根據上下文提供可能的變數、函式、類別或方法。</p></li><li><p><strong>範例</strong>：當您實例化一個類別後，只要輸入物件名稱和一個點 <code>.</code>，所有可用的屬性與方法都會被列出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;self.name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 實例化 Greeter</span></span><br><span class="line">g = Greeter(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 當您輸入 &quot;g.&quot; 時，IntelliSense 就會提示 name 屬性與 say_hello 方法</span></span><br><span class="line">g.say_hello()</span><br></pre></td></tr></table></figure></li></ul><h2 id="Emmet-縮寫"><a href="#Emmet-縮寫" class="headerlink" title="Emmet 縮寫"></a>Emmet 縮寫</h2><p>Emmet 是一個內建於 VSCode 的強大工具，但<strong>主要用於 Web 開發</strong>，能讓您用類似 CSS 選擇器的語法極速產生 HTML 和 CSS 程式碼。雖然它不是直接用於 Python 開發，但作為 VSCode 的核心編輯技巧之一，也值得了解。</p><ul><li>**範例 (HTML)**：在一個 HTML 檔案中，輸入 <code>ul&gt;li.item$*3</code> 然後按下 <code>Tab</code> 鍵，會立刻產生以下結構：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
          <category> VSCode </category>
          
          <category> VSCode 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> VSCode </tag>
            
            <tag> 整合開發環境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 01 下戴、安裝、設定及執行</title>
      <link href="/2025/07/29/vscode-01/"/>
      <url>/2025/07/29/vscode-01/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode-介紹"><a href="#VSCode-介紹" class="headerlink" title="VSCode 介紹"></a>VSCode 介紹</h1><p>這篇文章將引導您完成 Visual Studio Code (簡稱 VSCode) 的下載、安裝、基礎設定，並執行您的第一支程式。VSCode 是一款由微軟開發的免費、輕量級且功能強大的原始碼編輯器，支援 Windows、macOS 和 Linux。</p><h2 id="下載與安裝"><a href="#下載與安裝" class="headerlink" title="下載與安裝"></a>下載與安裝</h2><p>首先，我們需要從官方網站下載 VSCode。</p><ul><li><strong>前往官網</strong>：開啟瀏覽器，前往 <a href="https://code.visualstudio.com/">VSCode 官方網站</a>。</li><li><strong>下載安裝檔</strong>：網站會自動偵測您的作業系統，並推薦適合的版本。點擊下載按鈕，即可開始下載。</li><li><strong>執行安裝</strong>：<ul><li><strong>Windows</strong>: 下載完成後，點擊 <code>.exe</code> 安裝檔，並依照安裝精靈的指示進行。建議在「選取其他工作」步驟中，勾選「將’以 Code 開啟’操作新增至 Windows 檔案總管檔案內容功能表」和「將’以 Code 開啟’操作新增至 Windows 檔案總管目錄內容功能表」，這會讓您未來在資料夾或檔案上按右鍵時，能快速用 VSCode 開啟。</li><li><strong>macOS</strong>: 下載完成後，會得到一個 <code>.zip</code> 檔。解壓縮後，將 <code>Visual Studio Code.app</code> 拖曳至「應用程式」資料夾即可。</li><li><strong>Linux</strong>: 根據您的發行版，可以下載 <code>.deb</code> (Debian, Ubuntu) 或 <code>.rpm</code> (Red Hat, Fedora, SUSE) 套件並進行安裝。</li></ul></li></ul><h2 id="中文化與基本介面介紹"><a href="#中文化與基本介面介紹" class="headerlink" title="中文化與基本介面介紹"></a>中文化與基本介面介紹</h2><p>安裝完成後，讓我們來熟悉一下操作介面並將其設定為繁體中文。</p><h3 id="安裝中文語言包："><a href="#安裝中文語言包：" class="headerlink" title="安裝中文語言包："></a>安裝中文語言包：</h3><ol><li>開啟 VSCode。</li><li>點擊左側活動列 (Activity Bar) 的延伸模組圖示 (Extensions，看起來像四個方塊)。</li><li>在搜尋框中輸入 <code>Chinese (Traditional) Language Pack</code>。</li><li>找到由 Microsoft 提供的「繁體中文語言套件」，點擊 <code>Install</code> 安裝。</li><li>安裝完成後，右下角會跳出提示，點擊 <code>Change Language and Restart</code>，VSCode 將會重啟並套用中文介面。</li></ol><h3 id="使用者介面-UI-概覽："><a href="#使用者介面-UI-概覽：" class="headerlink" title="使用者介面 (UI) 概覽："></a>使用者介面 (UI) 概覽：</h3><ul><li>**活動列 (Activity Bar)**：位於最左側，提供檔案總管、全域搜尋、原始檔控制、執行與偵錯、以及延伸模組等主要功能的快速切換。</li><li>**側邊欄 (Side Bar)**：位於活動列旁，顯示當前所選功能的詳細內容，例如在檔案總管模式下，會顯示專案的資料夾與檔案結構。</li><li>**編輯器 (Editor)**：是您編寫程式碼的主要區域。</li><li>**面板 (Panel)**：位於下方，包含終端機 (Terminal)、主控台輸出、問題等資訊。您可以透過 <code>Ctrl + `` </code> ( <code>~</code> 鍵) 快速開啟或關閉終端機。</li><li>**狀態列 (Status Bar)**：位於最下方，顯示目前開啟的檔案、專案、程式語言、錯誤與警告等資訊。</li></ul><h2 id="實用設定與延伸模組推薦"><a href="#實用設定與延伸模組推薦" class="headerlink" title="實用設定與延伸模組推薦"></a>實用設定與延伸模組推薦</h2><p>VSCode 的強大之處在於其高度的可自訂性與豐富的延伸模組生態系。</p><h3 id="常用設定："><a href="#常用設定：" class="headerlink" title="常用設定："></a>常用設定：</h3><ul><li><strong>自動儲存</strong>：點擊左下角的齒輪圖示，選擇「設定」，在搜尋框中輸入 <code>Auto Save</code>，並將其值改為 <code>afterDelay</code>，這樣您的檔案在修改後會自動儲存。</li><li><strong>字型大小</strong>：在設定中搜尋 <code>Font Size</code>，即可調整編輯器內的字體大小。</li></ul><h3 id="推薦延伸模組-Extensions-："><a href="#推薦延伸模組-Extensions-：" class="headerlink" title="推薦延伸模組 (Extensions)："></a>推薦延伸模組 (Extensions)：</h3><ul><li><strong>Live Server</strong>: 對於網頁開發者來說是必備工具。它能啟動一個本地開發伺服器，並提供即時重新載入功能，當您儲存 HTML&#x2F;CSS&#x2F;JS 檔案時，瀏覽器會自動刷新。</li><li><strong>Prettier - Code formatter</strong>: 一款強大的程式碼格式化工具，能自動整理您的程式碼，使其風格保持一致。</li><li><strong>Material Icon Theme</strong>: 提供多樣化的檔案圖示，讓您在檔案總管中能更輕易地透過圖示辨識檔案類型。</li></ul><h2 id="執行您的第一支程式-以-Python-為例"><a href="#執行您的第一支程式-以-Python-為例" class="headerlink" title="執行您的第一支程式 (以 Python 為例)"></a>執行您的第一支程式 (以 Python 為例)</h2><p>現在，讓我們來試著用 VSCode 執行一支簡單的 Python 程式。</p><ol><li><strong>安裝 Python 延伸模組</strong>：在延伸模組市集中搜尋並安裝由 Microsoft 提供的 <code>Python</code> 延伸模組。</li><li><strong>安裝 Python 直譯器</strong>：請確保您的電腦已經安裝了 Python。若尚未安裝，請至 <a href="https://www.python.org/">Python 官方網站</a>下載並安裝。</li><li><strong>建立檔案</strong>：<ul><li>點擊活動列的「檔案總管」。</li><li>點擊「開啟資料夾」，選擇或建立一個您想存放專案的資料夾。</li><li>在該資料夾上按右鍵，選擇「新增檔案」，並將檔案命名為 <code>hello.py</code>。</li></ul></li><li><strong>撰寫程式碼</strong>：在 <code>hello.py</code> 編輯器中，輸入以下程式碼：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, VSCode!&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><strong>執行程式</strong>：</li></ol><ul><li><strong>方法一：透過終端機</strong><br>    * 按下 <code>Ctrl + `` </code> 開啟整合式終端機。<br>    * 在終端機中輸入 <code>python hello.py</code> (macOS&#x2F;Linux 可能需使用 <code>python3 hello.py</code>)，然後按下 Enter。</li><li><strong>方法二：透過執行按鈕</strong><br>    * 安裝 Python 延伸模組後，編輯器的右上角會出現一個播放按鈕 (Run Python File)。<br>    * 點擊此按鈕，即可執行程式。</li></ul><p>您應該會在下方的終端機面板中看到 <code>Hello, VSCode!</code> 的輸出結果。恭喜您，已經成功在 VSCode 中執行了第一支程式！</p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
          <category> VSCode </category>
          
          <category> VSCode 基礎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> VSCode </tag>
            
            <tag> 整合開發環境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 09 例外處理 try-catch-finally</title>
      <link href="/2025/05/04/Java/java-09/"/>
      <url>/2025/05/04/Java/java-09/</url>
      
        <content type="html"><![CDATA[<h1 id="認識-Java-例外處理（Exception-Handling）"><a href="#認識-Java-例外處理（Exception-Handling）" class="headerlink" title="認識 Java 例外處理（Exception Handling）"></a>認識 Java 例外處理（Exception Handling）</h1><p>當程式遇到錯誤時（如除以零、讀不到檔案），若沒有妥善處理，會造成程式中斷。<br>Java 使用 <code>try-catch-finally</code> 結構搭配 <code>throw</code>、<code>throws</code> 來控制錯誤流程。</p><hr><h1 id="類別：ExceptionExample"><a href="#類別：ExceptionExample" class="headerlink" title="類別：ExceptionExample"></a>類別：ExceptionExample</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        divideSafe(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        parseIntSafe(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">        tryWithFinally();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            customThrow(-<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[main] 捕捉自訂錯誤：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">divideSafe</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a / b;</span><br><span class="line">            System.out.println(<span class="string">&quot;[divide] 結果：&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[divide] 錯誤：除以零！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseIntSafe</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(input);</span><br><span class="line">            System.out.println(<span class="string">&quot;[parse] 轉換結果：&quot;</span> + number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[parse] 格式錯誤：&quot;</span> + input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tryWithFinally</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[finally] 嘗試執行&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[finally] 一定會執行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">customThrow</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;年齡不能是負數&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;[throw] 年齡為：&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 方法說明：divideSafe(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line"></span><br><span class="line">### 功能</span><br><span class="line"></span><br><span class="line">使用 `<span class="keyword">try</span>-<span class="keyword">catch</span>` 處理除以零錯誤</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">divideSafe</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a / b;</span><br><span class="line">        System.out.println(<span class="string">&quot;[divide] 結果：&quot;</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[divide] 錯誤：除以零！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2: 使用 <code>try</code> 包住可能發生錯誤的程式區塊</li><li>Line 3: 若 <code>b = 0</code>，會丟出 <code>ArithmeticException</code></li><li>Line 5: 在 <code>catch</code> 中接收例外物件 <code>e</code> 並處理</li></ul><hr><h2 id="方法說明：parseIntSafe-String-input"><a href="#方法說明：parseIntSafe-String-input" class="headerlink" title="方法說明：parseIntSafe(String input)"></a>方法說明：parseIntSafe(String input)</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>處理將字串轉換為整數時可能發生的格式錯誤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseIntSafe</span><span class="params">(String input)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(input);</span><br><span class="line">        System.out.println(<span class="string">&quot;[parse] 轉換結果：&quot;</span> + number);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[parse] 格式錯誤：&quot;</span> + input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 3: 嘗試將字串轉為整數</li><li>Line 6: 當輸入不是數字時會拋出 <code>NumberFormatException</code></li></ul><hr><h2 id="方法說明：tryWithFinally"><a href="#方法說明：tryWithFinally" class="headerlink" title="方法說明：tryWithFinally()"></a>方法說明：tryWithFinally()</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>展示 <code>finally</code> 區塊的使用，無論是否發生錯誤都會執行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tryWithFinally</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[finally] 嘗試執行&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[finally] 一定會執行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 3: <code>try</code> 區塊正常執行</li><li>Line 5: <code>finally</code> 永遠執行，用於釋放資源等用途（如關檔案）</li></ul><hr><h2 id="方法說明：customThrow-int-age"><a href="#方法說明：customThrow-int-age" class="headerlink" title="方法說明：customThrow(int age)"></a>方法說明：customThrow(int age)</h2><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>示範自訂例外條件並手動 <code>throw</code> 例外</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">customThrow</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;年齡不能是負數&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;[throw] 年齡為：&quot;</span> + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明-3"><a href="#說明-3" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2: 若條件不符合，手動使用 <code>throw</code> 丟出例外</li><li>Line 3: 使用內建例外類別 <code>IllegalArgumentException</code></li></ul><hr><h1 id="本章練習題"><a href="#本章練習題" class="headerlink" title="本章練習題"></a>本章練習題</h1><ol><li><p>撰寫方法 <code>divide(int a, int b)</code>，若除以 0，回傳 <code>&quot;錯誤&quot;</code>，否則回傳字串結果</p></li><li><p>實作方法 <code>safeParse(String s)</code>，若字串為數字則轉換為整數回傳，否則回傳 -1</p></li><li><p>撰寫方法 <code>readFile(String path)</code>，嘗試開啟檔案（可模擬路徑），即使錯誤也要印出 <code>&quot;已結束&quot;</code>（用 finally）</p></li><li><p>（加分題）撰寫 <code>checkScore(int score)</code>，若分數 &lt; 0 或 &gt; 100，丟出 <code>IllegalArgumentException</code>，否則輸出分數</p></li></ol><hr><h1 id="本章總結"><a href="#本章總結" class="headerlink" title="本章總結"></a>本章總結</h1><table><thead><tr><th>概念</th><th>關鍵語法</th><th>說明</th></tr></thead><tbody><tr><td>捕捉例外</td><td><code>try &#123; ... &#125; catch (類型 e) &#123; ... &#125;</code></td><td>處理執行中可能出錯的情況</td></tr><tr><td>保證執行</td><td><code>finally &#123; ... &#125;</code></td><td>無論是否錯誤都會執行</td></tr><tr><td>手動丟出例外</td><td><code>throw new Exception()</code></td><td>建立並丟出例外</td></tr><tr><td>宣告會丟出</td><td><code>throws Exception</code></td><td>用於方法簽章中（本章未用）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 例外處理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 08 繼承、多型與介面</title>
      <link href="/2025/05/04/Java/java-08/"/>
      <url>/2025/05/04/Java/java-08/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-OOP：繼承、多型、介面"><a href="#Java-OOP：繼承、多型、介面" class="headerlink" title="Java OOP：繼承、多型、介面"></a>Java OOP：繼承、多型、介面</h1><p>本章進一步擴充物件導向設計，讓類別之間可共享功能並擴展彈性。<br>三個關鍵核心：</p><ul><li>繼承（extends）→ 子類別複用父類別邏輯</li><li>多型（override）→ 子類別自定義方法行為</li><li>介面（interface）→ 行為契約設計</li></ul><hr><h1 id="類別一：Animal（父類別）"><a href="#類別一：Animal（父類別）" class="headerlink" title="類別一：Animal（父類別）"></a>類別一：Animal（父類別）</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>建立一個可被繼承的基本類別，提供共通欄位與方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Animal] &quot;</span> + name + <span class="string">&quot; 發出聲音&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">## 說明</span><br><span class="line"></span><br><span class="line">* Line <span class="number">1</span>: 套件 →請參考 Java <span class="number">01.</span>簡介</span><br><span class="line">* Line <span class="number">3</span>: 宣告父類別 `Animal`</span><br><span class="line">* Line <span class="number">4</span>: 公開屬性 `name`</span><br><span class="line">* Line <span class="number">6</span>: 建構子接收名稱參數</span><br><span class="line">* Line <span class="number">9</span>: 方法 `speak()` 為共通行為，可被覆寫</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 類別二：Dog（子類別繼承 Animal）</span><br><span class="line"></span><br><span class="line">## 功能</span><br><span class="line"></span><br><span class="line">繼承 Animal，並改寫 `speak()` 方法行為</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Dog] &quot;</span> + name + <span class="string">&quot;：汪汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 使用 <code>extends</code> 繼承 <code>Animal</code></li><li>Line 3: 呼叫父類別建構子 <code>super(name)</code></li><li>Line 6: 使用 <code>@Override</code> 覆寫 <code>speak()</code> 方法</li></ul><blockquote><p><strong>小提醒</strong><br><code>super()</code> 是呼叫父類別的建構子<br><code>@Override</code> 用於確認你確實覆寫了父類別的方法</p></blockquote><hr><h1 id="類別三：OopTest（建立物件與執行）"><a href="#類別三：OopTest（建立物件與執行）" class="headerlink" title="類別三：OopTest（建立物件與執行）"></a>類別三：OopTest（建立物件與執行）</h1><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><p>建立 <code>Animal</code> 與 <code>Dog</code> 物件，執行多型測試</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OopTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;動物&quot;</span>);</span><br><span class="line">        a1.speak();</span><br><span class="line"></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">        d1.speak();</span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        a2.speak(); <span class="comment">// 多型：Animal 型別 → Dog 實體</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 3: 建立父類別物件</li><li>Line 6: 建立子類別物件</li><li>Line 9: 父型別接收子類別 → 多型現象</li></ul><hr><h1 id="介面：Walkable（定義行為契約）"><a href="#介面：Walkable（定義行為契約）" class="headerlink" title="介面：Walkable（定義行為契約）"></a>介面：Walkable（定義行為契約）</h1><h2 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h2><p>定義 <code>walk()</code> 方法，讓類別能選擇實作（implements）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Walkable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 介面不包含邏輯，只定義方法名稱</li><li>Line 2: 無實作內容；實作時必須實作該方法</li></ul><hr><h1 id="實作介面：Dog-加入-walk-功能"><a href="#實作介面：Dog-加入-walk-功能" class="headerlink" title="實作介面：Dog 加入 walk 功能"></a>實作介面：Dog 加入 walk 功能</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Walkable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Dog] &quot;</span> + name + <span class="string">&quot;：汪汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Dog] &quot;</span> + name + <span class="string">&quot; 開始散步&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-3"><a href="#說明-3" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 同時繼承類別與實作介面（<code>extends + implements</code>）</li><li>Line 9: 需實作介面中的 <code>walk()</code> 方法</li></ul><hr><h1 id="本章練習題"><a href="#本章練習題" class="headerlink" title="本章練習題"></a>本章練習題</h1><ol><li><p>建立 <code>Cat</code> 類別，繼承 <code>Animal</code> 並覆寫 <code>speak()</code> 印出 <code>喵喵</code></p></li><li><p>建立介面 <code>Playable</code>，定義 <code>play()</code> 方法，讓 <code>Cat</code> 加以實作</p></li><li><p>在 <code>main()</code> 中建立 <code>Animal</code>, <code>Dog</code>, <code>Cat</code> 實體並統一使用 <code>Animal[]</code> 儲存，呼叫 <code>speak()</code> 展示多型</p></li><li><p>（加分題）建立另一個介面 <code>Swimmable</code>，定義 <code>swim()</code>，讓 <code>Dog</code> 可同時 <code>walk()</code> 與 <code>swim()</code></p></li></ol><hr><h1 id="本章總結"><a href="#本章總結" class="headerlink" title="本章總結"></a>本章總結</h1><table><thead><tr><th>概念</th><th>說明</th><th>關鍵語法</th></tr></thead><tbody><tr><td>繼承</td><td>子類別複用父類別欄位與方法</td><td><code>class Dog extends Animal</code></td></tr><tr><td>建構子傳遞</td><td>子類別使用 <code>super()</code> 呼叫父建構子</td><td><code>super(name)</code></td></tr><tr><td>覆寫</td><td>子類別覆寫父類別方法</td><td><code>@Override</code></td></tr><tr><td>多型</td><td>父類別變數 → 子類別實體</td><td><code>Animal a = new Dog()</code></td></tr><tr><td>介面</td><td>定義方法規格（無邏輯）</td><td><code>interface Walkable</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 07 物件導向基礎（OOP）：類別、屬性、建構子</title>
      <link href="/2025/05/04/Java/java-07/"/>
      <url>/2025/05/04/Java/java-07/</url>
      
        <content type="html"><![CDATA[<h1 id="認識-Java-類別與物件（Object-Oriented-Programming）"><a href="#認識-Java-類別與物件（Object-Oriented-Programming）" class="headerlink" title="認識 Java 類別與物件（Object-Oriented Programming）"></a>認識 Java 類別與物件（Object-Oriented Programming）</h1><p>在 Java 中，所有邏輯皆以「物件」為單位進行封裝與呼叫。<br>本章介紹物件導向的第一步：<strong>類別、屬性、建構子、this 與方法</strong></p><hr><h1 id="類別說明：Person（封裝資料與行為）"><a href="#類別說明：Person（封裝資料與行為）" class="headerlink" title="類別說明：Person（封裝資料與行為）"></a>類別說明：Person（封裝資料與行為）</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>定義一個 <code>Person</code> 類別，包含姓名、年齡等欄位，並提供建構子與對外方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Person] 我是 &quot;</span> + name + <span class="string">&quot;，今年 &quot;</span> + age + <span class="string">&quot; 歲&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">## 說明</span><br><span class="line"></span><br><span class="line">* Line <span class="number">1</span>: 「套件」（<span class="keyword">package</span>）→請參考 Java <span class="number">01.</span>簡介</span><br><span class="line">* Line <span class="number">3</span>: 宣告類別 `Person`</span><br><span class="line">* Line <span class="number">4</span>–<span class="number">5</span>: 宣告兩個屬性（`<span class="keyword">public</span>`）</span><br><span class="line">* Line <span class="number">7</span>: 建構子，名稱與類別相同</span><br><span class="line">* Line <span class="number">8</span>–<span class="number">9</span>: 使用 `<span class="built_in">this</span>` 表示「這個物件自己的變數」</span><br><span class="line">* Line <span class="number">11</span>: 方法 `sayHello()` 可印出屬性資訊</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 類別使用：OopExample</span><br><span class="line"></span><br><span class="line">## 功能</span><br><span class="line"></span><br><span class="line">示範如何使用 `<span class="keyword">new</span>` 建立物件、如何呼叫其方法。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OopExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Mendel&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        p1.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        p2.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 宣告類別 <code>OopExample</code></li><li>Line 4: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 5: 使用建構子建立第一個 Person 物件</li><li>Line 6: 呼叫 <code>sayHello()</code> 方法</li><li>Line 8–9: 建立第二個物件並執行相同行為</li></ul><hr><h1 id="建構子-Overloading：多種建立方式"><a href="#建構子-Overloading：多種建立方式" class="headerlink" title="建構子 Overloading：多種建立方式"></a>建構子 Overloading：多種建立方式</h1><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><p>提供多個建構子以支援預設值或不同的初始化方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;未命名&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 建構子無參數版本（預設用）</li><li>Line 2–3: 使用 <code>this.屬性</code> 指定預設值</li></ul><hr><h1 id="方法補充：setName-與-getName（預告封裝）"><a href="#方法補充：setName-與-getName（預告封裝）" class="headerlink" title="方法補充：setName 與 getName（預告封裝）"></a>方法補充：setName 與 getName（預告封裝）</h1><h2 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h2><p>以方法控制屬性存取（下一章會正式講封裝）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h2><ul><li><code>setName</code> 可修改屬性</li><li><code>getName</code> 取得值，未直接讀取欄位</li></ul><blockquote><p><strong>小提醒</strong><br>將屬性設為 <code>private</code>，改由 <code>getter/setter</code> 存取是封裝的基礎技巧（Java 08 詳述）</p></blockquote><hr><h1 id="本章練習題"><a href="#本章練習題" class="headerlink" title="本章練習題"></a>本章練習題</h1><ol><li><p>定義 <code>Dog</code> 類別，包含 <code>name</code>、<code>breed</code>，提供建構子與 <code>bark()</code> 方法，印出 <code>xxx 汪汪！</code></p></li><li><p>定義 <code>Car</code> 類別，提供兩種建構子：</p><ul><li><code>Car(String brand, int year)</code></li><li><code>Car()</code>，預設 <code>&quot;Toyota&quot;, 2020</code></li></ul></li><li><p>定義 <code>Student</code> 類別，屬性 <code>score</code>，提供 <code>printGrade()</code> 方法判斷 A&#x2F;B&#x2F;C&#x2F;D&#x2F;F</p></li><li><p>（加分題）將屬性設為 <code>private</code>，改由 <code>getXxx()</code>、<code>setXxx()</code> 操作</p></li></ol><hr><h1 id="本章總結"><a href="#本章總結" class="headerlink" title="本章總結"></a>本章總結</h1><table><thead><tr><th>概念</th><th>說明</th><th>範例</th></tr></thead><tbody><tr><td>類別</td><td>封裝資料與邏輯的模版</td><td><code>class Person &#123;&#125;</code></td></tr><tr><td>屬性</td><td>代表物件的狀態資料</td><td><code>String name;</code></td></tr><tr><td>建構子</td><td>初始化時執行，用於設定初始值</td><td><code>new Person(&quot;Mendel&quot;, 30)</code></td></tr><tr><td>this</td><td>指向目前物件，用於區分變數</td><td><code>this.name = name;</code></td></tr><tr><td>方法</td><td>提供外部呼叫功能</td><td><code>sayHello()</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 06 方法進階與參數設計</title>
      <link href="/2025/05/03/Java/java-06/"/>
      <url>/2025/05/03/Java/java-06/</url>
      
        <content type="html"><![CDATA[<h1 id="認識方法的彈性設計"><a href="#認識方法的彈性設計" class="headerlink" title="認識方法的彈性設計"></a>認識方法的彈性設計</h1><p>在 Java 中，方法（Method）不只是封裝邏輯，更重要的是可透過：</p><ul><li>傳遞參數來控制輸入</li><li>回傳結果進行處理</li><li>同一方法名稱可使用不同參數（Overloading）</li></ul><hr><h1 id="類別：MethodExample"><a href="#類別：MethodExample" class="headerlink" title="類別：MethodExample"></a>類別：MethodExample</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        greet(<span class="string">&quot;Mendel&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;[main] 加總結果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        modifyArray(nums);</span><br><span class="line">        System.out.println(<span class="string">&quot;[main] 修改後陣列第 1 筆：&quot;</span> + nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[overload] int 加法：&quot;</span> + multiply(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;[overload] double 加法：&quot;</span> + multiply(<span class="number">2.5</span>, <span class="number">3.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[greet] Hello, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">multiply</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="方法說明：greet-String-name"><a href="#方法說明：greet-String-name" class="headerlink" title="方法說明：greet(String name)"></a>方法說明：greet(String name)</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>傳入名字並輸出歡迎訊息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[greet] Hello, &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2: 宣告一個接收 <code>String</code> 的方法 <code>greet</code></li><li>Line 3: 使用傳入參數組合輸出文字</li></ul><hr><h2 id="方法說明：add-int-a-int-b"><a href="#方法說明：add-int-a-int-b" class="headerlink" title="方法說明：add(int a, int b)"></a>方法說明：add(int a, int b)</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>傳入兩個整數，回傳相加結果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2: 方法有回傳值（<code>int</code>），可用於主程式再運算</li><li>Line 3: 使用 <code>return</code> 傳出加總結果</li></ul><hr><h2 id="方法說明：modifyArray-int-arr"><a href="#方法說明：modifyArray-int-arr" class="headerlink" title="方法說明：modifyArray(int[] arr)"></a>方法說明：modifyArray(int[] arr)</h2><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>示範傳參考（Reference）對原陣列產生變動</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2: 傳入陣列（物件型別）會直接修改原始資料</li><li>Line 3: 將第 1 筆元素設為 99，主程式也會改變</li></ul><blockquote><p><strong>小提醒</strong><br>傳值（int, double 等）會複製值<br>傳參考（陣列、物件）會共用記憶體位置</p></blockquote><hr><h2 id="方法說明：multiply（Overloading）"><a href="#方法說明：multiply（Overloading）" class="headerlink" title="方法說明：multiply（Overloading）"></a>方法說明：multiply（Overloading）</h2><h3 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h3><p>同名方法 <code>multiply</code>，依參數型別決定執行內容（int 或 double）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">multiply</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明-3"><a href="#說明-3" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2&#x2F;6: 方法名稱相同，但參數型別不同（int vs double）</li><li>Line 3&#x2F;7: 回傳對應型別結果，呼叫時會自動比對</li></ul><blockquote><p><strong>小提醒</strong><br>方法名稱相同、參數不同就是 <strong>Overloading（多載）</strong><br>可增加程式彈性，不需額外命名新方法</p></blockquote><hr><h1 id="本章練習題"><a href="#本章練習題" class="headerlink" title="本章練習題"></a>本章練習題</h1><ol><li><p>撰寫方法 <code>greet(String name, int age)</code>，輸出 <code>&quot;Hello, [name]. You are [age] years old.&quot;</code></p></li><li><p>撰寫方法 <code>max(int a, int b)</code> 回傳較大的值</p></li><li><p>撰寫方法 <code>sum(int[] arr)</code> 回傳整數陣列的加總值</p></li><li><p>撰寫一個方法 <code>printLine(String symbol, int count)</code>，用 symbol 輸出 count 次的直線（Ex: <code>&quot;*&quot;</code> x 10）</p></li><li><p>（加分題）為 <code>multiply(int, int)</code> 與 <code>multiply(double, double)</code> 再加上 <code>multiply(int, int, int)</code> 多載版本</p></li></ol><hr><h1 id="本章總結"><a href="#本章總結" class="headerlink" title="本章總結"></a>本章總結</h1><table><thead><tr><th>功能</th><th>說明</th><th>範例</th></tr></thead><tbody><tr><td>傳值</td><td>基本型別（int, double）複製內容</td><td><code>add(a, b)</code></td></tr><tr><td>傳參考</td><td>陣列、物件傳址，原物件會被改變</td><td><code>modifyArray(arr)</code></td></tr><tr><td>回傳值</td><td>使用 <code>return</code> 傳結果回主程式</td><td><code>int result = add()</code></td></tr><tr><td>Overloading</td><td>同名方法支援不同參數型別</td><td><code>multiply(int)</code> vs <code>multiply(double)</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 05-2 集合（List / Set / Map）</title>
      <link href="/2025/05/03/Java/java-05-2/"/>
      <url>/2025/05/03/Java/java-05-2/</url>
      
        <content type="html"><![CDATA[<h1 id="認識-Java-集合（Collection）"><a href="#認識-Java-集合（Collection）" class="headerlink" title="認識 Java 集合（Collection）"></a>認識 Java 集合（Collection）</h1><p>Java 中的集合（Collection）用來處理「不定數量」的資料，與固定長度的陣列不同。<br>本章將介紹三種最常用的集合：</p><table><thead><tr><th>類型</th><th>說明</th><th>是否可重複</th><th>是否有順序</th></tr></thead><tbody><tr><td>List</td><td>有順序、可重複</td><td>✅ 是</td><td>✅ 是</td></tr><tr><td>Set</td><td>無順序、不重複</td><td>❌ 否</td><td>❌ 否</td></tr><tr><td>Map</td><td>鍵值對（Key-Value）</td><td>✅ Key 不可重複</td><td>✅ 依實作而定</td></tr></tbody></table><hr><h1 id="類別：CollectionExample"><a href="#類別：CollectionExample" class="headerlink" title="類別：CollectionExample"></a>類別：CollectionExample</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        useList();</span><br><span class="line">        useSet();</span><br><span class="line">        useMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useList</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        fruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String fruit : fruits) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[List] &quot;</span> + fruit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useSet</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">&quot;Mendel&quot;</span>);</span><br><span class="line">        names.add(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        names.add(<span class="string">&quot;Mendel&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[Set] &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useMap</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; scores = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        scores.put(<span class="string">&quot;Mendel&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        scores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">85</span>);</span><br><span class="line">        scores.put(<span class="string">&quot;Mendel&quot;</span>, <span class="number">95</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String key : scores.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[Map] &quot;</span> + key + <span class="string">&quot; 的成績是：&quot;</span> + scores.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="方法說明：useList"><a href="#方法說明：useList" class="headerlink" title="方法說明：useList()"></a>方法說明：useList()</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>儲存多筆資料（可重複、有順序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useList</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    fruits.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    fruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    fruits.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String fruit : fruits) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[List] &quot;</span> + fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2: 建立一個 <code>List</code> 物件並指定泛型為 <code>String</code></li><li>Line 3–5: 使用 <code>.add()</code> 增加元素（可重複）</li><li>Line 7: 使用 for-each 逐一輸出元素（保留順序）</li></ul><blockquote><p><strong>小提醒</strong><br><code>List</code> 用於有順序及可重覆的資料（如登入帳號清單、唯一分類…）</p></blockquote><hr><h2 id="方法說明：useSet"><a href="#方法說明：useSet" class="headerlink" title="方法說明：useSet()"></a>方法說明：useSet()</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>儲存唯一資料（不可重複、無順序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useSet</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;Mendel&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;Mendel&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Set] &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2: 使用 <code>HashSet</code> 建立集合（不可重複）</li><li>Line 3–5: 即使重複加入 “Mendel”，集合中仍只會保留一次</li><li>Line 7: 使用 for-each 走訪元素（不保證順序）</li></ul><blockquote><p><strong>小提醒</strong><br><code>Set</code> 用於唯一性需求的資料（如登入帳號清單、唯一分類…）</p></blockquote><hr><h2 id="方法說明：useMap"><a href="#方法說明：useMap" class="headerlink" title="方法說明：useMap()"></a>方法說明：useMap()</h2><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>使用鍵值對（Key-Value）儲存資料，類似字典。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; scores = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    scores.put(<span class="string">&quot;Mendel&quot;</span>, <span class="number">90</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">85</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;Mendel&quot;</span>, <span class="number">95</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String key : scores.keySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Map] &quot;</span> + key + <span class="string">&quot; 的成績是：&quot;</span> + scores.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2: 建立 <code>Map</code> 物件，key 為 <code>String</code>，value 為 <code>Integer</code></li><li>Line 3–5: 若對相同 key 多次 <code>.put()</code>，會覆蓋舊資料</li><li>Line 7: 使用 <code>.keySet()</code> 走訪所有 key，再透過 <code>.get()</code> 取得對應值</li></ul><blockquote><p><strong>小提醒</strong><br><code>Map</code> 常用於需要對應的資料（如帳號密碼、學號成績等結構…）</p></blockquote><hr><h1 id="本章練習題"><a href="#本章練習題" class="headerlink" title="本章練習題"></a>本章練習題</h1><ol><li><p>建立一個 <code>List&lt;Integer&gt;</code> 存入 <code>10, 20, 30, 10</code>，並印出所有元素與總和</p></li><li><p>建立一個 <code>Set&lt;String&gt;</code> 存入 <code>[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;red&quot;]</code>，印出所有不重複顏色</p></li><li><p>建立一個 <code>Map&lt;String, String&gt;</code> 存入以下資料，並印出每個人最喜歡的顏色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Mendel&quot;</span> -&gt; <span class="string">&quot;Blue&quot;</span>  </span><br><span class="line"><span class="string">&quot;Alice&quot;</span> -&gt; <span class="string">&quot;Green&quot;</span>  </span><br><span class="line"><span class="string">&quot;Mendel&quot;</span> -&gt; <span class="string">&quot;Red&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>（加分題）寫一個方法 <code>countWords(List&lt;String&gt; list)</code> 統計每個單字出現次數，使用 <code>Map&lt;String, Integer&gt;</code> 回傳結果</p></li></ol><hr><h1 id="本章總結"><a href="#本章總結" class="headerlink" title="本章總結"></a>本章總結</h1><table><thead><tr><th>集合類型</th><th>是否重複</th><th>是否排序</th><th>實作類別</th><th>用途</th></tr></thead><tbody><tr><td>List</td><td>✅ 是</td><td>✅ 有順序</td><td>ArrayList</td><td>可重複列表，如購物車</td></tr><tr><td>Set</td><td>❌ 否</td><td>❌ 無順序</td><td>HashSet</td><td>唯一資料清單，如會員ID</td></tr><tr><td>Map</td><td>✅ Key唯一</td><td>✅ 有 key 取值</td><td>HashMap</td><td>對應關係，如學生成績表</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 05 陣列與巢狀迴圈</title>
      <link href="/2025/05/03/Java/java-05/"/>
      <url>/2025/05/03/Java/java-05/</url>
      
        <content type="html"><![CDATA[<h1 id="陣列與巢狀迴圈（Nested-Loop）"><a href="#陣列與巢狀迴圈（Nested-Loop）" class="headerlink" title="陣列與巢狀迴圈（Nested Loop）"></a>陣列與巢狀迴圈（Nested Loop）</h1><p>當資料從單一筆變成「多筆」，我們需要使用「陣列」來儲存、使用「迴圈」來處理。<br>本章學會的重點：</p><ul><li>一維陣列的宣告與遍歷</li><li>二維陣列與巢狀迴圈</li><li><code>for</code>、<code>for-each</code> 搭配陣列輸出</li><li>方法封裝資料處理邏輯（印出、加總、平均等）</li></ul><hr><h1 id="類別：ArrayLoopExample"><a href="#類別：ArrayLoopExample" class="headerlink" title="類別：ArrayLoopExample"></a>類別：ArrayLoopExample</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayLoopExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printScores();</span><br><span class="line">        sumScores();</span><br><span class="line">        print2DTable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printScores</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] scores = &#123;<span class="number">80</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; scores.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[for] 第 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 筆成績：&quot;</span> + scores[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> score : scores) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[foreach] 成績：&quot;</span> + score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumScores</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] scores = &#123;<span class="number">80</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> score : scores) &#123;</span><br><span class="line">            sum += score;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;總分：&quot;</span> + sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;平均：&quot;</span> + (sum / (<span class="type">double</span>) scores.length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print2DTable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] table = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; table[i].length; j++) &#123;</span><br><span class="line">                System.out.print(table[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="方法說明：printScores"><a href="#方法說明：printScores" class="headerlink" title="方法說明：printScores()"></a>方法說明：printScores()</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>輸出一維陣列資料，使用 <code>for</code> 與 <code>for-each</code> 做對照。</p><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 「類別」（class）→請參考 Java 01.簡介</li><li>Line 5: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 10: 宣告整數陣列 <code>scores</code></li><li>Line 11-13: 傳統 for 迴圈搭配索引遍歷陣列</li><li>Line 14-16: 使用 for-each 更簡潔地走訪每一個元素</li></ul><hr><h2 id="方法說明：sumScores"><a href="#方法說明：sumScores" class="headerlink" title="方法說明：sumScores()"></a>方法說明：sumScores()</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>計算一維陣列的總和與平均。</p><h3 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 18: 宣告整數陣列 <code>scores</code></li><li>Line 19: 宣告加總變數 <code>sum</code></li><li>Line 20-22: 使用 for-each 將每筆成績加入 <code>sum</code></li><li>Line 23-24: 輸出總和與平均值（需轉型為 <code>double</code>）</li></ul><hr><h2 id="方法說明：print2DTable"><a href="#方法說明：print2DTable" class="headerlink" title="方法說明：print2DTable()"></a>方法說明：print2DTable()</h2><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>使用巢狀 for 迴圈，印出二維陣列的內容。</p><h3 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 26: 宣告一個二維整數陣列 <code>table</code></li><li>Line 30-31: 外層 for 控制列，內層 for 控制行</li><li>Line 32: 使用 <code>print()</code> 讓數字同列顯示</li><li>Line 33: 換行處理換列</li></ul><hr><h1 id="本章練習題"><a href="#本章練習題" class="headerlink" title="本章練習題"></a>本章練習題</h1><ol><li><p>請使用 <code>for</code> 輸出陣列 <code>&#123;1, 2, 3, 4, 5&#125;</code> 中的所有奇數</p></li><li><p>使用 <code>for-each</code> 遍歷陣列，並輸出所有小於 60 的成績（不及格）</p></li><li><p>宣告二維陣列如下，計算每一列的加總</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>（加分題）請設計一個方法 <code>sum2D(int[][] array)</code>，回傳二維陣列所有值的總和</p></li></ol><hr><h1 id="本章教學總結"><a href="#本章教學總結" class="headerlink" title="本章教學總結"></a>本章教學總結</h1><table><thead><tr><th>技能</th><th>關鍵語法</th><th>適用場景</th></tr></thead><tbody><tr><td>宣告陣列</td><td><code>int[] a = &#123;&#125;</code></td><td>儲存多筆資料</td></tr><tr><td>for 迴圈</td><td><code>for (int i = 0; i &lt; a.length; i++)</code></td><td>控制索引輸出</td></tr><tr><td>for-each</td><td><code>for (int n : a)</code></td><td>簡潔遍歷，不需索引</td></tr><tr><td>巢狀 for</td><td><code>for () &#123; for () &#123; ... &#125; &#125;</code></td><td>處理二維資料如表格</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 程式設計 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 04 迴圈控制：for、while、do-while、for-each 整合</title>
      <link href="/2025/05/03/Java/java-04/"/>
      <url>/2025/05/03/Java/java-04/</url>
      
        <content type="html"><![CDATA[<h1 id="認識迴圈控制（Loop）"><a href="#認識迴圈控制（Loop）" class="headerlink" title="認識迴圈控制（Loop）"></a>認識迴圈控制（Loop）</h1><p>當我們需要重複執行某段邏輯時，就會使用<strong>迴圈（Loop）</strong>來處理。<br>Java 提供四種常見迴圈語法：</p><table><thead><tr><th>類型</th><th>用途</th><th>特性</th></tr></thead><tbody><tr><td><code>for</code></td><td>次數已知的重複</td><td>適合計數型迴圈</td></tr><tr><td><code>while</code></td><td>條件為真的重複</td><td>先判斷，後執行</td></tr><tr><td><code>do-while</code></td><td>至少執行一次</td><td>先執行，後判斷</td></tr><tr><td><code>for-each</code></td><td>用於遍歷陣列或集合</td><td>更簡潔，不可用於索引控制</td></tr></tbody></table><h1 id="迴圈整合設計：LoopExample-類別"><a href="#迴圈整合設計：LoopExample-類別" class="headerlink" title="迴圈整合設計：LoopExample 類別"></a>迴圈整合設計：LoopExample 類別</h1><p>以下將建立一個 <code>LoopExample</code> 類別，裡面包含四個方法，分別演示不同迴圈語法：</p><ul><li><code>forLoop()</code></li><li><code>whileLoop()</code></li><li><code>doWhileLoop()</code></li><li><code>forEachLoop()</code></li></ul><h2 id="完整範例"><a href="#完整範例" class="headerlink" title="完整範例"></a>完整範例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        forLoop();</span><br><span class="line">        whileLoop();</span><br><span class="line">        doWhileLoop();</span><br><span class="line">        forEachLoop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forLoop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[for] 第 &quot;</span> + i + <span class="string">&quot; 次&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">whileLoop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[while] 倒數：&quot;</span> + i);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWhileLoop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[do-while] 這行一定會執行一次&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachLoop</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] langs = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String lang : langs) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[foreach] 語言：&quot;</span> + lang);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="forLoop"><a href="#forLoop" class="headerlink" title="forLoop()"></a>forLoop()</h2><h3 id="功能說明"><a href="#功能說明" class="headerlink" title="功能說明"></a>功能說明</h3><p>使用 <code>for</code> 迴圈執行 1~5 次，適合用於明確知道執行次數的情境。 for 由三部分組成：初始值、條件、遞增&#x2F;遞減邏輯。</p><h3 id="程式片段"><a href="#程式片段" class="headerlink" title="程式片段"></a>程式片段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forLoop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[for] 第 &quot;</span> + i + <span class="string">&quot; 次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="whileLoop"><a href="#whileLoop" class="headerlink" title="whileLoop()"></a>whileLoop()</h2><h3 id="功能說明-1"><a href="#功能說明-1" class="headerlink" title="功能說明"></a>功能說明</h3><p>使用 <code>while</code> 倒數 5 次，條件為真就持續執行。</p><h3 id="程式片段-1"><a href="#程式片段-1" class="headerlink" title="程式片段"></a>程式片段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">whileLoop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[while] 倒數：&quot;</span> + i);</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="doWhileLoop"><a href="#doWhileLoop" class="headerlink" title="doWhileLoop()"></a>doWhileLoop()</h2><h3 id="功能說明-2"><a href="#功能說明-2" class="headerlink" title="功能說明"></a>功能說明</h3><p>使用 <code>do-while</code>，即使條件一開始為 false，也會先執行一次。</p><h3 id="程式片段-2"><a href="#程式片段-2" class="headerlink" title="程式片段"></a>程式片段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWhileLoop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[do-while] 這行一定會執行一次&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="forEachLoop"><a href="#forEachLoop" class="headerlink" title="forEachLoop()"></a>forEachLoop()</h2><h3 id="功能說明-3"><a href="#功能說明-3" class="headerlink" title="功能說明"></a>功能說明</h3><p>走訪陣列 <code>String[]</code>，用 for-each 逐一輸出每個元素內容。適合用於遍歷資料集合。</p><h3 id="程式片段-3"><a href="#程式片段-3" class="headerlink" title="程式片段"></a>程式片段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachLoop</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] langs = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (String lang : langs) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[foreach] 語言：&quot;</span> + lang);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="本章練習題（整合應用）"><a href="#本章練習題（整合應用）" class="headerlink" title="本章練習題（整合應用）"></a>本章練習題（整合應用）</h1><ol><li>修改 <code>forLoop()</code>，使其只輸出偶數次數</li><li>修改 <code>whileLoop()</code>，讓它從 10 倒數到 1，且每次輸出時多印出累加總和</li><li>在 <code>doWhileLoop()</code> 中加入使用者輸入密碼的驗證（搭配 Scanner）</li><li>將 <code>forEachLoop()</code> 改為輸出陣列長度與元素順序編號（ex: 第1個語言：Java）</li><li>（加分題）新增 <code>sumBetween(int start, int end)</code>，使用任一迴圈回傳區間總和</li></ol><blockquote><p><strong>提示</strong><br>每個方法可獨立練習與驗證，<code>main()</code> 中可選擇呼叫順序。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 程式設計 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 03-2 條件判斷與邏輯運算（二）Switch語法</title>
      <link href="/2025/05/01/Java/java-03-2/"/>
      <url>/2025/05/01/Java/java-03-2/</url>
      
        <content type="html"><![CDATA[<h1 id="認識-switch-條件結構"><a href="#認識-switch-條件結構" class="headerlink" title="認識 switch 條件結構"></a>認識 switch 條件結構</h1><p>當我們要根據<strong>單一條件值</strong>對應多種輸出時，<code>switch</code> 是比連續 <code>if-else</code> 更直覺的寫法。<br>JDK 21 新增的 <code>switch expression</code> 更可直接產生回傳值，讓語法更簡潔有力。</p><hr><h1 id="傳統-switch-寫法"><a href="#傳統-switch-寫法" class="headerlink" title="傳統 switch 寫法"></a>傳統 switch 寫法</h1><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraditionalSwitchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        String result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                result = <span class="string">&quot;星期一&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                result = <span class="string">&quot;星期二&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                result = <span class="string">&quot;星期三&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result = <span class="string">&quot;其他&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;今天是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 「類別」（class）→請參考 Java 01.簡介</li><li>Line 4: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 5: 宣告整數變數 <code>day</code></li><li>Line 6: 宣告儲存結果的變數 <code>result</code></li><li>Line 8-17: 傳統 switch 結構，每個 <code>case</code> 結尾需 <code>break</code> 防止落入下一個</li><li>Line 19: 輸出結果</li></ul><hr><h1 id="switch-expression（JDK-21）"><a href="#switch-expression（JDK-21）" class="headerlink" title="switch expression（JDK 21）"></a>switch expression（JDK 21）</h1><p>Java 21 支援 <strong>switch expression</strong> 語法，不再需要 <code>break</code>，可直接將 switch 結果指派給變數或回傳。</p><h2 id="範例-1"><a href="#範例-1" class="headerlink" title="範例"></a>範例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchExpressionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dayName</span> <span class="operator">=</span> getDayName(day);</span><br><span class="line">        System.out.println(<span class="string">&quot;今天是：&quot;</span> + dayName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDayName</span><span class="params">(<span class="type">int</span> day)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> -&gt; <span class="string">&quot;星期一&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> -&gt; <span class="string">&quot;星期二&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> -&gt; <span class="string">&quot;星期三&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span> -&gt; <span class="string">&quot;星期四&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span> -&gt; <span class="string">&quot;星期五&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span> -&gt; <span class="string">&quot;週末&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="string">&quot;未知&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1~3: →請參考 Java 01.簡介</li><li>Line 4: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 5: 輸入星期數字</li><li>Line 6: 呼叫 <code>getDayName()</code> 並取得回傳值</li><li>Line 9: 定義方法，輸入整數 <code>day</code>，回傳對應的中文星期</li><li>Line 10-17: 使用 switch expression 配合箭頭語法 <code>-&gt;</code></li></ul><blockquote><h3 id="小提醒：為什麼要用方法？"><a href="#小提醒：為什麼要用方法？" class="headerlink" title="小提醒：為什麼要用方法？"></a>小提醒：為什麼要用方法？</h3><p>將 switch 邏輯獨立成方法，可以讓主程式更清楚、可重複使用，也方便單元測試與維護。</p></blockquote><hr><h1 id="綜合範例：月份對應季節"><a href="#綜合範例：月份對應季節" class="headerlink" title="綜合範例：月份對應季節"></a>綜合範例：月份對應季節</h1><h2 id="範例-2"><a href="#範例-2" class="headerlink" title="範例"></a>範例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeasonExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNKNOWN</span> <span class="operator">=</span> <span class="string">&quot;未知季節&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">season</span> <span class="operator">=</span> getSeason(month);</span><br><span class="line">        System.out.println(<span class="string">&quot;月份：&quot;</span> + month);</span><br><span class="line">        System.out.println(<span class="string">&quot;季節：&quot;</span> + season);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSeason</span><span class="params">(<span class="type">int</span> month)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> -&gt; <span class="string">&quot;春&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> -&gt; <span class="string">&quot;夏&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> -&gt; <span class="string">&quot;秋&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span> -&gt; <span class="string">&quot;冬&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; UNKNOWN;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1~3: →請參考 Java 01.簡介</li><li>Line 4: 宣告常數 <code>UNKNOWN</code> 為預設回傳值</li><li>Line 6: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 7: 使用者輸入月份（這裡寫死為 4）</li><li>Line 8: 呼叫 <code>getSeason()</code> 方法並取得結果</li><li>Line 11: 定義方法，輸入整數 <code>month</code>，回傳字串</li><li>Line 12-17: 對應不同月份回傳季節（含合併條件）</li></ul><hr><h1 id="本章練習題"><a href="#本章練習題" class="headerlink" title="本章練習題"></a>本章練習題</h1><ol><li><p>撰寫 <code>getDayName(int)</code> 方法，輸入 1~7 回傳「星期一」到「星期日」，否則回傳「未知」</p></li><li><p>撰寫 <code>getSeason(int)</code> 方法，根據月份輸出「春夏秋冬」，錯誤數字回傳「未知季節」</p></li><li><p>將職位轉換為薪資等級：</p><ul><li>“Intern” → “Level 1”</li><li>“Engineer” → “Level 2”</li><li>“Manager” → “Level 3”</li><li>其他 → “Unknown”</li></ul></li><li><p>（加分題）使用 <code>Scanner</code> 輸入月份，呼叫 <code>getSeason()</code> 並印出季節</p></li></ol><blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>練習將條件封裝進方法中，並讓主程式保持簡潔與易讀性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 程式設計 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 03 條件判斷與邏輯運算（一）if、邏輯運算與方法</title>
      <link href="/2025/05/01/Java/java-03/"/>
      <url>/2025/05/01/Java/java-03/</url>
      
        <content type="html"><![CDATA[<h1 id="認識條件判斷"><a href="#認識條件判斷" class="headerlink" title="認識條件判斷"></a>認識條件判斷</h1><p>程式運作常會依據<strong>條件結果</strong>來決定流程走向。<br>本章會介紹：</p><ul><li><code>if</code>, <code>else if</code>, <code>else</code> 的基本使用</li><li>邏輯運算子（布林邏輯）</li><li>巢狀條件結構（Nested if）</li><li>方法（Method）的定義與呼叫方式（含 Signature）</li></ul><hr><h1 id="if、else-if、else-條件結構"><a href="#if、else-if、else-條件結構" class="headerlink" title="if、else if、else 條件結構"></a>if、else if、else 條件結構</h1><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;優秀！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;及格！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不及格！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 「類別」（class）→請參考 Java 01.簡介</li><li>Line 4: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 5: 宣告一個整數變數 <code>score</code></li><li>Line 7-13: 根據條件，執行對應的輸出內容</li></ul><hr><h1 id="邏輯運算子（Boolean-Operators）"><a href="#邏輯運算子（Boolean-Operators）" class="headerlink" title="邏輯運算子（Boolean Operators）"></a>邏輯運算子（Boolean Operators）</h1><p>在多條件情境下，我們可以使用邏輯運算子結合判斷：</p><table><thead><tr><th>運算子</th><th>說明</th><th>範例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>且（AND）</td><td><code>a &gt; 0 &amp;&amp; b &gt; 0</code></td></tr><tr><td>&#96;</td><td></td><td>&#96;</td></tr><tr><td><code>!</code></td><td>非（NOT）</td><td><code>!(a &gt; 0)</code></td></tr></tbody></table><h2 id="範例-1"><a href="#範例-1" class="headerlink" title="範例"></a>範例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogicalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasLicense</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">18</span> &amp;&amp; hasLicense) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;可以開車！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;無法開車！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 「類別」（class）→請參考 Java 01.簡介</li><li>Line 4: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 5-6: 宣告整數與布林變數</li><li>Line 8-12: 結合 <code>&amp;&amp;</code> 運算，兩條件都成立才顯示可開車</li></ul><hr><h1 id="巢狀-if-結構（Nested-if）"><a href="#巢狀-if-結構（Nested-if）" class="headerlink" title="巢狀 if 結構（Nested if）"></a>巢狀 if 結構（Nested if）</h1><h2 id="範例-2"><a href="#範例-2" class="headerlink" title="範例"></a>範例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestedIfExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isStudent</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStudent) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;成年人（學生）&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;成年人（非學生）&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未成年&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1~4: 請參考上方說明</li><li>Line 5-6: 設定條件變數</li><li>Line 8-14: 外層判斷成年與否，內層再依據學生身分細分</li></ul><hr><h1 id="方法（Method）的定義與使用"><a href="#方法（Method）的定義與使用" class="headerlink" title="方法（Method）的定義與使用"></a>方法（Method）的定義與使用</h1><p><strong>方法（Method）</strong>是封裝邏輯、增加可重複使用性的單位。<br>每個方法都有其<strong>簽章（Signature）</strong>，包含：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[存取修飾子] [<span class="keyword">static</span>] 回傳型別 方法名稱(參數...)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">gradeText</span><span class="params">(<span class="type">int</span> score)</span></span><br></pre></td></tr></table></figure><p>表示這是一個公開靜態方法，輸入整數 <code>score</code>，回傳字串。</p><h2 id="範例：方法封裝成績評語"><a href="#範例：方法封裝成績評語" class="headerlink" title="範例：方法封裝成績評語"></a>範例：方法封裝成績評語</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">78</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> getGrade(score);</span><br><span class="line">        System.out.println(<span class="string">&quot;成績評語：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getGrade</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) <span class="keyword">return</span> <span class="string">&quot;D&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;F&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-3"><a href="#說明-3" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1~4: 請參考前述</li><li>Line 5: 宣告整數變數 <code>score</code></li><li>Line 6: 呼叫 <code>getGrade()</code> 方法並接收回傳值</li><li>Line 8: 印出評語</li><li>Line 10-16: 方法 <code>getGrade()</code> 根據成績輸出字母等級</li></ul><hr><h1 id="本章練習題"><a href="#本章練習題" class="headerlink" title="本章練習題"></a>本章練習題</h1><ol><li><p>請撰寫一段程式碼，輸入分數後依下列規則印出：</p><ul><li>90~100：A</li><li>80~89：B</li><li>70~79：C</li><li>60~69：D</li><li>未滿60：F</li></ul></li><li><p>建立一個方法 <code>isAdult(int age)</code>，回傳布林值，表示是否為成年人（18歲以上）</p></li><li><p>建立一個方法 <code>canDrive(int age, boolean hasLicense)</code>，依條件回傳 <code>true/false</code> 表示是否能合法開車</p></li><li><p>（加分題）建立方法 <code>getHealthStatus(double bmi)</code>，依 BMI 值回傳：</p><ul><li>&lt;18.5：過輕</li><li>18.5~24：正常</li><li><blockquote><p>24：過重</p></blockquote></li></ul></li></ol><blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>所有方法請用 <code>public static</code>，方便在 <code>main()</code> 中直接呼叫。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 程式設計 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 02-2 字串處理：String 與 StringBuilder</title>
      <link href="/2025/05/01/Java/java-02-2/"/>
      <url>/2025/05/01/Java/java-02-2/</url>
      
        <content type="html"><![CDATA[<h1 id="認識-Java-字串（String）"><a href="#認識-Java-字串（String）" class="headerlink" title="認識 Java 字串（String）"></a>認識 Java 字串（String）</h1><p>在 Java 中，<code>String</code> 是一種常用的參考型別（Reference Type），代表文字資料。<br>使用雙引號 <code>&quot;</code> 包住的資料都是字串，例如 <code>&quot;Hello&quot;</code>、<code>&quot;123&quot;</code>。</p><hr><h1 id="類別：StringExample"><a href="#類別：StringExample" class="headerlink" title="類別：StringExample"></a>類別：StringExample</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        basicString();</span><br><span class="line">        compareString();</span><br><span class="line">        convertString();</span><br><span class="line">        useStringBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">basicString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Mendel&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">        System.out.println(<span class="string">&quot;[basic] &quot;</span> + greeting);</span><br><span class="line">        System.out.println(<span class="string">&quot;[basic] 長度：&quot;</span> + name.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;[basic] 第一個字元：&quot;</span> + name.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compareString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[compare] 相等內容：&quot;</span> + a.equals(b));</span><br><span class="line">        System.out.println(<span class="string">&quot;[compare] 是否同個物件：&quot;</span> + (a == b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convertString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf(number);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(pi);</span><br><span class="line">        <span class="type">int</span> <span class="variable">parsed</span> <span class="operator">=</span> Integer.parseInt(text);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[convert] int 轉字串：&quot;</span> + s1);</span><br><span class="line">        System.out.println(<span class="string">&quot;[convert] double 轉字串：&quot;</span> + s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;[convert] 字串轉 int：&quot;</span> + (parsed + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useStringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;StringBuilder&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;[builder] 結果：&quot;</span> + sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="方法說明：basicString"><a href="#方法說明：basicString" class="headerlink" title="方法說明：basicString()"></a>方法說明：basicString()</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>基本字串操作：長度、連接、字元讀取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">basicString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Mendel&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">System.out.println(<span class="string">&quot;[basic] &quot;</span> + greeting);</span><br><span class="line">System.out.println(<span class="string">&quot;[basic] 長度：&quot;</span> + name.length());</span><br><span class="line">System.out.println(<span class="string">&quot;[basic] 第一個字元：&quot;</span> + name.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2: 建立 <code>String</code> 變數 <code>name</code></li><li>Line 3: 使用 <code>+</code> 連接字串</li><li>Line 4: 輸出字串</li><li>Line 5: 使用 <code>.length()</code> 計算長度</li><li>Line 6: 使用 <code>.charAt(0)</code> 取得第一個字元</li></ul><hr><h2 id="方法說明：compareString"><a href="#方法說明：compareString" class="headerlink" title="方法說明：compareString()"></a>方法說明：compareString()</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>比較字串內容與記憶體參考。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compareString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;[compare] 相等內容：&quot;</span> + a.equals(b));</span><br><span class="line">System.out.println(<span class="string">&quot;[compare] 是否同個物件：&quot;</span> + (a == b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2: <code>a</code> 為常數池中的字串物件</li><li>Line 3: <code>b</code> 使用 <code>new</code> 建立新物件，內容相同但記憶體不同</li><li>Line 5: 使用 <code>.equals()</code> 比較<strong>內容</strong></li><li>Line 6: 使用 <code>==</code> 比較<strong>記憶體位置（參考）</strong></li></ul><hr><h2 id="方法說明：convertString"><a href="#方法說明：convertString" class="headerlink" title="方法說明：convertString()"></a>方法說明：convertString()</h2><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>進行基本型別與字串間的轉換。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convertString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf(number);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(pi);</span><br><span class="line"><span class="type">int</span> <span class="variable">parsed</span> <span class="operator">=</span> Integer.parseInt(text);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;[convert] int 轉字串：&quot;</span> + s1);</span><br><span class="line">System.out.println(<span class="string">&quot;[convert] double 轉字串：&quot;</span> + s2);</span><br><span class="line">System.out.println(<span class="string">&quot;[convert] 字串轉 int：&quot;</span> + (parsed + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2~4: 整數、浮點數與字串</li><li>Line 6~7: 使用 <code>String.valueOf()</code> 將數值轉為字串</li><li>Line 8: 使用 <code>Integer.parseInt()</code> 將字串轉回整數</li></ul><hr><h2 id="方法說明：useStringBuilder"><a href="#方法說明：useStringBuilder" class="headerlink" title="方法說明：useStringBuilder()"></a>方法說明：useStringBuilder()</h2><h3 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h3><p>介紹使用 <code>StringBuilder</code> 進行多次字串拼接，效能較佳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useStringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;StringBuilder&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;[builder] 結果：&quot;</span> + sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明-3"><a href="#說明-3" class="headerlink" title="說明"></a>說明</h3><ul><li>Line 2: 建立 <code>StringBuilder</code> 物件</li><li>Line 3~5: 多次使用 <code>.append()</code> 拼接字串</li><li>Line 6: 使用 <code>.toString()</code> 取得完整結果</li></ul><blockquote><p><strong>小提醒</strong><br>如果在迴圈中頻繁操作字串，建議使用 <code>StringBuilder</code>，效率比 <code>+</code> 快很多。</p></blockquote><hr><h1 id="本章練習題"><a href="#本章練習題" class="headerlink" title="本章練習題"></a>本章練習題</h1><ol><li><p>請宣告兩個字串 <code>s1 = &quot;Hello&quot;</code>、<code>s2 = &quot;World&quot;</code>，將它們用三種方式合併輸出：</p><ul><li>使用 <code>+</code></li><li>使用 <code>concat()</code></li><li>使用 <code>StringBuilder</code></li></ul></li><li><p>使用 <code>.length()</code> 與 <code>.charAt()</code> 輸出你名字的字數與前三個字元</p></li><li><p>宣告一個字串 <code>&quot;2025&quot;</code>，轉換成整數後加 5 並輸出結果</p></li><li><p>宣告一個字串 <code>&quot;HELLO&quot;</code>，轉成小寫並輸出（提示：<code>.toLowerCase()</code>）</p></li><li><p>（加分題）撰寫方法 <code>isEqualIgnoreCase(String a, String b)</code>，比較兩字串是否忽略大小寫後相等</p></li></ol><hr><h1 id="本章總結"><a href="#本章總結" class="headerlink" title="本章總結"></a>本章總結</h1><table><thead><tr><th>功能</th><th>方法 &#x2F; 操作</th><th>範例</th></tr></thead><tbody><tr><td>字串連接</td><td><code>+</code>, <code>concat()</code></td><td><code>&quot;A&quot; + &quot;B&quot;</code></td></tr><tr><td>長度 &#x2F; 位置</td><td><code>.length()</code>, <code>.charAt(i)</code></td><td><code>s.charAt(0)</code></td></tr><tr><td>比較</td><td><code>.equals()</code>, <code>==</code>, <code>.equalsIgnoreCase()</code></td><td></td></tr><tr><td>轉換</td><td><code>String.valueOf()</code>, <code>Integer.parseInt()</code></td><td></td></tr><tr><td>拼接最佳化</td><td><code>StringBuilder</code> + <code>.append()</code></td><td><code>sb.append(&quot;text&quot;)</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 字串處理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 02 基本語法：變數、常數與資料型態</title>
      <link href="/2025/05/01/Java/java-02/"/>
      <url>/2025/05/01/Java/java-02/</url>
      
        <content type="html"><![CDATA[<h1 id="認識基本語法"><a href="#認識基本語法" class="headerlink" title="認識基本語法"></a>認識基本語法</h1><p>本章節將學習以下主題：</p><ul><li>變數與常數的宣告方式</li><li>Java 資料型態分類</li><li>區域與全域變數的差異</li><li>常見存取修飾子（Access Modifiers）</li></ul><hr><h1 id="變數（Variable）"><a href="#變數（Variable）" class="headerlink" title="變數（Variable）"></a>變數（Variable）</h1><p>變數是用來儲存資料的命名空間，必須先宣告型別。<br>Java 中變數也有<strong>作用範圍（Scope）</strong>與<strong>存取權限（Access Level）</strong>的概念。</p><h2 id="範例：區域變數"><a href="#範例：區域變數" class="headerlink" title="範例：區域變數"></a>範例：區域變數</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">175.5</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isStudent</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Mendel&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年齡：&quot;</span> + age);</span><br><span class="line">        System.out.println(<span class="string">&quot;身高：&quot;</span> + height);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否為學生：&quot;</span> + isStudent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 「類別」（class）→請參考 Java 01.簡介</li><li>Line 4: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 5-8: 宣告區域變數（僅在 main 方法內有效）</li><li>Line 10-13: 使用變數輸出資訊</li></ul><hr><h1 id="Global-vs-Local-變數"><a href="#Global-vs-Local-變數" class="headerlink" title="Global vs Local 變數"></a>Global vs Local 變數</h1><table><thead><tr><th>類型</th><th>宣告位置</th><th>作用範圍</th><th>是否需初始化</th><th>常見用途</th></tr></thead><tbody><tr><td>區域變數 (Local)</td><td>方法或區塊內</td><td>只能在該區塊使用</td><td>必須初始化</td><td>計算用、短暫記錄</td></tr><tr><td>成員變數 (Global)</td><td>類別中、方法外</td><td>整個類別中可用</td><td>有預設值</td><td>物件屬性、常數</td></tr></tbody></table><h2 id="範例：全域變數"><a href="#範例：全域變數" class="headerlink" title="範例：全域變數"></a>範例：全域變數</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScopeExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span> <span class="string">&quot;Mendel College&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">student</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;學校名稱：&quot;</span> + schoolName);</span><br><span class="line">        System.out.println(<span class="string">&quot;學生：&quot;</span> + student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 「類別」（class）→請參考 Java 01.簡介</li><li>Line 4: 宣告全域變數 <code>schoolName</code>，<code>static</code> 讓它不需建立物件即可使用</li><li>Line 6-8: 宣告區域變數、並輸出兩者結果</li></ul><hr><h1 id="存取修飾子（Access-Modifiers）"><a href="#存取修飾子（Access-Modifiers）" class="headerlink" title="存取修飾子（Access Modifiers）"></a>存取修飾子（Access Modifiers）</h1><p>在 Java 中，變數與方法都可以設定不同的存取權限，決定外部是否可存取。</p><table><thead><tr><th>修飾子</th><th>說明</th><th>使用範圍</th></tr></thead><tbody><tr><td><code>public</code></td><td>完全開放</td><td>任意類別皆可使用</td></tr><tr><td><code>protected</code></td><td>類別與子類別共享</td><td>包含 package 與繼承</td></tr><tr><td><em>(無修飾詞)</em></td><td>預設（default）</td><td>僅限同一個 package</td></tr><tr><td><code>private</code></td><td>完全封閉</td><td>僅限當前類別中使用</td></tr></tbody></table><h2 id="小提醒：變數範例"><a href="#小提醒：變數範例" class="headerlink" title="小提醒：變數範例"></a>小提醒：變數範例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModifierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;公開變數&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">note</span> <span class="operator">=</span> <span class="string">&quot;package可見&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="常數（Constant）"><a href="#常數（Constant）" class="headerlink" title="常數（Constant）"></a>常數（Constant）</h1><p>若變數值需固定不可變，則可使用 <code>final</code>。<br>而若常數需被整個專案共用，會使用 <strong><code>public static final</code></strong> 宣告於類別中。</p><h2 id="範例：宣告全域常數"><a href="#範例：宣告全域常數" class="headerlink" title="範例：宣告全域常數"></a>範例：宣告全域常數</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;圓周率：&quot;</span> + PI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 「類別」（class）→請參考 Java 01.簡介</li><li>Line 4: 宣告常數，使用 <code>public static final</code> 修飾，可供外部存取、不可變</li><li>Line 6: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 7: 輸出常數</li></ul><blockquote><h3 id="小提醒：常數命名"><a href="#小提醒：常數命名" class="headerlink" title="小提醒：常數命名"></a>小提醒：常數命名</h3><p>建議使用全大寫 + 底線（如：<code>MAX_SPEED</code>, <code>PI_VALUE</code>）</p></blockquote><hr><h1 id="資料型態（Data-Types）"><a href="#資料型態（Data-Types）" class="headerlink" title="資料型態（Data Types）"></a>資料型態（Data Types）</h1><p>Java 資料型態分為兩大類：</p><table><thead><tr><th>類型</th><th>說明</th><th>範例</th></tr></thead><tbody><tr><td>基本型別（Primitive）</td><td>儲存基本數值</td><td><code>int</code>, <code>double</code>, <code>boolean</code>, <code>char</code></td></tr><tr><td>參考型別（Reference）</td><td>儲存物件參考</td><td><code>String</code>, 陣列, 自訂類別</td></tr></tbody></table><h2 id="小整理：基本型別對照表"><a href="#小整理：基本型別對照表" class="headerlink" title="小整理：基本型別對照表"></a>小整理：基本型別對照表</h2><table><thead><tr><th>型別</th><th>大小</th><th>範例</th></tr></thead><tbody><tr><td>byte</td><td>1 byte</td><td><code>byte b = 10;</code></td></tr><tr><td>short</td><td>2 bytes</td><td><code>short s = 1000;</code></td></tr><tr><td>int</td><td>4 bytes</td><td><code>int i = 100000;</code></td></tr><tr><td>long</td><td>8 bytes</td><td><code>long l = 10000000000L;</code></td></tr><tr><td>float</td><td>4 bytes（小數）</td><td><code>float f = 3.14f;</code></td></tr><tr><td>double</td><td>8 bytes（更高精度）</td><td><code>double d = 3.14159;</code></td></tr><tr><td>char</td><td>2 bytes（Unicode）</td><td><code>char c = &#39;A&#39;;</code></td></tr><tr><td>boolean</td><td>1 bit（true&#x2F;false）</td><td><code>boolean flag = true;</code></td></tr></tbody></table><hr><h1 id="綜合範例"><a href="#綜合範例" class="headerlink" title="綜合範例"></a>綜合範例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTypePractice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;Mendel College&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">studentName</span> <span class="operator">=</span> <span class="string">&quot;Mendel&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">birthYear</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CURRENT_YEAR</span> <span class="operator">=</span> <span class="number">2025</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> CURRENT_YEAR - birthYear;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAdult</span> <span class="operator">=</span> age &gt;= <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;學生：&quot;</span> + studentName);</span><br><span class="line">        System.out.println(<span class="string">&quot;學校：&quot;</span> + SCHOOL_NAME);</span><br><span class="line">        System.out.println(<span class="string">&quot;年齡：&quot;</span> + age);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否成年：&quot;</span> + isAdult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-3"><a href="#說明-3" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 「類別」（class）→請參考 Java 01.簡介</li><li>Line 4: 宣告全域常數 <code>SCHOOL_NAME</code></li><li>Line 6: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 7-10: 使用變數、常數與基本運算邏輯</li><li>Line 12-15: 印出所有資訊</li></ul><hr><h1 id="本章練習題"><a href="#本章練習題" class="headerlink" title="本章練習題"></a>本章練習題</h1><ol><li><p>宣告三個變數，分別代表：</p><ul><li>姓名（String）</li><li>年齡（int）</li><li>是否為學生（boolean）</li></ul></li><li><p>宣告常數 <code>COUNTRY</code> 並賦值你最喜歡的國家<br>將其設為 <code>public static final</code></p></li><li><p>建立一個類別變數 <code>schoolName</code> 並在 <code>main()</code> 中輸出它（用 <code>static</code>）</p></li><li><p>建立一個全域變數為 <code>int MAX_SCORE = 100</code>，然後在 <code>main()</code> 使用它輸出格式化成績</p></li><li><p>（加分題）創建一個類別，包含：</p><ul><li>一個 <code>private</code> 的整數變數 <code>score</code></li><li>一個 <code>public</code> 的方法 <code>printScore()</code> 印出該變數</li></ul></li></ol><blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>嘗試組合使用：<code>public</code> &#x2F; <code>private</code>、<code>static</code>、<code>final</code>、與不同作用範圍的變數。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 程式設計 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 01-2 簡介（二）輸入：使用 Scanner 接收使用者輸入</title>
      <link href="/2025/05/01/Java/java-01-2/"/>
      <url>/2025/05/01/Java/java-01-2/</url>
      
        <content type="html"><![CDATA[<h1 id="認識輸入（Input）"><a href="#認識輸入（Input）" class="headerlink" title="認識輸入（Input）"></a>認識輸入（Input）</h1><p>在前一章中，我們已經學會如何用 <code>System.out.println</code> 將文字輸出到螢幕。<br>這一篇要進一步學習：<strong>如何接收使用者輸入</strong>，讓程式更有互動性。</p><p>Java 中常用的輸入工具是 <code>Scanner</code> 類別，它可以從 <code>System.in</code> 讀取鍵盤輸入。</p><hr><h1 id="使用-Scanner"><a href="#使用-Scanner" class="headerlink" title="使用 Scanner"></a>使用 Scanner</h1><h2 id="範例：讀取文字輸入"><a href="#範例：讀取文字輸入" class="headerlink" title="範例：讀取文字輸入"></a>範例：讀取文字輸入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  <span class="comment">// 建立 Scanner 物件</span></span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;請輸入您的名字：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();          <span class="comment">// 讀取一整行文字</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;你好，&quot;</span> + name + <span class="string">&quot;！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 匯入 <code>Scanner</code> 類別。<code>Scanner</code> 是 Java 提供的輸入工具，屬於 <code>java.util</code> 套件中的類別，必須先透過 <code>import</code> 才能使用</li><li>Line 5: 「類別」（class）→請參考 Java 01.簡介</li><li>Line 6: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 7: 使用 <code>new Scanner(System.in)</code> 產生一個可以讀取鍵盤輸入的掃描器物件</li><li>Line 9-10: 顯示提示文字，並使用 <code>nextLine()</code> 讀取一整行包含空白的使用者輸入</li><li>Line 12: 輸出組合好的歡迎訊息</li></ul><blockquote><h3 id="小提醒：匯入-Scanner"><a href="#小提醒：匯入-Scanner" class="headerlink" title="小提醒：匯入 Scanner"></a>小提醒：匯入 Scanner</h3><p>記得在檔案最上方加上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="讀取其他型別的輸入"><a href="#讀取其他型別的輸入" class="headerlink" title="讀取其他型別的輸入"></a>讀取其他型別的輸入</h1><h2 id="範例：讀取整數與浮點數"><a href="#範例：讀取整數與浮點數" class="headerlink" title="範例：讀取整數與浮點數"></a>範例：讀取整數與浮點數</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputTypeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;請輸入年齡：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt();  <span class="comment">// 讀取整數</span></span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;請輸入身高(cm)：&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">height</span> <span class="operator">=</span> scanner.nextDouble();  <span class="comment">// 讀取浮點數</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;年齡：&quot;</span> + age + <span class="string">&quot; 歲&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;身高：&quot;</span> + height + <span class="string">&quot; 公分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 匯入 <code>Scanner</code> 類別（如上方說明）</li><li>Line 5: 「類別」（class）→請參考 Java 01.簡介</li><li>Line 6: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 7: 建立可讀鍵盤輸入的 Scanner 物件</li><li>Line 9-10: 顯示提示訊息並使用 <code>nextInt()</code> 讀取整數輸入</li><li>Line 12-13: 顯示提示並使用 <code>nextDouble()</code> 讀取浮點數輸入</li><li>Line 15-16: 輸出年齡與身高</li></ul><blockquote><h3 id="小提醒：避免輸入錯誤"><a href="#小提醒：避免輸入錯誤" class="headerlink" title="小提醒：避免輸入錯誤"></a>小提醒：避免輸入錯誤</h3><p>如果先用 <code>nextInt()</code> 後面馬上接 <code>nextLine()</code>，會發生跳過的情形。<br>解法：中間加一行 <code>scanner.nextLine();</code> 清除換行符。</p></blockquote><hr><h1 id="綜合範例：輸入個人資訊"><a href="#綜合範例：輸入個人資訊" class="headerlink" title="綜合範例：輸入個人資訊"></a>綜合範例：輸入個人資訊</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfileInput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;請輸入姓名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;請輸入年齡：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        scanner.nextLine(); <span class="comment">// 清除換行符</span></span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;請輸入喜歡的顏色：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;======== 輸出結果 ========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年齡：&quot;</span> + age);</span><br><span class="line">        System.out.println(<span class="string">&quot;喜歡的顏色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h2><ul><li>Line 1: 「套件」（package）→請參考 Java 01.簡介</li><li>Line 3: 匯入 <code>Scanner</code> 類別（如上方說明）</li><li>Line 5: 「類別」（class）→請參考 Java 01.簡介</li><li>Line 6: 「主方法」（main）→請參考 Java 01.簡介</li><li>Line 7: 建立 Scanner 物件</li><li>Line 9-10: 顯示提示並讀取姓名（使用 <code>nextLine()</code>）</li><li>Line 12-13: 顯示提示並使用 <code>nextInt()</code> 讀取年齡</li><li>Line 14: 加一行 <code>scanner.nextLine()</code> 清除多餘的換行符，避免跳過下一行輸入</li><li>Line 16-17: 顯示提示並讀取喜歡的顏色</li><li>Line 19-21: 將所有輸入資料格式化輸出</li></ul><hr><h1 id="本章練習題"><a href="#本章練習題" class="headerlink" title="本章練習題"></a>本章練習題</h1><ol><li><p>請設計一個小程式，輸入使用者的名字與年齡，並輸出格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您好，張三，今年25歲，歡迎使用本系統！</span><br></pre></td></tr></table></figure></li><li><p>輸入使用者的身高與體重（浮點數），並計算 BMI：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BMI = 體重(kg) / 身高(m)^2</span><br></pre></td></tr></table></figure></li><li><p>試著使用 <code>nextLine()</code>、<code>nextInt()</code>、<code>nextDouble()</code> 各自輸入，觀察使用順序錯誤會發生什麼事？嘗試解決。</p></li><li><p>（加分題）輸入你的學號、系級與興趣，完整輸出一份「學生小檔案」。</p></li></ol><blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>練習順序：先文字 → 整數 → 再文字，記得用 <code>scanner.nextLine()</code> 處理跳行問題。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 程式設計 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 01 簡介</title>
      <link href="/2023/02/06/Python/python-01/"/>
      <url>/2023/02/06/Python/python-01/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h1><p>　　首先，先從<a href="https://www.python.org/downloads/">Python官網</a>下載Python並安裝(3.7各套件支援最完整，但於今年都就不再更新，建議使用3.8或3.9)，之後環境變數在PATH中會自動設定。</p><h1 id="安装開發工具-IDE"><a href="#安装開發工具-IDE" class="headerlink" title="安装開發工具(IDE)"></a>安装開發工具(IDE)</h1><p>　　接著再從<a href="https://code.visualstudio.com/download">Visual Stdio Code官網</a>下載IDE並安裝，然後就可以開啟使用了。</p><h1 id="介紹Hello-World"><a href="#介紹Hello-World" class="headerlink" title="介紹Hello World!"></a>介紹Hello World!</h1><p>　　不能免俗的要介紹一下Hello World！</p><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  多行註解</span></span><br><span class="line"><span class="string">  測試第一個class</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 顯示在Console的Hello World!</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    hw = HelloWorld()</span><br><span class="line">    hw.main()</span><br></pre></td></tr></table></figure><h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><p>　　一般市面上的書籍或線上教學都不是從物件導向設計（請參考<strong>物件導向設計</strong>）開始說明，但為了要能無縫接軌，我還是以類別為範例開始說起。讓我們從頭開始一行一行的看下去吧！</p><blockquote><p><strong>物件導向設計（英語：Object-oriented programming，縮寫：OOP）</strong><br>　　真實世界的事物轉為各種物件，物件之間彼此能互相操作溝通。而產生物件的東西就是類別。類別就如同設計圖一樣，依照此設計圖就能產生一個個的物件。</p></blockquote><ul><li>Line 1-4：多行註解</li><li>Line 5：class就是類別，類別會產生一個個的物件，就如同設計圖一樣，依照此設計圖就能產生一個個的物件。HelloWorld就是此類別的名稱，其命名方式是「大駝峰」（類別的命名方式請參考<strong>駝峰式命名</strong>）。</li><li>Line 6：def定義一個函式(function)，main為此函式名稱。self代表此類別或物件。-&gt;None定義此函式的回傳值，在Python回傳值的定義可有可無，無強制規定需定義。</li><li>Line 7：單行註解</li><li>Line 8：print此方法會將字串列印在標準輸入輸出裝置(Console)。</li><li>Line 10：當直接執行這隻程式時，__name__這個變數中的名稱會是__main__，若是由其他不同檔案的程式來呼叫這隻程式的話，就不會繼續執行裡面的東西。</li><li>Line 11：用這個類別新增一個物件hw。</li><li>Line 12：用這個物件去執行main的函式。</li></ul><blockquote><p><strong>駝峰式命名（Camel case）</strong><br>　　* 就像駝峰會一高一低<br>　　* 單字之間不空格，而是直接連起來，但是連起來的第一個字要大寫<br>　　* 例如：有一個 handle add post 的 function，就會叫做 handleAddPost<br>駝峰又有分兩種：<br>　　1. 小駝峰（lower camel case）：開頭是小寫，就像上面的範例 handleAddPost<br>　　2. 大駝峰（upper camel case）：又被稱為 Pascal Case。開頭變成大寫，也就會變成 HandleAddPost</p></blockquote><h2 id="練習題"><a href="#練習題" class="headerlink" title="練習題"></a>練習題</h2><p>　　1. 試著說明何謂 類別(Class)<br>　　2. 試著說明何謂 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“ 的用途<br>　　3. 試著建立一個類別為Homework，在Console中顯示您的個人資料，例：姓名、年齡、生日、喜好…等等。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 程式設計 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 01 簡介</title>
      <link href="/2023/02/04/Java/java-01/"/>
      <url>/2023/02/04/Java/java-01/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Java-JDK"><a href="#安装Java-JDK" class="headerlink" title="安装Java(JDK)"></a>安装Java(JDK)</h1><p>　　首先，先從<a href="https://www.azul.com/downloads/?package=jdk#download-openjdk">Zulu官網</a>下載Java Development Kit(JDK)並安裝，之後設定環境變數JAVA_HOME及在PATH中設定%JAVA_HOME%&#x2F;bin。</p><h1 id="安装開發工具-IDE"><a href="#安装開發工具-IDE" class="headerlink" title="安装開發工具(IDE)"></a>安装開發工具(IDE)</h1><p>　　接著再從<a href="https://netbeans.apache.org/download/index.html">NetBeans官網</a>下載IDE並安裝，然後就可以開啟使用了。</p><h1 id="介紹Hello-World"><a href="#介紹Hello-World" class="headerlink" title="介紹Hello World!"></a>介紹Hello World!</h1><h2 id="不能免俗的要介紹一下Hello-World！-範例"><a href="#不能免俗的要介紹一下Hello-World！-範例" class="headerlink" title="　　不能免俗的要介紹一下Hello World！## 範例"></a>　　不能免俗的要介紹一下Hello World！<br>## 範例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mendel.teaching;</span><br><span class="line"><span class="comment">/* 多行註解</span></span><br><span class="line"><span class="comment"> * 測試第一個class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 顯示在Console的Hello World!</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><p>　　因為Java是典型的物件導向設計的程式語言（請參考<strong>物件導向設計</strong>），所以以上的範例是用類別來寫的。讓我們從頭開始一行一行的看下去吧！</p><blockquote><p><strong>物件導向設計（英語：Object-oriented programming，縮寫：OOP）</strong><br>　　真實世界的事物轉為各種物件，物件之間彼此能互相操作溝通。而產生物件的東西就是類別。類別就如同設計圖一樣，依照此設計圖就能產生一個個的物件。</p></blockquote><ul><li>Line 1：提供「套件」（package）來管理類別，套件被設計與檔案系統結構相對應，如果您的套件設定為org.mendel.teaching，則該類別應該在 Classpath(程式編譯後的位置) 可以存取到的路徑下的 org 目錄下之 mendel 目錄下之 teaching 找到，沒有設定套件管理的類別會歸為「預設套件」（default package）。</li><li>Line 2-4：多行註解</li><li>Line 5：public是存取修飾符(Access Modifiers)，主要是用在其他的物件可否存取這個物件的內容。class就是類別。MyClass就是此類別的名稱，其命名方式是「大駝峰」（類別的命名方式請參考<strong>駝峰式命名</strong>）。</li><li>Line 6：static靜態的意思，此為靜態方法(Method)，也就是不管有幾個物件全都共用這個方法。void代表不回傳值，執行方法之後可以回傳一個值。main此為Java程式的「進入點」（Entry point），也就是程式會從此方法的第一行開始執行。String[] args傳入的參數，呼叫此方法會傳入的字串陣列(Array)的參數(Parameter)。</li><li>Line 7：單行註解</li><li>Line 8：System.out.println此方法會將字串列印在標準輸入輸出裝置(Console)。</li></ul><blockquote><p><strong>駝峰式命名（Camel case）</strong><br>　　* 就像駝峰會一高一低<br>　　* 單字之間不空格，而是直接連起來，但是連起來的第一個字要大寫<br>　　* 例如：有一個 handle add post 的 function，就會叫做 handleAddPost<br>駝峰又有分兩種：<br>　　1. 小駝峰（lower camel case）：開頭是小寫，就像上面的範例 handleAddPost<br>　　2. 大駝峰（upper camel case）：又被稱為 Pascal Case。開頭變成大寫，也就會變成 HandleAddPost</p></blockquote><hr><h2 id="🔧-補充說明：main-方法是什麼？為何一定要有？"><a href="#🔧-補充說明：main-方法是什麼？為何一定要有？" class="headerlink" title="🔧 補充說明：main 方法是什麼？為何一定要有？"></a>🔧 <strong>補充說明：main 方法是什麼？為何一定要有？</strong></h2><ul><li><p><code>main()</code> 是 Java 程式的「進入點」，也就是 JVM（Java Virtual Machine）<strong>啟動後會從這裡開始執行</strong></p></li><li><p>若沒有 <code>main()</code>，JVM 將無法啟動程式，會出現錯誤</p></li><li><p><code>public static void main(String[] args)</code> 解析：</p><ul><li><code>public</code>：讓 JVM 能夠從外部呼叫它</li><li><code>static</code>：代表這個方法「不需要建立物件就能執行」</li><li><code>void</code>：這個方法「不會有回傳值」</li><li><code>String[] args</code>：這是從命令列傳進來的參數（目前可先忽略）</li></ul></li></ul><hr><h2 id="💡-小提醒：類別名稱與檔案名稱需相同！"><a href="#💡-小提醒：類別名稱與檔案名稱需相同！" class="headerlink" title="💡 小提醒：類別名稱與檔案名稱需相同！"></a>💡 <strong>小提醒：類別名稱與檔案名稱需相同！</strong></h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">✔ 正確：HelloWorld.java 裡面 class HelloWorld &#123;&#125;</span><br><span class="line">✘ 錯誤：HelloWorld.java 裡面寫 class Hello &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>否則在編譯時會出現：<strong>類別名稱與檔名不符錯誤</strong></p></blockquote><hr><h2 id="🧠-補充說明：System-out-是什麼？為什麼能印出？"><a href="#🧠-補充說明：System-out-是什麼？為什麼能印出？" class="headerlink" title="🧠 補充說明：System.out 是什麼？為什麼能印出？"></a>🧠 <strong>補充說明：System.out 是什麼？為什麼能印出？</strong></h2><ul><li><code>System.out</code> 是 Java 中預設的輸出裝置，連接到「主控台（Console）」</li><li><code>.println()</code> 是印出一行並換行的方法</li><li>實際上它會呼叫背後的輸出串流（OutputStream）</li></ul><hr><h2 id="🔁-補充說明：程式執行完整流程"><a href="#🔁-補充說明：程式執行完整流程" class="headerlink" title="🔁 補充說明：程式執行完整流程"></a>🔁 <strong>補充說明：程式執行完整流程</strong></h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Step 1. 編寫 Java 程式碼（.java）</span><br><span class="line">Step 2. 使用 javac 編譯成 .class</span><br><span class="line">Step 3. JVM 載入 .class，執行 main 方法</span><br><span class="line">Step 4. 執行到 println()，印出畫面文字</span><br></pre></td></tr></table></figure><hr><h2 id="練習題"><a href="#練習題" class="headerlink" title="練習題"></a>練習題</h2><p>　　1. 試著說明何謂 套件(Package)<br>　　2. 試著說明何謂 main<br>　　3. 試著建立一個類別為Homework，在Console中顯示您的個人資料，例：姓名、年齡、生日、喜好…等等。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 程式設計 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
